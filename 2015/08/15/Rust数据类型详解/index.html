<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="null">
  <meta name="keyword" content="undefined">
  
       <link rel="shortcut icon" href="/css/images/logo.jpg">
  
  <title>
    
      Rust数据类型详解 | kriry
    
  </title>
  <div class="wechat-share">
      <img src="/css/images/logo.png" width='700'/>
  </div>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
</head>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span><strong>kriry</strong></span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link"><strong>Home</strong></a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link"><strong>Tags</strong></a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link"><strong>Archives</strong></a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link"><strong>Projects</strong></a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link"><strong>About</strong></a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Rust数据类型详解</h2>
  <span class="post-date"><strong>2015-08-15 </strong> </span> &nbsp; &nbsp;
  <span> <strong>
  <a href="/tags#Rust" >
    <span class="tag-code">Rust</span>
  </a>
</strong></span> &nbsp; &nbsp;
  <span  class="post-date">
     <span id="busuanzi_container_page_pv"><strong>
    Hits: <span id="busuanzi_value_page_pv"></span></strong></span>
  </span>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!--
        <div class="tags">
          <span style="color:darkorange">Tags:</span>
          
  <a href="/tags#Rust" >
    <span class="tag-code">Rust</span>
  </a>

        </div>
    -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="一：原生类型"><a href="#一：原生类型" class="headerlink" title="一：原生类型"></a>一：原生类型</h1><ul>
<li>布尔类型（bool）：有两个值true和false。</li>
<li>字符类型 (char)：表示单个Unicode值，存储为4个字节。Rust支持(u8)单字节字符b’H’,仅限制于ASCII字符。</li>
<li>数值类型 (int/float)：有符号整数 (i8,i16,i32,i64,isize)、无符号整数 (u8,u16,u32,u64,usize) 浮点数(f32,f64).整形默认为i32，浮点型默认为f64.</li>
<li>字符串类型(str)：Unicode string slices.分为字符串切片&amp;str和堆分配字符串String，字符串切片是静态分配，有固定大小，且不可变，堆分配字符串是可变的。Rust还支持单字节字符串b”Hello”和原始字节字符串使用br#”hello”#，仅限于ASCII字符,不需要对特殊字符进行转义。</li>
<li>指针 ( pointer )：最底层的是裸指针*const T和*mut T，但解引用它们是不安全的，必须放到unsafe块里。</li>
<li>函数 ( fn )：具有函数类型的变量实质上是一个函数指针。</li>
<li>元类型：即()，其唯一的值也是()。</li>
</ul>
<h1 id="二：复合类型"><a href="#二：复合类型" class="headerlink" title="二：复合类型"></a>二：复合类型</h1><ul>
<li>数组  ( array )：具有固定大小，并且元素都是同种类型，表示[T; N]，标准库动态的数组即向量 Vec。不多于32个元素的数组在值传递时是自动复制的.数组切片(&amp;[T])：一个数组引用部分数据并且不需要拷贝，可表示为&amp;[T]。</li>
<li>元组  ( tuple )：固定大小的有序列表，每个元素都有自己的类型，通过解构或者索引来获得元素的值。可使用==和!=运算符来判断是否相同，不多于12个元素的元组在值传递时是自动复制的。</li>
</ul>
<h1 id="三：自定义类型"><a href="#三：自定义类型" class="headerlink" title="三：自定义类型"></a>三：自定义类型</h1><ul>
<li>结构体(struct) : </li>
<li>枚举(enum) : </li>
</ul>
<h1 id="四：标准库数据类型"><a href="#四：标准库数据类型" class="headerlink" title="四：标准库数据类型"></a>四：标准库数据类型</h1><ul>
<li>String : A UTF-8 encoded, growable string.</li>
<li>Box : </li>
<li>Sequences: Vec, VecDeque, LinkedList</li>
<li>Maps: HashMap, BTreeMap</li>
<li>Sets: HashSet, BTreeSet</li>
<li>Misc: BinaryHeap</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>一个<em>字符串</em>是一串UTF-8字节编码的Unicode量级值的序列。所有的字符串都确保是有效编码的UTF-8序列。另外，字符串并不以null结尾并且可以包含null字节。Rust有两种主要的字符串类型：<code>&amp;str</code>和<code>String</code>。让我们先看看<code>&amp;str</code>。这叫做<em>字符串片段</em>（<em>string slices</em>）。字符串常量是<code>&amp;&#39;static str</code>类型的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> greeting = <span class="string">"Hello there."</span>; <span class="comment">// greeting: &amp;'static str</span></div></pre></td></tr></table></figure>
<p><code>&quot;Hello there.&quot;</code>是一个字符串常量而它的类型是<code>&amp;&#39;static str</code>。字符串常量是静态分配的字符串切片，也就是说它储存在我们编译好的程序中，并且整个程序的运行过程中一直存在。这个<code>greeting</code>绑定了一个静态分配的字符串的引用。任何接受一个字符串切片的函数也接受一个字符串常量。</p>
<p>字符串常量可以跨多行。有两种形式。第一种会包含新行符和之前的空格：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="string">"foo</span></div><div class="line">    bar";</div><div class="line"></div><div class="line"><span class="built_in">assert_eq!</span>(<span class="string">"foo\n        bar"</span>, s);</div></pre></td></tr></table></figure>
<p>第二种，带有<code>\</code>，会去掉空格和新行符：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="string">"foo\</span></div><div class="line">    bar";</div><div class="line"></div><div class="line"><span class="built_in">assert_eq!</span>(<span class="string">"foobar"</span>, s);</div></pre></td></tr></table></figure>
<p>Rust 当然不仅仅只有<code>&amp;str</code>。一个<code>String</code>，是一个在堆上分配的字符串。这个字符串可以增长，并且也保证是UTF-8编码的。<code>String</code>通常通过一个字符串片段调用<code>to_string</code>方法转换而来。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="string">"Hello"</span>.to_string(); <span class="comment">// mut s: String</span></div><div class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</div><div class="line"></div><div class="line">s.push_str(<span class="string">", world."</span>);</div><div class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</div></pre></td></tr></table></figure>
<p><code>String</code>可以通过一个<code>&amp;</code>强制转换为<code>&amp;str</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_slice</span></span>(slice: &amp;<span class="built_in">str</span>) &#123;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, slice);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> s = <span class="string">"Hello"</span>.to_string();</div><div class="line">    takes_slice(&amp;s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种强制转换并不发生在接受<code>&amp;str</code>的trait而不是<code>&amp;str</code>本身作为参数的函数上。例如，<a href="http://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.connect" target="_blank" rel="external">TcpStream::connect</a>，有一个<code>ToSocketAddrs</code>类型的参数。<code>&amp;str</code>可以不用转换不过<code>String</code>必须使用<code>&amp;*</code>显式转换。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::net::TcpStream;</div><div class="line"></div><div class="line">TcpStream::connect(<span class="string">"192.168.0.1:3000"</span>); <span class="comment">// &amp;str parameter</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> addr_string = <span class="string">"192.168.0.1:3000"</span>.to_string();</div><div class="line">TcpStream::connect(&amp;*addr_string); <span class="comment">// convert addr_string to &amp;str</span></div></pre></td></tr></table></figure>
<p>把<code>String</code>转换为<code>&amp;str</code>的代价很小，不过从<code>&amp;str</code>转换到<code>String</code>涉及到分配内存。除非必要，没有理由这样做！</p>
<h2 id="索引（Indexing）"><a href="#索引（Indexing）" class="headerlink" title="索引（Indexing）"></a>索引（Indexing）</h2><p>因为字符串是有效UTF-8编码的，它不支持索引：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="string">"hello"</span>;</div><div class="line"></div><div class="line"><span class="built_in">println!</span>(<span class="string">"The first letter of s is &#123;&#125;"</span>, s[<span class="number">0</span>]); <span class="comment">// ERROR!!!</span></div></pre></td></tr></table></figure>
<p>通常，用<code>[]</code>访问一个数组是非常快的。不过，字符串中每个UTF-8编码的字符可以是多个字节，你必须遍历字符串来找到字符串的第N个字符。这个操作的代价相当高，而且我们不想误导读者。更进一步来讲，Unicode实际上并没有定义什么“字符”。我们可以选择把字符串看作一个串独立的字节，或者代码点（codepoints）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> hachiko = <span class="string">"忠犬ハチ公"</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> b <span class="keyword">in</span> hachiko.as_bytes() &#123;</div><div class="line">    <span class="built_in">print!</span>(<span class="string">"&#123;&#125;, "</span>, b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">println!</span>(<span class="string">""</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> c <span class="keyword">in</span> hachiko.chars() &#123;</div><div class="line">    <span class="built_in">print!</span>(<span class="string">"&#123;&#125;, "</span>, c);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">println!</span>(<span class="string">""</span>);</div></pre></td></tr></table></figure>
<p>这会打印出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,</div><div class="line">忠, 犬, ハ, チ, 公,</div></pre></td></tr></table></figure>
<p>如你所见，这有比<code>char</code>更多的字节。</p>
<p>你可以这样来获取跟索引相似的东西：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># <span class="keyword">let</span> hachiko = <span class="string">"忠犬ハチ公"</span>;</div><div class="line"><span class="keyword">let</span> dog = hachiko.chars().nth(<span class="number">1</span>); <span class="comment">// kinda like hachiko[1]</span></div></pre></td></tr></table></figure>
<p>这强调了我们不得不遍历整个<code>char</code>的列表。</p>
<p>你可以使用切片语法来获取一个字符串的切片：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> dog = <span class="string">"hachiko"</span>;</div><div class="line"><span class="keyword">let</span> hachi = &amp;dog[<span class="number">0</span>..<span class="number">5</span>];</div></pre></td></tr></table></figure>
<p>注意这里是<em>字节</em>偏移，而不是<em>字符</em>偏移。所以如下代码在运行时会失败：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> dog = <span class="string">"忠犬ハチ公"</span>;</div><div class="line"><span class="keyword">let</span> hachi = &amp;dog[<span class="number">0</span>..<span class="number">2</span>];</div></pre></td></tr></table></figure>
<p>给出如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">thread &apos;&lt;main&gt;&apos; panicked at &apos;index 0 and/or 2 in `忠犬ハチ公` do not lie on</div><div class="line">character boundary&apos;</div></pre></td></tr></table></figure>
<h3 id="拼接字符串：-结果是String"><a href="#拼接字符串：-结果是String" class="headerlink" title="拼接字符串：(结果是String)"></a>拼接字符串：(结果是String)</h3><ol>
<li>&amp;str不能直接拼接，</li>
<li>拼接的首个字符串必须是String，之后的String需要一个 &amp; 转换成 &amp;str，这个功能叫做 Deref  转换。</li>
<li>满足1，2条件的String与&amp;str可以多个交叉拼接。</li>
</ol>
<p>这是因为<code>&amp;String</code>可以自动转换为一个<code>&amp;str</code>。这个功能叫做<strong> <code>Deref</code>转换</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span>    hello      =  <span class="string">"Hello"</span>.to_string();        <span class="comment">// String</span></div><div class="line"><span class="keyword">let</span>    hello_str  =  <span class="string">"Hello!"</span>;                 <span class="comment">// &amp;'static str</span></div><div class="line"><span class="keyword">let</span>    world      =  <span class="string">"World!"</span>.to_string();      </div><div class="line"><span class="keyword">let</span>    world_str  =  <span class="string">"World!"</span>;             </div><div class="line"><span class="keyword">let</span>    tom        =  <span class="string">"tom!"</span>.to_string();  </div><div class="line"><span class="keyword">let</span>    tom_str    =  <span class="string">"tom!"</span>;</div><div class="line"><span class="keyword">let</span>    lucy       =  <span class="string">"lucy!"</span>.to_string();  </div><div class="line"><span class="keyword">let</span>    lucy_str   =  <span class="string">"lucy!"</span>;</div><div class="line"><span class="keyword">let</span>    lilei      =  <span class="string">"lilei!"</span>.to_string();  </div><div class="line"><span class="keyword">let</span>    lilei_str  =  <span class="string">"lilei!"</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span>    hello_world  =  hello + world_str;</div><div class="line"><span class="keyword">let</span>    hello_world  =  hello + &amp;world;</div><div class="line"><span class="keyword">let</span>    hello_world  =  hello + world_str + tom_str + lucy_str;</div><div class="line"><span class="keyword">let</span>    hello_world  =  hello + &amp;world + &amp;tom + &amp;lucy;</div><div class="line"><span class="keyword">let</span>    hello_world  =  hello + hello_str + &amp;world + world_str + tom_str + &amp;tom + &amp;lucy + &amp;lilei + lucy_str + lilei_str;</div></pre></td></tr></table></figure>
<h2 id="元组（Tuples）"><a href="#元组（Tuples）" class="headerlink" title="元组（Tuples）"></a>元组（Tuples）</h2><p>元组（tuples）是固定大小的有序列表。如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = (<span class="number">1</span>, <span class="string">"hello"</span>);</div><div class="line"><span class="keyword">let</span> x: (<span class="built_in">i32</span>, &amp;<span class="built_in">str</span>) = (<span class="number">1</span>, <span class="string">"hello"</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = (<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// x: (i32, i32)</span></div><div class="line"><span class="keyword">let</span> y = (<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// y: (i32, i32)</span></div><div class="line"><span class="keyword">let</span>	e	=	x.<span class="number">1</span>;</div><div class="line">x = y;</div></pre></td></tr></table></figure>
<p>你可以通过一个<em>解构let</em>（<em>destructuring let</em>）访问元组中的字段。下面是一个例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> (x, y, z) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="built_in">println!</span>(<span class="string">"x is &#123;&#125;"</span>, x);</div></pre></td></tr></table></figure>
<p>可以在<code>let</code>左侧写一个模式，如果它能匹配右侧的话，我们可以一次写多个绑定。这种情况下，<code>let</code>“解构”或“拆开”了元组，并分成了三个绑定。</p>
<p>你可以一个逗号来消除一个单元素元组和一个括号中的值的歧义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="number">0</span>,); <span class="comment">// single-element tuple</span></div><div class="line">(<span class="number">0</span>); <span class="comment">// zero</span></div></pre></td></tr></table></figure>
<h3 id="元组索引（Tuple-Indexing）"><a href="#元组索引（Tuple-Indexing）" class="headerlink" title="元组索引（Tuple Indexing）"></a>元组索引（Tuple Indexing）</h3><p>你也可以用索引语法访问一个元组的字段,它使用<code>.</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> x = tuple.<span class="number">0</span>;</div><div class="line"><span class="built_in">println!</span>(<span class="string">"x is &#123;&#125;"</span>, x);</div></pre></td></tr></table></figure>
<h3 id="数组-array-与Vec"><a href="#数组-array-与Vec" class="headerlink" title="数组(array)与Vec"></a>数组(array)与Vec</h3><p><strong>定义数组</strong>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> array: [<span class="built_in">i32</span>; <span class="number">3</span>] = [<span class="number">0</span>; <span class="number">3</span>];   <span class="comment">// 方式一</span></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">8</span>,	<span class="number">9</span>,	<span class="number">10</span>];            <span class="comment">// 方式二</span></div><div class="line">array[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line">array[<span class="number">2</span>] = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="built_in">assert_eq!</span>([<span class="number">1</span>, <span class="number">2</span>], &amp;array[<span class="number">1</span>..]);</div><div class="line"></div><div class="line"><span class="comment">// This loop prints: 0 1 2</span></div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> &amp;array &#123;</div><div class="line">    <span class="built_in">print!</span>(<span class="string">"&#123;&#125; "</span>, x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> Vec : pronounced ‘Vector’是一个动态或“可增长”的数组，被实现为标准库类型<a href="http://doc.rust-lang.org/std/Vec/" target="_blank" rel="external"><code>Vec&lt;T&gt;</code></a>（其中<code>&lt;T&gt;</code>是一个<a href="Generics 泛型.md">泛型</a>语句）。Vec总是在堆上分配数据。Vec与数组切片就像<code>String</code>与<code>&amp;str</code>一样。你可以使用<code>vec!</code>宏来创建它：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();    <span class="comment">// 方式一</span></div><div class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];    <span class="comment">// v: Vec&lt;i32&gt;   方式二</span></div><div class="line"><span class="keyword">let</span>	v2 = <span class="built_in">vec!</span>[<span class="number">0</span>;<span class="number">10</span>];	        <span class="comment">//	声明一个初始长度为10的值全为0的动态数组</span></div></pre></td></tr></table></figure>
<p>（与我们之前使用<code>println!</code>宏时不一样，我们在<code>vec!</code>中使用中括号<code>[]</code>。为了方便，Rust 允许你使用上述各种情况。）</p>
<p>对于重复初始值有另一种形式的<code>vec!</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">10</span>]; <span class="comment">// ten zeroes</span></div></pre></td></tr></table></figure>
<h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><p>为了Vec特定索引的值，我们使用<code>[]</code>,索引从<code>0</code>开始，所以第3个元素是<code>v[2]</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"><span class="keyword">let</span> r0 = v[<span class="number">1</span>];</div><div class="line"><span class="keyword">let</span> r1 = &amp;v[<span class="number">2</span>];             <span class="comment">//当引用一个不存在的元素时，会造成panic!.</span></div><div class="line"><span class="keyword">let</span> r2 = v.get(<span class="number">3</span>);           <span class="comment">//当引用一个不存在的元素时，返回None.</span></div><div class="line"><span class="built_in">println!</span>(<span class="string">"The third element of v is&#123;&#125;, &#123;&#125;,&#123;&#125;"</span>, r0, r1,r2);</div></pre></td></tr></table></figure>
<p>另外值得注意的是你必须用<code>usize</code>类型的值来索引：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="keyword">let</span> i: <span class="built_in">usize</span> = <span class="number">0</span>;</div><div class="line"><span class="keyword">let</span> j: <span class="built_in">i32</span> = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// works</span></div><div class="line">v[i];</div><div class="line"></div><div class="line"><span class="comment">// doesn’t</span></div><div class="line">v[j];</div></pre></td></tr></table></figure>
<p>用非<code>usize</code>类型索引的话会给出类似如下的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">error: the trait `core::ops::Index&lt;i32&gt;` is not implemented for the type</div><div class="line">`collections::Vec::Vec&lt;_&gt;` [E0277]</div><div class="line">v[j];</div><div class="line">^~~~</div><div class="line">note: the type `collections::Vec::Vec&lt;_&gt;` cannot be indexed by `i32`</div><div class="line">error: aborting due to previous error</div></pre></td></tr></table></figure>
<p>信息中有很多标点符号，不过核心意思是：你不能用<code>i32</code>来索引。</p>
<h4 id="越界访问（Out-of-bounds-Access）"><a href="#越界访问（Out-of-bounds-Access）" class="headerlink" title="越界访问（Out-of-bounds Access）"></a>越界访问（Out-of-bounds Access）</h4><p>如果你尝试访问并不存在的索引：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="built_in">println!</span>(<span class="string">"Item 7 is &#123;&#125;"</span>, v[<span class="number">7</span>]);</div></pre></td></tr></table></figure>
<p>那么当前的线程会<strong>panic</strong>并输出如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thread &apos;&lt;main&gt;&apos; panicked at &apos;index out of bounds: the len is 3 but the index is 7&apos;</div></pre></td></tr></table></figure>
<p>如果你想处理越界错误而不是 panic，你可以使用像<a href="http://doc.rust-lang.org/std/Vec/struct.Vec.html#method.get" target="_blank" rel="external"><code>get</code></a>或<a href="http://doc.rust-lang.org/std/Vec/struct.Vec.html#method.get" target="_blank" rel="external"><code>get_mut</code></a>这样的方法，他们当给出一个无效的索引时返回<code>None</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">match</span> v.get(<span class="number">7</span>) &#123;</div><div class="line">    <span class="literal">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">"Item 7 is &#123;&#125;"</span>, x),</div><div class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Sorry, this Vector is too short."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用枚举来储存多种类型<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SpreadsheetCell</span></span> &#123;</div><div class="line">    Int(<span class="built_in">i32</span>),</div><div class="line">    Float(<span class="built_in">f64</span>),</div><div class="line">    Text(<span class="built_in">String</span>),</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> row = <span class="built_in">vec!</span>[</div><div class="line">    SpreadsheetCell::Int(<span class="number">3</span>),</div><div class="line">    SpreadsheetCell::Text(<span class="built_in">String</span>::from(<span class="string">"blue"</span>)),</div><div class="line">    SpreadsheetCell::Float(<span class="number">10.12</span>),</div><div class="line">];</div></pre></td></tr></table></figure></p>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>当你有了一个Vector，我可以用<code>for</code>来迭代它的元素。有3个版本：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"A reference to &#123;&#125;"</span>, i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"A mutable reference to &#123;&#125;"</span>, i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v &#123;</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"Take ownership of the Vector and its element &#123;&#125;"</span>, i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Vector还有很多有用的方法，你可以看看<a href="http://doc.rust-lang.org/nightly/std/Vec/" target="_blank" rel="external">Vector的API文档</a>了解它们。</p>
<h2 id="数组切片（Slices）"><a href="#数组切片（Slices）" class="headerlink" title="数组切片（Slices）"></a>数组切片（Slices）</h2><p>一个<em>切片</em>（<em>slice</em>）是一个数组的引用（或者“视图”）。它有利于安全，有效的访问数组的一部分而不用进行拷贝。比如，你可能只想要引用读入到内存的文件中的一行。原理上，片段并不是直接创建的，而是引用一个已经存在的变量。片段有预定义的长度，可以是可变也可以是不可变的。</p>
<h3 id="切片语法"><a href="#切片语法" class="headerlink" title="切片语法"></a>切片语法</h3><p>你可以用一个<code>&amp;</code>和<code>[]</code>的组合从多种数据类型创建一个切片。<code>&amp;</code>表明切片类似于<strong>引用</strong>，带有一个范围的<code>[]</code>，允许你定义切片的长度：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">let</span> complete = &amp;a[..]; <span class="comment">// A slice containing all of the elements in a</span></div><div class="line"><span class="keyword">let</span> middle = &amp;a[<span class="number">1</span>..<span class="number">4</span>]; <span class="comment">// A slice of a: just the elements 1, 2, and 3</span></div></pre></td></tr></table></figure>
<p>片段拥有<code>&amp;[T]</code>类型。当我们涉及到<strong>泛型</strong>时会讨论这个<code>T</code>。</p>
<p>你可以在<a href="http://doc.rust-lang.org/stable/std/primitive.slice.html" target="_blank" rel="external">标准库文档</a>中找到更多关于<code>slices</code>的文档。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数也有一个类型！它们看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; x &#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> x: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> = foo;</div></pre></td></tr></table></figure>
<p>在这个例子中，<code>x</code>是一个“函数指针”，指向一个获取一个<code>i32</code>参数并返回一个<code>i32</code>值的函数。</p>
<h2 id="表达式-VS-语句"><a href="#表达式-VS-语句" class="headerlink" title="表达式 VS 语句"></a>表达式 VS 语句</h2><p>Rust 主要是一个基于表达式的语言。只有两种语句，其它的一切都是表达式。</p>
<p>表达式返回一个值，而语句不是。这就是为什么这里我们以“不是所有控制路径都返回一个值”结束：<code>x + 1;</code>语句不返回一个值。Rust 中有两种类型的语句：“声明语句”和“表达式语句”。其余的一切是表达式。让我们先讨论下声明语句。</p>
<p>在 Rust 中，使用<code>let</code>引入一个绑定并<em>不是</em>一个表达式。下面的代码会产生一个编译时错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = (<span class="keyword">let</span> y = <span class="number">5</span>); <span class="comment">// expected identifier, found keyword `let`</span></div></pre></td></tr></table></figure>
<p>编译器告诉我们这里它期望看到表达式的开头，而<code>let</code>只能开始一个语句，不是一个表达式。</p>
<p>注意赋值一个已经绑定过的变量（例如，<code>y = 5</code>）仍是一个表达式，即使它的（返回）值并不是特别有用。不像其它语言中赋值语句返回它赋的值（例如，前面例子中的<code>5</code>），在 Rust 中赋值的值是一个空的元组<code>()</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> y = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> x = (y = <span class="number">6</span>);  <span class="comment">// x has the value `()`, not `6`</span></div></pre></td></tr></table></figure>
<p>Rust中第二种语句是<em>表达式语句</em>。它的目的是把任何表达式变为语句。在实践环境中，Rust 语法期望语句后跟其它语句。这意味着你用分号来分隔各个表达式。这意味着Rust看起来很像大部分其它使用分号做为语句结尾的语言，并且你会看到分号出现在几乎每一行你看到的 Rust 代码。</p>
<p>那么我们说“几乎”的例外是神马呢？你已经见过它了，在这些代码中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</div><div class="line">    x + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们的函数声称它返回一个<code>i32</code>，不过带有一个分号，它会返回一个<code>()</code>。Rust意识到这可能不是我们想要的，并在我们之前看到的错误中建议我们去掉分号。</p>
<h2 id="提早返回（Early-returns）"><a href="#提早返回（Early-returns）" class="headerlink" title="提早返回（Early returns）"></a>提早返回（Early returns）</h2><p>不过提早返回,Rust确实有这么一个关键字，<code>return</code>,使用<code>return</code>作为函数的最后一行是可行的，不过被认为是一个糟糕的风格：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line"></div><div class="line">    <span class="comment">// we never run this code!</span></div><div class="line">    x + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="发散函数（Diverging-functions）"><a href="#发散函数（Diverging-functions）" class="headerlink" title="发散函数（Diverging functions）"></a>发散函数（Diverging functions）</h2><p>Rust有些特殊的语法叫“发散函数”，这些函数并不返回：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">diverges</span></span>() -&gt; ! &#123;</div><div class="line">    <span class="built_in">panic!</span>(<span class="string">"This function never returns!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>panic!</code>是一个宏，类似我们已经见过的<code>println!()</code>。与<code>println!()</code>不同的是，<code>panic!()</code>导致当前的执行线程崩溃并返回指定的信息。因为这个函数会崩溃，所以它不会返回，所以它拥有一个类型<code>!</code>，它代表“发散”。</p>
<p>如果你添加一个叫做<code>diverges()</code>的函数并运行，你将会得到一些像这样的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thread ‘&lt;main&gt;’ panicked at ‘This function never returns!’, hello.rs:2</div></pre></td></tr></table></figure>
<p>如果你想要更多信息，你可以设定<code>RUST_BACKTRACE</code>环境变量来获取 backtrace ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ RUST_BACKTRACE=1 ./diverges</div><div class="line">thread <span class="string">'&lt;main&gt;'</span> panicked at <span class="string">'This function never returns!'</span>, hello.rs:2</div><div class="line">stack backtrace:</div><div class="line">   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r</div><div class="line">   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w</div><div class="line">   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw</div><div class="line">   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650</div><div class="line">   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa</div><div class="line">   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa</div><div class="line">   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231</div><div class="line">   8:     0x7f402773d1d8 - __rust_try</div><div class="line">   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w</div><div class="line">  10:     0x7f4027738a19 - main</div><div class="line">  11:     0x7f402694ab44 - __libc_start_main</div><div class="line">  12:     0x7f40277386c8 - &lt;unknown&gt;</div><div class="line">  13:                0x0 - &lt;unknown&gt;</div></pre></td></tr></table></figure>
<p><code>RUST_BACKTRACE</code>也可以用于 Cargo 的<code>run</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ RUST_BACKTRACE=1 cargo run</div><div class="line">     Running `target/debug/diverges`</div><div class="line">thread <span class="string">'&lt;main&gt;'</span> panicked at <span class="string">'This function never returns!'</span>, hello.rs:2</div><div class="line">stack backtrace:</div><div class="line">   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r</div><div class="line">   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w</div><div class="line">   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw</div><div class="line">   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650</div><div class="line">   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa</div><div class="line">   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa</div><div class="line">   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231</div><div class="line">   8:     0x7f402773d1d8 - __rust_try</div><div class="line">   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w</div><div class="line">  10:     0x7f4027738a19 - main</div><div class="line">  11:     0x7f402694ab44 - __libc_start_main</div><div class="line">  12:     0x7f40277386c8 - &lt;unknown&gt;</div><div class="line">  13:                0x0 - &lt;unknown&gt;</div></pre></td></tr></table></figure>
<p>发散函数可以被用作任何类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">diverges</span></span>() -&gt; ! &#123;</div><div class="line">   <span class="built_in">panic!</span>(<span class="string">"This function never returns!"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> x: <span class="built_in">i32</span> = diverges();</div><div class="line"><span class="keyword">let</span> x: <span class="built_in">String</span> = diverges();</div></pre></td></tr></table></figure>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>我们也可以创建指向函数的变量绑定：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> f: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>;</div></pre></td></tr></table></figure>
<p><code>f</code>是一个指向一个获取<code>i32</code>作为参数并返回<code>i32</code>的函数的变量绑定。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(i: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</div><div class="line">    i + <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// without type inference</span></div><div class="line"><span class="keyword">let</span> f: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> = plus_one;</div><div class="line"></div><div class="line"><span class="comment">// with type inference</span></div><div class="line"><span class="keyword">let</span> f = plus_one;</div></pre></td></tr></table></figure>
<p>你可以用<code>f</code>来调用这个函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># <span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(i: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; i + <span class="number">1</span> &#125;</div><div class="line"># <span class="keyword">let</span> f = plus_one;</div><div class="line"><span class="keyword">let</span> six = f(<span class="number">5</span>);</div></pre></td></tr></table></figure>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>  高阶函数与普通函数的不同在于，它可以使用一个或多个函数作为参数，可以将函数作为返回值。rust的函数是first class type，所以支持高阶函数。而，由于rust是一个强类型的语言，如果要将函数作为参数或返回值，首先需要搞明白函数的类型。下面先说函数的类型，再说函数作为参数和返回值。</p>
<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>  前面说过，关键字<code>fn</code>可以用来定义函数。除此以外，它还用来构造函数类型。与函数定义主要的不同是，构造函数类型不需要函数名、参数名和函数体。在Rust Reference中的描述如下：</p>
<blockquote>
<p>The function type constructor fn forms new function types. A function type consists of a possibly-empty set of function-type modifiers (such as unsafe or extern), a sequence of input types and an output type.</p>
</blockquote>
<p>  来看一个简单例子：<br>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">inc</span></span>(n: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;<span class="comment">//函数定义</span></div><div class="line">  n + <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">IncType</span></span> = <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>;<span class="comment">//函数类型</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">  <span class="keyword">let</span> func: IncType = inc;</div><div class="line">  <span class="built_in">println!</span>(<span class="string">"3 + 1 = &#123;&#125;"</span>, func(<span class="number">3</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  上例首先使用<code>fn</code>定义了<code>inc</code>函数，它有一个<code>i32</code>类型参数，返回<code>i32</code>类型的值。然后再用<code>fn</code>定义了一个函数类型，这个函数类型有i32类型的参数和i32类型的返回值，并用<code>type</code>关键字定义了它的别名<code>IncType</code>。在<code>main</code>函数中定义了一个变量<code>func</code>，其类型就为<code>IncType</code>，并赋值为<code>inc</code>，然后在<code>pirntln</code>宏中调用：<code>func(3)</code>。可以看到，<code>inc</code>函数的类型其实就是<code>IncType</code>。<br>  这里有一个问题，我们将<code>inc</code>赋值给了<code>func</code>，而不是<code>&amp;inc</code>，这样是将<code>inc</code>函数的拥有权转给了<code>func</code>吗，赋值后还可以以<code>inc()</code>形式调用<code>inc</code>函数吗？先来看一个例子：<br>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">  <span class="keyword">let</span> func: IncType = inc;</div><div class="line">  <span class="built_in">println!</span>(<span class="string">"3 + 1 = &#123;&#125;"</span>, func(<span class="number">3</span>));</div><div class="line">  <span class="built_in">println!</span>(<span class="string">"3 + 1 = &#123;&#125;"</span>, inc(<span class="number">3</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">IncType</span></span> = <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">inc</span></span>(n: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</div><div class="line">  n + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  我们将上例保存在rs源文件中，再用rustc编译，发现并没有报错，并且运行也得到我们想要的结果：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3 + 1 = 4</div><div class="line">3 + 1 = 4</div></pre></td></tr></table></figure></p>
<p>  这说明，赋值时，<code>inc</code>函数的所有权并没有被转移到<code>func</code>变量上，而是更像不可变引用。在rust中，函数的所有权是不能转移的，我们给函数类型的变量赋值时，赋给的一般是函数的指针，所以rust中的函数类型，就像是C/C++中的函数指针，当然，rust的函数类型更安全。可见，rust的函数类型，其实应该是属于指针类型（Pointer Type）。rust的Pointer Type有两种，一种为引用（Reference<code>&amp;</code>），另一种为原始指针（Raw pointer <code>*</code>），详细内容请看<a href="http://doc.rust-lang.org/reference.html#pointer-types" target="_blank" rel="external">Rust Reference 8.18 Pointer Types</a>。而rust的函数类型应是引用类型，因为它是安全的，而原始指针则是不安全的，要使用原始指针，必须使用<code>unsafe</code>关键字声明。</p>
<h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><p>  函数作为参数，其声明与普通参数一样。看下例：<br>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">  <span class="built_in">println!</span>(<span class="string">"3 + 1 = &#123;&#125;"</span>, process(<span class="number">3</span>, inc));</div><div class="line">  <span class="built_in">println!</span>(<span class="string">"3 - 1 = &#123;&#125;"</span>, process(<span class="number">3</span>, dec));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">inc</span></span>(n: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</div><div class="line">  n + <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">dec</span></span>(n: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</div><div class="line">  n - <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>(n: <span class="built_in">i32</span>, func: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</div><div class="line">  func(n)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  例子中，<code>process</code>就是一个高阶函数，它有两个参数，一个类型为<code>i32</code>的<code>n</code>，另一个类型为<code>fn(i32)-&gt;i32</code>的函数<code>func</code>，返回一个<code>i32</code>类型的参数；它在函数体内以<code>n</code>作为参数调用<code>func</code>函数，返回<code>func</code>函数的返回值。运行可以得到以下结果：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3 + 1 = 4</div><div class="line">3 - 1 = 2</div></pre></td></tr></table></figure></p>
<p>  不过，这不是函数作为参数的唯一声明方法，使用泛型函数配合特质（<code>trait</code>）也是可以的，因为rust的函数都会实现一个<code>trait</code>:<code>FnOnce</code>、<code>Fn</code>或<code>FnMut</code>。将上例中的<code>process</code>函数定义换成以下形式是等价的：<br>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">process</span></span>&lt;F&gt;(n: <span class="built_in">i32</span>, func: F) -&gt; <span class="built_in">i32</span></div><div class="line">    <span class="keyword">where</span> F: <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</div><div class="line">    func(n)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>  函数作为返回值，其生命与普通函数的返回值类型声明一样。看例子：<br>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">   <span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>];</div><div class="line">   <span class="keyword">let</span> <span class="keyword">mut</span> b = <span class="built_in">Vec</span>::&lt;<span class="built_in">i32</span>&gt;::new();</div><div class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> &amp;a &#123;</div><div class="line">       b.push(get_func(*i)(*i));</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_func</span></span>(n: <span class="built_in">i32</span>) -&gt; <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">inc</span></span>(n: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</div><div class="line">        n + <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">dec</span></span>(n: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</div><div class="line">        n - <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> &#123;</div><div class="line">        inc</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dec</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  例子中的高阶函数为<code>get_func</code>，它接收一个i32类型的函数，返回一个类型为<code>fn(i32) -&gt; i32</code>的函数，若传入的参数为偶数，返回<code>inc</code>，否则返回<code>dec</code>。这里需要注意的是，<code>inc</code>函数和<code>dec</code>函数都定义在<code>get_func</code>内。在函数内定义函数在很多其他语言中是不支持的，不过rust支持，这也是rust灵活和强大的一个体现。不过，在函数中定义的函数，不能包含函数中（环境中）的变量，若要包含，应该闭包。</p>
<h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h4><p>rust的函数不支持多返回值,但是我们可以利用元组来返回多个值,配合rust的模式匹配,使用起来十分灵活。先看例子:<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> (p2,p3) = pow_2_3(<span class="number">789</span>);</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"pow 2 of 789 is &#123;&#125;."</span>, p2);</div><div class="line">	<span class="built_in">println!</span>(<span class="string">"pow 3 of 789 is &#123;&#125;."</span>, p3);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">pow_2_3</span></span>(n: <span class="built_in">i32</span>) -&gt; (<span class="built_in">i32</span>, <span class="built_in">i32</span>) &#123;</div><div class="line">	(n*n, n*n*n)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到,上例中, pow_2_3函数接收一个i32类型的值,返回其二次方和三次方的值,这两个值包装在一个元组中返回。在 main函数中, let语句就可以使用模式匹配将函数返回的元组进行解构,将这两个返回值分别赋给 p2和p3,从而可以得到 789二次方的值和三次方的值。</p>
<h1 id="二：复合类型-1"><a href="#二：复合类型-1" class="headerlink" title="二：复合类型"></a>二：复合类型</h1><h2 id="1-结构体"><a href="#1-结构体" class="headerlink" title="1. 结构体"></a>1. 结构体</h2><p>结构体是一个创建更复杂数据类型的方法,大写字母开头并且驼峰命名法.结构体中的值默认是不可变的.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</div><div class="line">    x: <span class="built_in">i32</span>,</div><div class="line">    y: <span class="built_in">i32</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> origin = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;; <span class="comment">// origin: Point</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> <span class="keyword">do</span> = Point &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;;</div><div class="line">    <span class="keyword">do</span>.x = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="built_in">println!</span>(<span class="string">"The origin is at (&#123;&#125;, &#123;&#125;)"</span>, origin.x, origin.y);</div><div class="line">    <span class="built_in">println!</span>(<span class="string">"The origin is at (&#123;&#125;, &#123;&#125;)"</span>, <span class="keyword">do</span>.x, <span class="keyword">do</span>.y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Rust 在语言级别不支持字段可变性，可变性是绑定的一个属性，不是结构体自身的。如果你习惯于字段级别的可变性，这开始可能看起来有点奇怪，不过这样明显地简化了问题。它甚至可以让你使变量只可变一段临时时间：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</div><div class="line">    x: <span class="built_in">i32</span>,</div><div class="line">    y: <span class="built_in">i32</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> point = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;;</div><div class="line"></div><div class="line">    point.x = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> point = point; <span class="comment">// now immutable</span></div><div class="line"></div><div class="line">    point.y = <span class="number">6</span>; <span class="comment">// this causes an error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你的结构体仍然可以包含<code>&amp;mut</code>指针，它会给你一些类型的可变性：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</div><div class="line">    x: <span class="built_in">i32</span>,</div><div class="line">    y: <span class="built_in">i32</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PointRef</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</div><div class="line">    x: &amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="built_in">i32</span>,</div><div class="line">    y: &amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="built_in">i32</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</div><div class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> point = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> r = PointRef &#123; x: &amp;<span class="keyword">mut</span> point.x, y: &amp;<span class="keyword">mut</span> point.y &#125;;</div><div class="line"></div><div class="line">        *r.x = <span class="number">5</span>;</div><div class="line">        *r.y = <span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, point.x);</div><div class="line">    <span class="built_in">assert_eq!</span>(<span class="number">6</span>, point.y);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="更新语法（Update-syntax）"><a href="#更新语法（Update-syntax）" class="headerlink" title="更新语法（Update syntax）"></a>更新语法（Update syntax）</h2><p>一个包含<code>..</code>的<code>struct</code>表明你想要使用一些其它结构体的拷贝的一些值。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point3d</span></span> &#123;</div><div class="line">    x: <span class="built_in">i32</span>,</div><div class="line">    y: <span class="built_in">i32</span>,</div><div class="line">    z: <span class="built_in">i32</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="keyword">mut</span> point = Point3d &#123; x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span> &#125;;</div><div class="line">point = Point3d &#123; y: <span class="number">1</span>, .. point &#125;;</div></pre></td></tr></table></figure>
<p>这给了<code>point</code>一个新的<code>y</code>，不过保留了<code>x</code>和<code>z</code>的值。这也并不必要是同样的<code>struct</code>，你可以在创建新结构体时使用这个语法，并会拷贝你未指定的值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">Point3d</span></span> &#123;</div><div class="line">#     x: <span class="built_in">i32</span>,</div><div class="line">#     y: <span class="built_in">i32</span>,</div><div class="line">#     z: <span class="built_in">i32</span>,</div><div class="line"># &#125;</div><div class="line"><span class="keyword">let</span> origin = Point3d &#123; x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span> &#125;;</div><div class="line"><span class="keyword">let</span> point = Point3d &#123; z: <span class="number">1</span>, x: <span class="number">2</span>, .. origin &#125;;</div></pre></td></tr></table></figure>
<h2 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h2><p>Rust有像另一个<a href="Primitive Types 原生类型.md#tuples">元组</a>和结构体的混合体的数据类型。元组结构体有一个名字，不过它的字段没有。他们用<code>struct</code>关键字声明，并元组前面带有一个名字：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</div><div class="line"></div><div class="line"><span class="comment">//这里`black`和`origin`并不相等，即使它们有一模一样的值：</span></div><div class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>使用结构体几乎总是好于使用元组结构体。不过有种情况元组结构体非常有用，就是当元组结构体只有一个元素时。我们管它叫<em>新类型</em>（<em>newtype</em>），因为你创建了一个与元素相似的类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inches</span></span>(<span class="built_in">i32</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> length = Inches(<span class="number">10</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> Inches(integer_length) = length;</div><div class="line"><span class="built_in">println!</span>(<span class="string">"length is &#123;&#125; inches"</span>, integer_length);</div></pre></td></tr></table></figure>
<p>如你所见，你可以通过一个解构<code>let</code>来提取内部的整型，就像我们在讲元组时说的那样，<code>let Inches(integer_length)</code>给<code>integer_length</code>赋值为<code>10</code>。</p>
<h2 id="类单元结构体（Unit-like-structs）"><a href="#类单元结构体（Unit-like-structs）" class="headerlink" title="类单元结构体（Unit-like structs）"></a>类单元结构体（Unit-like structs）</h2><p>你可以定义一个没有任何成员的结构体：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Electron</span></span> &#123;&#125; <span class="comment">// Use empty braces...</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proton</span></span>;     <span class="comment">// ...or just a semicolon.</span></div><div class="line"></div><div class="line"><span class="comment">// Use the same notation when creating an instance.</span></div><div class="line"><span class="keyword">let</span> x = Electron &#123;&#125;;</div><div class="line"><span class="keyword">let</span> y = Proton;</div></pre></td></tr></table></figure>
<p>这样的结构体叫做“类单元”因为它与一个空元组类似，<code>()</code>，这有时叫做“单元”。就像一个元组结构体，它定义了一个新类型。</p>
<p>就它本身来看没什么用（虽然有时它可以作为一个标记类型），不过在与其它功能的结合中，它可以变得有用。例如，一个库可能请求你创建一个实现了一个特定特性的结构来处理事件。如果你并不需要在结构中存储任何数据，你可以仅仅创建一个类单元结构体。</p>
<h2 id="2-枚举"><a href="#2-枚举" class="headerlink" title="2. 枚举"></a>2. 枚举</h2><p>Rust 中的一个<code>enum</code>是一个代表数个可能变量的数据的类型。每个变量都可选是否关联数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</div><div class="line">    Quit,</div><div class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</div><div class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</div><div class="line">    Write(<span class="built_in">String</span>),</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>定义变量的语法与用来定义结构体的语法类似：你可以有不带数据的变量（像类单元结构体），带有命名数据的变量，和带有未命名数据的变量（像元组结构体）。然而，不像单独的结构体定义，一个<code>enum</code>是一个单独的类型。一个枚举的值可以匹配任何一个变量。因为这个原因，枚举有时被叫做“集合类型”：枚举可能值的集合是每一个变量可能值的集合的总和。</p>
<p>我们使用<code>::</code>语法来使用每个变量的名字：它们包含在<code>enum</code>名字自身中。这样的话，以下的情况都是可行的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</div><div class="line">     Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> x: Message = Message::Move &#123; x: <span class="number">3</span>, y: <span class="number">4</span> &#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BoardGameTurn</span></span> &#123;</div><div class="line">    Move &#123; squares: <span class="built_in">i32</span> &#125;,</div><div class="line">    Pass,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> y: BoardGameTurn = BoardGameTurn::Move &#123; squares: <span class="number">1</span> &#125;;</div></pre></td></tr></table></figure>
<p>这两个变量都叫做<code>Move</code>，不过他们包含在枚举名字中，他们可以无冲突的使用。</p>
<p>枚举类型的一个值包含它是哪个变量的信息，以及任何与变量相关的数据。这有时被作为一个“标记的联合”被提及。因为数据包括一个“标签”表明它的类型是什么。编译器使用这个信息来确保安全的访问枚举中的数据。例如，我们不能简单的尝试解构一个枚举值，就像它是其中一个可能的变体那样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">process_color_change</span></span>(msg: Message) &#123;</div><div class="line">    <span class="keyword">let</span> Message::ChangeColor(r, g, b) = msg; <span class="comment">// compile-time error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不支持这些操作（比较操作）可能看起来更像限制。不过这是一个我们可以克服的限制。有两种方法：我们自己实现相等（比较），或通过<a href="Match 匹配.md"><code>match</code> </a>表达式模式匹配变量，你会在下一部分学到它。我们还不够了解Rust如何实现相等，不过我们会在<a href="Traits.md">特性</a>找到它们。</p>
<h2 id="构造器作为函数（Constructors-as-functions）"><a href="#构造器作为函数（Constructors-as-functions）" class="headerlink" title="构造器作为函数（Constructors as functions）"></a>构造器作为函数（Constructors as functions）</h2><p>一个枚举的构造器总是可以像函数一样使用。例如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</div><div class="line">Write(<span class="built_in">String</span>),</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> m = Message::Write(<span class="string">"Hello, world"</span>.to_string());</div></pre></td></tr></table></figure>
<p>与下面是一样的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</div><div class="line">Write(<span class="built_in">String</span>),</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: <span class="built_in">String</span>) -&gt; Message &#123;</div><div class="line">    Message::Write(x)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> x = foo(<span class="string">"Hello, world"</span>.to_string());</div></pre></td></tr></table></figure>
<p>这对我们没有什么直接的帮助，直到我们要用到<a href="Closures 闭包.md">闭包</a>时，这时我们要考虑将函数作为参数传递给其他函数。例如，使用<a href="Iterators 迭代器.md">迭代器</a>，我们可以这样把一个<code>String</code>的Vector转换为一个<code>Message::Write</code>的Vector：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</div><div class="line">Write(<span class="built_in">String</span>),</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="string">"Hello"</span>.to_string(), <span class="string">"World"</span>.to_string()];</div><div class="line"></div><div class="line"><span class="keyword">let</span> v1: <span class="built_in">Vec</span>&lt;Message&gt; = v.into_iter().map(Message::Write).collect();</div></pre></td></tr></table></figure>
<h1 id="三：不定长类型"><a href="#三：不定长类型" class="headerlink" title="三：不定长类型"></a>三：不定长类型</h1><p>大部分类型有一个特定的大小，以字节为单位，它们在编译时是已知的。例如，一个<code>i32</code>是32位大，或者4个字节。然而，有些类型有益于表达，却没有一个定义的大小。它们叫做“不定长”或者“动态大小”类型。一个例子是<code>[T]</code>。这个类型代表一个特定数量<code>t</code>的序列。不过我们并不知道有多少，所以大小是未知的。</p>
<p>Rust知道几个这样的类型，不过它们有一些限制。这有三个：</p>
<ol>
<li>我们只能通过指针操作一个不定长类型的实例。<code>&amp;[T]</code>刚好能正常工作，不过<code>[T]</code>不行。一个<code>&amp;[T]</code>能正常工作，不过一个<code>[T]</code>不行。</li>
<li>变量和参数不能拥有动态大小类型。</li>
<li>只有一个<code>struct</code>的最后一个字段可能拥有一个动态大小类型；其它字段则不可以拥有动态大小类型。枚举变量不可以用动态大小类型作为数据。</li>
</ol>
<p>所以为什么这很重要？好吧，因为<code>[T]</code>只能用在一个指针之后，如果我们没有对不定长类型的语言支持，它将不可能这么写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">impl</span> Foo <span class="keyword">for</span> <span class="built_in">str</span> &#123;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">impl</span>&lt;T&gt; Foo <span class="keyword">for</span> [T] &#123;</div></pre></td></tr></table></figure>
<p>相反，你将不得不这么写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">impl</span> Foo <span class="keyword">for</span> &amp;<span class="built_in">str</span> &#123;</div></pre></td></tr></table></figure>
<p>意味深长的是，这个实现将只能用于<a href="References and Borrowing 引用和借用.md">引用</a>，并且不能用于其它类型的指针。通过<code>impl for str</code>，所有指针，包括（在一些地方，这里会有bug需要修复）用户自定义的智能指针，可以使用这个<code>impl</code>。</p>
<h2 id="Sized"><a href="#Sized" class="headerlink" title="?Sized"></a><code>?Sized</code></h2><p>如果你想要写一个接受动态大小类型的函数，你可以使用这个特殊的限制，<code>?Sized</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>&lt;T: ?<span class="built_in">Sized</span>&gt; &#123;</div><div class="line">    f: T,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>?</code>，读作“<code>T</code>可能是<code>Sized</code>的”，意味着这个限制是特殊的：它让我们的匹配更宽松，而不是相反。这几乎像每个<code>T</code>都隐式拥有<code>T: Sized</code>一样，<code>?</code>放松了这个默认（限制）。</p>
<h1 id="四：关联类型"><a href="#四：关联类型" class="headerlink" title="四：关联类型"></a>四：关联类型</h1><p>关联类型是Rust类型系统中非常强大的一部分。它涉及到‘类型族’的概念，换句话说，就是把多种类型归于一类。这个描述可能比较抽象，所以让我们深入研究一个例子。如果你想编写一个<code>Graph</code>trait，你需要泛型化两个类型：点类型和边类型。所以你可能会像这样写一个trait，<code>Graph&lt;N, E&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span>&lt;N, E&gt; &#123;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;N, &amp;N) -&gt; <span class="built_in">bool</span>;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;N) -&gt; <span class="built_in">Vec</span>&lt;E&gt;;</div><div class="line">    <span class="comment">// etc</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然这可以工作，不过显得很尴尬，例如，任何需要一个<code>Graph</code>作为参数的函数都需要泛型化的<code>N</code>ode和<code>E</code>dge类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">distance</span></span>&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; <span class="built_in">u32</span> &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>我们的距离计算并不需要<code>Edge</code>类型，所以函数签名中<code>E</code>只是写着玩的。</p>
<p>我们需要的是对于每一种<code>Graph</code>类型，都使用一个特定的的<code>N</code>ode和<code>E</code>dge类型。我们可以用关联类型来做到这一点：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span> &#123;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">N</span></span>;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">E</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class="built_in">bool</span>;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N) -&gt; <span class="built_in">Vec</span>&lt;Self::E&gt;;</div><div class="line">    <span class="comment">// etc</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，我们使用一个抽象的<code>Graph</code>了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">distance</span></span>&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; uint &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>这里不再需要处理<code>E</code>dge类型了。</p>
<p>让我们更详细的回顾一下。</p>
<h2 id="定义关联类型"><a href="#定义关联类型" class="headerlink" title="定义关联类型"></a>定义关联类型</h2><p>让我们构建一个<code>Graph</code>trait。这里是定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span> &#123;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">N</span></span>;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">E</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class="built_in">bool</span>;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N) -&gt; <span class="built_in">Vec</span>&lt;Self::E&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>十分简单。关联类型使用<code>type</code>关键字，并出现在trait体和函数中。</p>
<p>这些<code>type</code>声明跟函数定义一样。例如，如果我们想<code>N</code>类型实现<code>Display</code>，这样我们就可以打印出点类型，我们可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::fmt;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span> &#123;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">N</span></span>: fmt::Display;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">E</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class="built_in">bool</span>;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N) -&gt; <span class="built_in">Vec</span>&lt;Self::E&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现关联类型"><a href="#实现关联类型" class="headerlink" title="实现关联类型"></a>实现关联类型</h2><p>就像任何 trait，使用关联类型的 trait 用<code>impl</code>关键字来提供实现。下面是一个<code>Graph</code>的简单实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># <span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span> &#123;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">N</span></span>;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">E</span></span>;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class="built_in">bool</span>;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N) -&gt; <span class="built_in">Vec</span>&lt;Self::E&gt;;</div><div class="line"># &#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyGraph</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">impl</span> Graph <span class="keyword">for</span> MyGraph &#123;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">N</span></span> = Node;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">E</span></span> = Edge;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class="built_in">bool</span> &#123;</div><div class="line">        <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, n: &amp;Node) -&gt; <span class="built_in">Vec</span>&lt;Edge&gt; &#123;</div><div class="line">        <span class="built_in">Vec</span>::new()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个可笑的实现总是返回<code>true</code>和一个空的<code>Vec&lt;Edge&gt;</code>，不过它提供了如何实现这类 trait 的思路。首先我们需要3个<code>struct</code>，一个代表图，一个代表点，还有一个代表边。如果使用别的类型更合理，也可以那样做，我们只是准备使用<code>struct</code>来代表这 3 个类型。</p>
<p>接下来是<code>impl</code>行，它就像其它任何 trait 的实现。</p>
<p>在这里，我们使用<code>=</code>来定义我们的关联类型。trait 使用的名字出现在<code>=</code>的左边，而我们<code>impl</code>的具体类型出现在右边。最后，我们在函数声明中使用具体类型。</p>
<h2 id="trait-对象和关联类型"><a href="#trait-对象和关联类型" class="headerlink" title="trait 对象和关联类型"></a>trait 对象和关联类型</h2><p>这里还有另外一个我们需要讨论的语法：trait对象。如果你创建一个关联类型的trait对象，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># <span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span> &#123;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">N</span></span>;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">E</span></span>;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class="built_in">bool</span>;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N) -&gt; <span class="built_in">Vec</span>&lt;Self::E&gt;;</div><div class="line"># &#125;</div><div class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span>;</div><div class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span>;</div><div class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">MyGraph</span></span>;</div><div class="line"># <span class="keyword">impl</span> Graph <span class="keyword">for</span> MyGraph &#123;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">N</span></span> = Node;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">E</span></span> = Edge;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class="built_in">bool</span> &#123;</div><div class="line">#         <span class="literal">true</span></div><div class="line">#     &#125;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, n: &amp;Node) -&gt; <span class="built_in">Vec</span>&lt;Edge&gt; &#123;</div><div class="line">#         <span class="built_in">Vec</span>::new()</div><div class="line">#     &#125;</div><div class="line"># &#125;</div><div class="line"><span class="keyword">let</span> graph = MyGraph;</div><div class="line"><span class="keyword">let</span> obj = <span class="built_in">Box</span>::new(graph) <span class="keyword">as</span> <span class="built_in">Box</span>&lt;Graph&gt;;</div></pre></td></tr></table></figure>
<p>你会得到两个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">error: the value of the associated type `E` (from the trait `main::Graph`) must</div><div class="line">be specified [E0191]</div><div class="line">let obj = Box::new(graph) as Box&lt;Graph&gt;;</div><div class="line">          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line">24:44 error: the value of the associated type `N` (from the trait</div><div class="line">`main::Graph`) must be specified [E0191]</div><div class="line">let obj = Box::new(graph) as Box&lt;Graph&gt;;</div><div class="line">          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div></pre></td></tr></table></figure>
<p>我们不能这样创建一个trait对象，因为我们并不知道关联的类型。相反，我们可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># <span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span> &#123;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">N</span></span>;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">E</span></span>;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class="built_in">bool</span>;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N) -&gt; <span class="built_in">Vec</span>&lt;Self::E&gt;;</div><div class="line"># &#125;</div><div class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span>;</div><div class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span>;</div><div class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">MyGraph</span></span>;</div><div class="line"># <span class="keyword">impl</span> Graph <span class="keyword">for</span> MyGraph &#123;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">N</span></span> = Node;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">E</span></span> = Edge;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class="built_in">bool</span> &#123;</div><div class="line">#         <span class="literal">true</span></div><div class="line">#     &#125;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, n: &amp;Node) -&gt; <span class="built_in">Vec</span>&lt;Edge&gt; &#123;</div><div class="line">#         <span class="built_in">Vec</span>::new()</div><div class="line">#     &#125;</div><div class="line"># &#125;</div><div class="line"><span class="keyword">let</span> graph = MyGraph;</div><div class="line"><span class="keyword">let</span> obj = <span class="built_in">Box</span>::new(graph) <span class="keyword">as</span> <span class="built_in">Box</span>&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;</div></pre></td></tr></table></figure>
<p><code>N=Node</code>语法允许我们提供一个具体类型，<code>Node</code>，作为<code>N</code>类型参数。<code>E=Edge</code>也是一样。如果我们不提供这个限制，我们不能确定应该<code>impl</code>那个来匹配trait对象。</p>
<p>关联类型是Rust类型系统中非常强大的一部分。它涉及到‘类型族’的概念，换句话说，就是把多种类型归于一类。这个描述可能比较抽象，所以让我们深入研究一个例子。如果你想编写一个<code>Graph</code>trait，你需要泛型化两个类型：点类型和边类型。所以你可能会像这样写一个trait，<code>Graph&lt;N, E&gt;</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span>&lt;N, E&gt; &#123;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;N, &amp;N) -&gt; <span class="built_in">bool</span>;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;N) -&gt; <span class="built_in">Vec</span>&lt;E&gt;;</div><div class="line">    <span class="comment">// etc</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然这可以工作，不过显得很尴尬，例如，任何需要一个<code>Graph</code>作为参数的函数都需要泛型化的<code>N</code>ode和<code>E</code>dge类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">distance</span></span>&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; <span class="built_in">u32</span> &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>我们的距离计算并不需要<code>Edge</code>类型，所以函数签名中<code>E</code>只是写着玩的。</p>
<p>我们需要的是对于每一种<code>Graph</code>类型，都使用一个特定的的<code>N</code>ode和<code>E</code>dge类型。我们可以用关联类型来做到这一点：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span> &#123;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">N</span></span>;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">E</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class="built_in">bool</span>;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N) -&gt; <span class="built_in">Vec</span>&lt;Self::E&gt;;</div><div class="line">    <span class="comment">// etc</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，我们使用一个抽象的<code>Graph</code>了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fn</span> <span class="title">distance</span></span>&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; uint &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>这里不再需要处理<code>E</code>dge类型了。</p>
<p>让我们更详细的回顾一下。</p>
<h2 id="定义关联类型-1"><a href="#定义关联类型-1" class="headerlink" title="定义关联类型"></a>定义关联类型</h2><p>让我们构建一个<code>Graph</code>trait。这里是定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span> &#123;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">N</span></span>;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">E</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class="built_in">bool</span>;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N) -&gt; <span class="built_in">Vec</span>&lt;Self::E&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>十分简单。关联类型使用<code>type</code>关键字，并出现在trait体和函数中。</p>
<p>这些<code>type</code>声明跟函数定义一样。例如，如果我们想<code>N</code>类型实现<code>Display</code>，这样我们就可以打印出点类型，我们可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::fmt;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span> &#123;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">N</span></span>: fmt::Display;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">E</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class="built_in">bool</span>;</div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N) -&gt; <span class="built_in">Vec</span>&lt;Self::E&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现关联类型-1"><a href="#实现关联类型-1" class="headerlink" title="实现关联类型"></a>实现关联类型</h2><p>就像任何 trait，使用关联类型的 trait 用<code>impl</code>关键字来提供实现。下面是一个<code>Graph</code>的简单实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># <span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span> &#123;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">N</span></span>;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">E</span></span>;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class="built_in">bool</span>;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N) -&gt; <span class="built_in">Vec</span>&lt;Self::E&gt;;</div><div class="line"># &#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyGraph</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">impl</span> Graph <span class="keyword">for</span> MyGraph &#123;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">N</span></span> = Node;</div><div class="line">    <span class="class"><span class="keyword">type</span> <span class="title">E</span></span> = Edge;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class="built_in">bool</span> &#123;</div><div class="line">        <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, n: &amp;Node) -&gt; <span class="built_in">Vec</span>&lt;Edge&gt; &#123;</div><div class="line">        <span class="built_in">Vec</span>::new()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个可笑的实现总是返回<code>true</code>和一个空的<code>Vec&lt;Edge&gt;</code>，不过它提供了如何实现这类 trait 的思路。首先我们需要3个<code>struct</code>，一个代表图，一个代表点，还有一个代表边。如果使用别的类型更合理，也可以那样做，我们只是准备使用<code>struct</code>来代表这 3 个类型。</p>
<p>接下来是<code>impl</code>行，它就像其它任何 trait 的实现。</p>
<p>在这里，我们使用<code>=</code>来定义我们的关联类型。trait 使用的名字出现在<code>=</code>的左边，而我们<code>impl</code>的具体类型出现在右边。最后，我们在函数声明中使用具体类型。</p>
<h2 id="trait-对象和关联类型-1"><a href="#trait-对象和关联类型-1" class="headerlink" title="trait 对象和关联类型"></a>trait 对象和关联类型</h2><p>这里还有另外一个我们需要讨论的语法：trait对象。如果你创建一个关联类型的trait对象，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># <span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span> &#123;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">N</span></span>;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">E</span></span>;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class="built_in">bool</span>;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N) -&gt; <span class="built_in">Vec</span>&lt;Self::E&gt;;</div><div class="line"># &#125;</div><div class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span>;</div><div class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span>;</div><div class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">MyGraph</span></span>;</div><div class="line"># <span class="keyword">impl</span> Graph <span class="keyword">for</span> MyGraph &#123;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">N</span></span> = Node;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">E</span></span> = Edge;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class="built_in">bool</span> &#123;</div><div class="line">#         <span class="literal">true</span></div><div class="line">#     &#125;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, n: &amp;Node) -&gt; <span class="built_in">Vec</span>&lt;Edge&gt; &#123;</div><div class="line">#         <span class="built_in">Vec</span>::new()</div><div class="line">#     &#125;</div><div class="line"># &#125;</div><div class="line"><span class="keyword">let</span> graph = MyGraph;</div><div class="line"><span class="keyword">let</span> obj = <span class="built_in">Box</span>::new(graph) <span class="keyword">as</span> <span class="built_in">Box</span>&lt;Graph&gt;;</div></pre></td></tr></table></figure>
<p>你会得到两个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">error: the value of the associated type `E` (from the trait `main::Graph`) must</div><div class="line">be specified [E0191]</div><div class="line">let obj = Box::new(graph) as Box&lt;Graph&gt;;</div><div class="line">          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line">24:44 error: the value of the associated type `N` (from the trait</div><div class="line">`main::Graph`) must be specified [E0191]</div><div class="line">let obj = Box::new(graph) as Box&lt;Graph&gt;;</div><div class="line">          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div></pre></td></tr></table></figure>
<p>我们不能这样创建一个trait对象，因为我们并不知道关联的类型。相反，我们可以这样写：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># <span class="class"><span class="keyword">trait</span> <span class="title">Graph</span></span> &#123;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">N</span></span>;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">E</span></span>;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class="built_in">bool</span>;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, &amp;Self::N) -&gt; <span class="built_in">Vec</span>&lt;Self::E&gt;;</div><div class="line"># &#125;</div><div class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span>;</div><div class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span>;</div><div class="line"># <span class="class"><span class="keyword">struct</span> <span class="title">MyGraph</span></span>;</div><div class="line"># <span class="keyword">impl</span> Graph <span class="keyword">for</span> MyGraph &#123;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">N</span></span> = Node;</div><div class="line">#     <span class="class"><span class="keyword">type</span> <span class="title">E</span></span> = Edge;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">has_edge</span></span>(&amp;<span class="keyword">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class="built_in">bool</span> &#123;</div><div class="line">#         <span class="literal">true</span></div><div class="line">#     &#125;</div><div class="line">#     <span class="function"><span class="keyword">fn</span> <span class="title">edges</span></span>(&amp;<span class="keyword">self</span>, n: &amp;Node) -&gt; <span class="built_in">Vec</span>&lt;Edge&gt; &#123;</div><div class="line">#         <span class="built_in">Vec</span>::new()</div><div class="line">#     &#125;</div><div class="line"># &#125;</div><div class="line"><span class="keyword">let</span> graph = MyGraph;</div><div class="line"><span class="keyword">let</span> obj = <span class="built_in">Box</span>::new(graph) <span class="keyword">as</span> <span class="built_in">Box</span>&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;</div></pre></td></tr></table></figure>
<p><code>N=Node</code>语法允许我们提供一个具体类型，<code>Node</code>，作为<code>N</code>类型参数。<code>E=Edge</code>也是一样。如果我们不提供这个限制，我们不能确定应该<code>impl</code>那个来匹配trait对象。</p>
<h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><h2 id="type-别名"><a href="#type-别名" class="headerlink" title="`type`别名"></a>`type`别名</h2><p><code>type</code>关键字让你定义另一个类型的别名：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">Name</span></span> = <span class="built_in">String</span>;</div></pre></td></tr></table></figure>
<p>你可以像一个真正类型那样使用这个类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">Name</span></span> = <span class="built_in">String</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> x: Name = <span class="string">"Hello"</span>.to_string();</div></pre></td></tr></table></figure>
<p>然而要注意的是，这一个<em>别名</em>，完全不是一个新的类型。换句话说，因为Rust是强类型的，你可以预期两个不同类型的比较会失败：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">5</span>;</div><div class="line"><span class="keyword">let</span> y: <span class="built_in">i64</span> = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> x == y &#123;</div><div class="line">   <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">error: mismatched types:</div><div class="line"> expected `i32`,</div><div class="line">    found `i64`</div><div class="line">(expected i32,</div><div class="line">    found i64) [E0308]</div><div class="line">     if x == y &#123;</div><div class="line">             ^</div></pre></td></tr></table></figure>
<p>不过，如果我们有一个别名：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">Num</span></span> = <span class="built_in">i32</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="number">5</span>;</div><div class="line"><span class="keyword">let</span> y: Num = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span> x == y &#123;</div><div class="line">   <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这会无错误的编译。从任何角度来说，<code>Num</code>类型的值与<code>i32</code>类型的值都是一样的。</p>
<p>你也可以在泛型中使用类型别名：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> std::result;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ConcreteError</span></span> &#123;</div><div class="line">    Foo,</div><div class="line">    Bar,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;T&gt; = result::<span class="built_in">Result</span>&lt;T, ConcreteError&gt;;</div></pre></td></tr></table></figure>
<p>这创建了一个特定版本的<code>Result</code>类型，它总是有一个<code>ConcreteError</code>作为<code>Result&lt;T, E&gt;</code>的<code>E</code>那部分。这通常用于标准库中创建每个子部分的自定义错误。例如，<a href="http://doc.rust-lang.org/nightly/std/io/type.Result.html" target="_blank" rel="external"><code>io::Result</code></a>。</p>
</section>
    <br>
    <p style="background-color:azure">~~~( 完 )~~~ </p>
    <br>
    <div class="pager">
          
             <span class="previous" style="float:left" >
                <a style="background-color:azure" href="/2016/01/12/Github-Pages结合Hexo搭建博客/" data-toggle="tooltip" data-placement="top"
                   title="Github-Pages结合Hexo搭建博客">&larr; <strong>Previous</strong></a>
             </span>
                    
          
            <span class="next" style="float:right" >
                 <a style="background-color:azure" href="/2015/04/12/GCC的编译流程/" data-toggle="tooltip" data-placement="top"
                    title="GCC的编译流程"><strong>Next</strong> &rarr;</a>
            </span>
          
    </div>
    <div class="money-like">
      <div class="reward-btn">
        赏
        <span class="money-code">
          <span class="alipay-code">
            <div class="code-image"></div>
            <b>使用支付宝打赏</b>
          </span>
          <span class="wechat-code">
            <div class="code-image"></div>
            <b>使用微信打赏</b>
          </span>
        </span>
      </div>
      <p class="notice">若你觉得文章对你有帮助，欢迎点击上方~赏~按钮给我打赏</p>
    </div>
    <!--<div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>-->
    <div style="background-color:aliceblue; border-radius: 3px; padding: 0 0 3px 8px;">
      <h3>文档信息</h3>
        <li style="list-style:none">版权声明：自由转载-非商用-非衍生-保持署名
          <a style="color:indigo" rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">（创意共享4.0许可证）</a> 转载请保留原文链接及作者。
        </li>
        <li style="list-style:none">作者：
          <a style="color:indigo" href="http://www.kriry.com/about" target="_blank" I><strong>kriry</strong></a> 
        </li>
        <li style="list-style:none ">社交:
           
            <a style="color:indigo" class="icon-weibo" href="http://weibo.com/kriry" target="_blank">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-1x"></i>
                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          
          
            <a style="color:indigo" class="icon-twitter" href="https://twitter.com/krircc" target="_blank">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-1x"></i>
                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          
          
            <a style="color:indigo" class="icon-github" href="https://github.com/krircc" target="_blank">
              <span class="fa-stack fa-lg">
                <i class="fa fa-circle fa-stack-1x"></i>
                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
              </span>
            </a>
          
        </li>
    </div>
    <br>
    
          <div id="comments"></div>
          
  </article>
</main>

<script>
  (function () {
    var url = 'http://www.kriry.com/2015/08/15/Rust数据类型详解/';
    var banner = 'undefined'
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header');
      
      // error image
    $(".markdown-content img").on('error', function() {
        $(this).attr('src', 'http://file.muyutech.com/error-img.png')
        $(this).css({
          'cursor': 'default'
        })
    })

     // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src != 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)
        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')
        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
    
    var gitmentConfig = "krircc";
    if (gitmentConfig != "undefined") {
      var gitment = new Gitment({
        id: "Rust数据类型详解",
        owner: "krircc",
        repo: "krircc.github.io",
        oauth: {
          client_id: "fa541fea53a0e03f7cae",
          client_secret: "d0875e9546bcf231f7f7de67f3ed2b7b6f070964"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
    <p class="copyright">
      <strong>Copyright&copy; kriry</strong>&nbsp;|&nbsp;2015-2017
      &nbsp;|&nbsp;
    <span class="powered-by">
      <i class="fa fa-user-md"></i>
      <span id="busuanzi_container_site_uv">
        本站访客数:<span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>
<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>