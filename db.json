{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/kriry/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/kriry/source/js/qrious.js","path":"js/qrious.js","modified":1,"renderable":1},{"_id":"themes/kriry/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/kriry/source/css/images/alipay.jpg","path":"css/images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/kriry/source/css/images/escheres.png","path":"css/images/escheres.png","modified":1,"renderable":1},{"_id":"themes/kriry/source/css/images/kriry.jpg","path":"css/images/kriry.jpg","modified":1,"renderable":1},{"_id":"themes/kriry/source/css/images/logo.jpg","path":"css/images/logo.jpg","modified":1,"renderable":1},{"_id":"themes/kriry/source/css/images/menu.png","path":"css/images/menu.png","modified":1,"renderable":1},{"_id":"themes/kriry/source/css/images/top.png","path":"css/images/top.png","modified":1,"renderable":1},{"_id":"themes/kriry/source/css/images/wechat.jpg","path":"css/images/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/kriry/source/css/plugins/gitment.css","path":"css/plugins/gitment.css","modified":1,"renderable":1},{"_id":"themes/kriry/source/fonts/SourceSansPro.ttf","path":"fonts/SourceSansPro.ttf","modified":1,"renderable":1},{"_id":"themes/kriry/source/js/gitment.js","path":"js/gitment.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"e466bd40429cd65a3664afc6276266e9ba9d0497","modified":1498039813332},{"_id":"themes/kriry/_config.yml","hash":"ad40aa260f6eb41de558f26e1ad488bf5965b81e","modified":1507172966000},{"_id":"source/_posts/GCC的编译流程.md","hash":"5f712de15b755ebef8690d11fbd7d592c410c322","modified":1498115466058},{"_id":"source/_posts/Github-Pages结合Hexo搭建博客.md","hash":"763c558a9e0da69a76a1feda6ccb413cc674741d","modified":1498915106000},{"_id":"source/_posts/Polymer 2.x Cheat Sheet.md","hash":"61bdac7a3a7006e6f22c85fd81e0729969123983","modified":1498372417298},{"_id":"source/_posts/Postgresql安装使用.md","hash":"a2223647223e207ed50d1936c3d5e54f8f5d3c25","modified":1503919167000},{"_id":"source/_posts/Rust数据类型详解.md","hash":"591df8cd9dfe290afc57947828b10a70779d3020","modified":1499593829000},{"_id":"source/_posts/Use-debian.md","hash":"87506706427ed0abeaee311eb8ec0273036c93a7","modified":1504968065000},{"_id":"source/_posts/用nvm管理不同版本的node.md","hash":"1c1423e0856e85cebbdb58ed044acffe679c0da6","modified":1498117501000},{"_id":"source/about/index.md","hash":"65cbc6744c1417ca7b7619dda33ebfc6f36a835b","modified":1507111214000},{"_id":"source/project/index.md","hash":"592d77dba4771c03a39930d9e36729c8d7c324a1","modified":1507127611000},{"_id":"source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1498023195442},{"_id":"themes/kriry/layout/about.ejs","hash":"1db24dd91a67dcd1de5684e67d4acae7090da841","modified":1507173041433},{"_id":"themes/kriry/layout/archive.ejs","hash":"842a8698baddccc73fdb3bf753e87f0850c160d7","modified":1498231243000},{"_id":"themes/kriry/layout/index.ejs","hash":"a55dde21f8465b9101878064789aedd7b53ed523","modified":1507130978000},{"_id":"themes/kriry/layout/layout.ejs","hash":"a7b8f1debdca12d667ecd1bcc3d4bc6e13a23d7b","modified":1498201638000},{"_id":"themes/kriry/layout/page.ejs","hash":"fc54829b2d32d99de5d635f919153470ec6e80f8","modified":1507122870000},{"_id":"themes/kriry/layout/project.ejs","hash":"4dae9fc9606ed8f4e9c85b6508e74140844e5b41","modified":1507173065000},{"_id":"themes/kriry/layout/tags.ejs","hash":"f6d70357a284f9916a7a56339c53b47e1a037ec3","modified":1507118356000},{"_id":"themes/kriry/_source/about/index.md","hash":"68c8af0453deca5f6b03eb18ee6f89fb0c1f1f75","modified":1498017072966},{"_id":"themes/kriry/_source/project/index.md","hash":"b8f5482c157514bd2df4ce8a4e4d01a957497924","modified":1507125883000},{"_id":"themes/kriry/_source/tags/index.md","hash":"80a15f1b5daff22b04849109e976bc91a410b83e","modified":1498017072966},{"_id":"themes/kriry/layout/_partial/archive.ejs","hash":"9abbf14034d581569c0b6c992fe22035cb5306b3","modified":1498017072966},{"_id":"themes/kriry/layout/_partial/footer.ejs","hash":"e4f58f772b1c939cf1bd761b7896ac457e939f1d","modified":1507112837186},{"_id":"themes/kriry/layout/_partial/head.ejs","hash":"5340525581b6b77a29dee66cc60cbeaa042e928f","modified":1507123499000},{"_id":"themes/kriry/layout/_partial/header.ejs","hash":"838c5d641f50da0424a6eae68c58b3f9dd7e6ab1","modified":1504940534000},{"_id":"themes/kriry/layout/_partial/pager.ejs","hash":"51e76b9175111fd72911b6a48204892895d3c9bd","modified":1507123102000},{"_id":"themes/kriry/layout/_partial/tag.ejs","hash":"5d2a2c3f8ca7000945ab426a0c6939421974b224","modified":1507112304000},{"_id":"themes/kriry/layout/_partial/top.ejs","hash":"f09dea486246a580213005b21d4b38810dd16fb3","modified":1498017072966},{"_id":"themes/kriry/source/css/_config.styl","hash":"7551942a744dec034bc0a2b8af60cfa18b0a4a2b","modified":1507121197930},{"_id":"themes/kriry/source/css/style.styl","hash":"c66614b688e29256f71e9de02ddb36974b33ab17","modified":1507136970000},{"_id":"themes/kriry/source/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1498017072974},{"_id":"themes/kriry/source/js/script.js","hash":"c17ea69c0e0657c0d8c1e7de19a730416b929e5e","modified":1507121372000},{"_id":"themes/kriry/source/css/_partial/about.styl","hash":"63fe431713226ab5e11d608a9078eba2002d2ebf","modified":1507116355000},{"_id":"themes/kriry/source/css/_partial/archive.styl","hash":"7b8147bd07d3f6ef8a4acf9e6da50f79741ae26c","modified":1507133111000},{"_id":"themes/kriry/source/css/_partial/footer.styl","hash":"acc26664e5b3bdb40534496234a66fca2994e905","modified":1498017072966},{"_id":"themes/kriry/source/css/_partial/header.styl","hash":"def3a6938d925c585a7da6256a6f2e90f3b7d61e","modified":1507133162013},{"_id":"themes/kriry/source/css/_partial/markdown.styl","hash":"26c951c7c59876143a7e603ffb750994e77e54dd","modified":1507136281806},{"_id":"themes/kriry/source/css/_partial/pager.styl","hash":"888384c67429c7568aa38b5ebe5acae3cc4de367","modified":1498017072966},{"_id":"themes/kriry/source/css/_partial/project.styl","hash":"e1751b0f30068a3f18d3348b0ca49f6349621394","modified":1507135385000},{"_id":"themes/kriry/source/css/_partial/tags.styl","hash":"5198a7f7c221341138ae5c65185e86b6e13e8e26","modified":1507133062000},{"_id":"themes/kriry/source/css/images/alipay.jpg","hash":"74f995fc84ad9d0dd17a5a0e3b8bff58ad8147ac","modified":1498113071859},{"_id":"themes/kriry/source/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1498017072966},{"_id":"themes/kriry/source/css/images/kriry.jpg","hash":"2b7949c6b74da136b5c364ec74cb58a7d1f43c68","modified":1496108406271},{"_id":"themes/kriry/source/css/images/logo.jpg","hash":"2b7949c6b74da136b5c364ec74cb58a7d1f43c68","modified":1496108406000},{"_id":"themes/kriry/source/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1498017072966},{"_id":"themes/kriry/source/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1498017072970},{"_id":"themes/kriry/source/css/images/wechat.jpg","hash":"9c87e99e3f41505436c01aee18d3cb1f96519be7","modified":1498112949624},{"_id":"themes/kriry/source/css/plugins/gitment.css","hash":"d1d671baa06a180a01f74c8611b504a21af271c4","modified":1507136281806},{"_id":"themes/kriry/source/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1498017072970},{"_id":"themes/kriry/source/js/gitment.js","hash":"982b17c5e29f259f8c8704cf93e6236adbf7f67a","modified":1498212428000},{"_id":"public/about/index.html","hash":"3e53084a2778a09d8cb5a676669bda1ea952eaaa","modified":1507173215998},{"_id":"public/project/index.html","hash":"68ee3cce98314a14f9537f65147f608f509a2cc7","modified":1507173215999},{"_id":"public/tags/index.html","hash":"f0c0732f4dfa164fd3a9b6a6c19349615b2c2ecc","modified":1507173215999},{"_id":"public/2016/11/12/Postgresql安装使用/index.html","hash":"1ba676f230c155e58c03d1eddfc9c7079c3fd5a4","modified":1507173216000},{"_id":"public/2015/04/12/GCC的编译流程/index.html","hash":"278816ac0a77fcd2a040d2d210b794baf31539dc","modified":1507173216000},{"_id":"public/archives/index.html","hash":"170d5d499367305080f711c3b0937f4353200b39","modified":1507173216000},{"_id":"public/archives/2015/index.html","hash":"92fa8b99f7cf3deaa53432c81331e01c27d42675","modified":1507173216000},{"_id":"public/archives/2015/03/index.html","hash":"da8840e04e31b19a1de22d648dc9971e8bff661e","modified":1507173216000},{"_id":"public/archives/2015/04/index.html","hash":"7cb0fcc009f6d17cca71e2ca30d517f666fb0dcc","modified":1507173216000},{"_id":"public/archives/2015/08/index.html","hash":"44efbcb9dcbb58ea6587e35ae69d68495e0c31dd","modified":1507173216001},{"_id":"public/archives/2016/index.html","hash":"ae80e2e3edef36e633893ba8af79942cb10dc205","modified":1507173216001},{"_id":"public/archives/2016/01/index.html","hash":"2b18bbcd661152b19ad2caa7744526156a0b68a8","modified":1507173216001},{"_id":"public/archives/2016/06/index.html","hash":"126d3c3acbe8632316bf315b2ec297d67bb2d50d","modified":1507173216001},{"_id":"public/archives/2016/11/index.html","hash":"2861e490912ed804d73e4db7210cac6238cfe7e6","modified":1507173216001},{"_id":"public/archives/2017/index.html","hash":"3f8407f9a8f86e3734f5f47df174c5b215864d75","modified":1507173216001},{"_id":"public/archives/2017/07/index.html","hash":"7927ab42b9956c4d676e4c7400667b176ac344e5","modified":1507173216002},{"_id":"public/index.html","hash":"5b8a3d010f9d8aa33d87798bb0a0768b4fb7f588","modified":1507173216002},{"_id":"public/tags/C/index.html","hash":"8dade761ba6833422b95d6865d1b7d244c6e9f1a","modified":1507173216002},{"_id":"public/tags/Github/index.html","hash":"3a41dd78fab4155724debbe0e8939b7bfe8e3118","modified":1507173216003},{"_id":"public/tags/hexo/index.html","hash":"87a7b126c8861bab9f581a4bc6408715fd5daa64","modified":1507173216003},{"_id":"public/tags/Polymer/index.html","hash":"56944a751c2d0491aa34d50e633b2e394ccc78cf","modified":1507173216003},{"_id":"public/tags/Web/index.html","hash":"6b65eb477c69d7c6eaaabb38d0ad7dbca3bad886","modified":1507173216003},{"_id":"public/tags/Postgresql/index.html","hash":"5c2cd132c318849e3938a4a415249c359de4d702","modified":1507173216003},{"_id":"public/tags/Rust/index.html","hash":"dbb24a61b68c2d1e0ad5323004fdb5b6a048355c","modified":1507173216003},{"_id":"public/tags/Linux/index.html","hash":"f2ad3e9a2d3ed9871ed063482e9271eeeba44fda","modified":1507173216004},{"_id":"public/tags/Node/index.html","hash":"6a14f495abc69586eec033d2ffe95e04f4ff5985","modified":1507173216004},{"_id":"public/2017/07/11/Polymer 2.x Cheat Sheet/index.html","hash":"c73df88b1ab5a08b53c7088321ffc968ad3a4a3e","modified":1507173216004},{"_id":"public/2016/06/10/用nvm管理不同版本的node/index.html","hash":"a2f4328088c24ed92eaec5ed2db1c0b9edd86e24","modified":1507173216005},{"_id":"public/2016/01/12/Github-Pages结合Hexo搭建博客/index.html","hash":"266b2979431e5a4e601414f0873613a25ae0645b","modified":1507173216005},{"_id":"public/2015/08/15/Rust数据类型详解/index.html","hash":"8696ba8215811ae3a97f330f6b804c206358c92f","modified":1507173216005},{"_id":"public/2015/03/06/Use-debian/index.html","hash":"227407ea04fd34a2143431e53350d801c517e530","modified":1507173216005},{"_id":"public/CNAME","hash":"e466bd40429cd65a3664afc6276266e9ba9d0497","modified":1507173216011},{"_id":"public/css/images/alipay.jpg","hash":"74f995fc84ad9d0dd17a5a0e3b8bff58ad8147ac","modified":1507173216011},{"_id":"public/css/images/escheres.png","hash":"55deece3236dcc2fb44c28dec3e8bacbb7b46542","modified":1507173216011},{"_id":"public/css/images/kriry.jpg","hash":"2b7949c6b74da136b5c364ec74cb58a7d1f43c68","modified":1507173216012},{"_id":"public/css/images/logo.jpg","hash":"2b7949c6b74da136b5c364ec74cb58a7d1f43c68","modified":1507173216012},{"_id":"public/css/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1507173216012},{"_id":"public/css/images/top.png","hash":"611a257907474ca02828319f81b006c1d818bb84","modified":1507173216012},{"_id":"public/css/images/wechat.jpg","hash":"9c87e99e3f41505436c01aee18d3cb1f96519be7","modified":1507173216012},{"_id":"public/js/script.js","hash":"c17ea69c0e0657c0d8c1e7de19a730416b929e5e","modified":1507173216382},{"_id":"public/css/style.css","hash":"914837a0d2a6dbc3152bac03f68c305c9dc229a0","modified":1507173216382},{"_id":"public/js/qrious.js","hash":"a9271e81e2ac6a692b1c133811afa33f0f3d7dc5","modified":1507173216382},{"_id":"public/css/plugins/gitment.css","hash":"d1d671baa06a180a01f74c8611b504a21af271c4","modified":1507173216382},{"_id":"public/js/gitment.js","hash":"982b17c5e29f259f8c8704cf93e6236adbf7f67a","modified":1507173216383},{"_id":"public/fonts/SourceSansPro.ttf","hash":"1e9f0372c269da205fdbac8cf27cb9cf59f6ad45","modified":1507173216383}],"Category":[],"Data":[],"Page":[{"title":"About","layout":"about","_content":"\nHello, I'm kriry - welcome here ! This is where I occasionally write about my journey through \n\nthe world of software development. Usually I'll write about tech I'm interested in, problems I \n\nencounter or things I'm working on. You can see the full list below to find out more about me!\n\n\nLang : Rust、Swift、Html5/CSS/JS\n\nOS : Linux、VScode\n\nEmail : krircc@aliyun.com\n","source":"about/index.md","raw":"---\ntitle: About\nlayout: about\n---\n\nHello, I'm kriry - welcome here ! This is where I occasionally write about my journey through \n\nthe world of software development. Usually I'll write about tech I'm interested in, problems I \n\nencounter or things I'm working on. You can see the full list below to find out more about me!\n\n\nLang : Rust、Swift、Html5/CSS/JS\n\nOS : Linux、VScode\n\nEmail : krircc@aliyun.com\n","date":"2017-10-04T10:00:14.528Z","updated":"2017-10-04T10:00:14.000Z","path":"about/index.html","comments":1,"_id":"cj8dw0nff0001qnjxqdkmw11c","content":"<p>Hello, I’m kriry - welcome here ! This is where I occasionally write about my journey through </p>\n<p>the world of software development. Usually I’ll write about tech I’m interested in, problems I </p>\n<p>encounter or things I’m working on. You can see the full list below to find out more about me!</p>\n<p>Lang : Rust、Swift、Html5/CSS/JS</p>\n<p>OS : Linux、VScode</p>\n<p>Email : krircc@aliyun.com</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Hello, I’m kriry - welcome here ! This is where I occasionally write about my journey through </p>\n<p>the world of software development. Usually I’ll write about tech I’m interested in, problems I </p>\n<p>encounter or things I’m working on. You can see the full list below to find out more about me!</p>\n<p>Lang : Rust、Swift、Html5/CSS/JS</p>\n<p>OS : Linux、VScode</p>\n<p>Email : krircc@aliyun.com</p>\n"},{"title":"Project","layout":"project","_content":"\n\n","source":"project/index.md","raw":"---\ntitle: Project\nlayout: project\n---\n\n\n","date":"2017-10-04T14:33:31.322Z","updated":"2017-10-04T14:33:31.000Z","path":"project/index.html","comments":1,"_id":"cj8dw0nfj0003qnjx72vf5h7z","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tags\nlayout: tags\n---\n","date":"2017-07-11T12:41:33.817Z","updated":"2017-06-21T05:33:15.442Z","path":"tags/index.html","comments":1,"_id":"cj8dw0nfo0006qnjxl42kyb1x","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"GCC的编译流程","date":"2015-04-12T06:20:00.000Z","_content":"\n**GCC的编译流程分为了4个步骤**\n\n- 预处理（Pre-Processing）\n- 编译（Compiling）\n- 汇编（Assembling）\n- 链接（Linking）\n\n**GCC使用的基本语法为：**\n\n    gcc [option | filename]\n\n预处理阶段\n\n    gcc –E –o [目标文件] [编译文件]\n\n选项“-E”可以使编译器在预处理结束时就停止编译,选项“-o”是指定GCC输出的结果。\n\n编译阶段\n\n    gcc –S –o hello.s hello.i\n\n 选项“-S”能使编译器在进行完编译之后就停止\n\n汇编阶段\n\n    gcc –c hello.s –o hello.\n    \n选项“-c”把编译阶段生成的“.s”文件生成目标文件 “.o”\n\n链接阶段\n\n    gcc hello.o –o hello\n\n可以生成可执行文件","source":"_posts/GCC的编译流程.md","raw":"---\ntitle: GCC的编译流程\ndate: 2015-04-12 14:20\ntags:\n - C++\n---\n\n**GCC的编译流程分为了4个步骤**\n\n- 预处理（Pre-Processing）\n- 编译（Compiling）\n- 汇编（Assembling）\n- 链接（Linking）\n\n**GCC使用的基本语法为：**\n\n    gcc [option | filename]\n\n预处理阶段\n\n    gcc –E –o [目标文件] [编译文件]\n\n选项“-E”可以使编译器在预处理结束时就停止编译,选项“-o”是指定GCC输出的结果。\n\n编译阶段\n\n    gcc –S –o hello.s hello.i\n\n 选项“-S”能使编译器在进行完编译之后就停止\n\n汇编阶段\n\n    gcc –c hello.s –o hello.\n    \n选项“-c”把编译阶段生成的“.s”文件生成目标文件 “.o”\n\n链接阶段\n\n    gcc hello.o –o hello\n\n可以生成可执行文件","slug":"GCC的编译流程","published":1,"updated":"2017-06-22T07:11:06.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8dw0nf90000qnjxg1gvlkkr","content":"<p><strong>GCC的编译流程分为了4个步骤</strong></p>\n<ul>\n<li>预处理（Pre-Processing）</li>\n<li>编译（Compiling）</li>\n<li>汇编（Assembling）</li>\n<li>链接（Linking）</li>\n</ul>\n<p><strong>GCC使用的基本语法为：</strong></p>\n<pre><code>gcc [option | filename]\n</code></pre><p>预处理阶段</p>\n<pre><code>gcc –E –o [目标文件] [编译文件]\n</code></pre><p>选项“-E”可以使编译器在预处理结束时就停止编译,选项“-o”是指定GCC输出的结果。</p>\n<p>编译阶段</p>\n<pre><code>gcc –S –o hello.s hello.i\n</code></pre><p> 选项“-S”能使编译器在进行完编译之后就停止</p>\n<p>汇编阶段</p>\n<pre><code>gcc –c hello.s –o hello.\n</code></pre><p>选项“-c”把编译阶段生成的“.s”文件生成目标文件 “.o”</p>\n<p>链接阶段</p>\n<pre><code>gcc hello.o –o hello\n</code></pre><p>可以生成可执行文件</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>GCC的编译流程分为了4个步骤</strong></p>\n<ul>\n<li>预处理（Pre-Processing）</li>\n<li>编译（Compiling）</li>\n<li>汇编（Assembling）</li>\n<li>链接（Linking）</li>\n</ul>\n<p><strong>GCC使用的基本语法为：</strong></p>\n<pre><code>gcc [option | filename]\n</code></pre><p>预处理阶段</p>\n<pre><code>gcc –E –o [目标文件] [编译文件]\n</code></pre><p>选项“-E”可以使编译器在预处理结束时就停止编译,选项“-o”是指定GCC输出的结果。</p>\n<p>编译阶段</p>\n<pre><code>gcc –S –o hello.s hello.i\n</code></pre><p> 选项“-S”能使编译器在进行完编译之后就停止</p>\n<p>汇编阶段</p>\n<pre><code>gcc –c hello.s –o hello.\n</code></pre><p>选项“-c”把编译阶段生成的“.s”文件生成目标文件 “.o”</p>\n<p>链接阶段</p>\n<pre><code>gcc hello.o –o hello\n</code></pre><p>可以生成可执行文件</p>\n"},{"title":"Github-Pages结合Hexo搭建博客","date":"2016-01-12T09:20:00.000Z","_content":"\n###  Github-Pages结合Hexo搭建博客\n\n### 一 : 环境准备\n\n- 安装Git\n- 安装Node.js\n\n### 二 : Hexo安装\n```\nnpm install -g hexo-cli\n常用命令：\nhexo help #查看帮助\nhexo init #初始化一个目录\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成网页，可以在 public 目录查看整个网站的文件\nhexo server #本地预览，'Ctrl+C'关闭\nhexo deploy #部署.deploy目录\nhexo clean #清除缓存，**强烈建议执行命令前先清理缓存，部署前先删除 .deploy 文件夹**\n简写：\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n\n```\n### 三 ：Setup\n```\n$ hexo init folder\n$ cd folder\n$ npm install\n\nhexo目录结构\n├── .deploy #需要部署的文件\n├── node_modules #Hexo插件\n├── public #生成的静态网页文件\n├── scaffolds #模板\n├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里\n ├── _drafts #草稿\n └── _posts #文章\n├── themes #主题\n├── _config.yml #全局配置文件\n└── package.json\n\n```\n### 四 ：设置_config.yml\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n# Site #站点信息\ntitle:  #标题\nsubtitle:  #副标题\ndescription:  #站点描述，给搜索引擎看的\nauthor:  #作者\nemail:  #电子邮箱\nlanguage: zh-CN #语言\n# URL #链接格式\nurl:  #网址\nroot: / #根目录\npermalink: :year/:month/:day/:title/ #文章的链接格式\ntag_dir: tags #标签目录\narchive_dir: archives #存档目录\ncategory_dir: categories #分类目录\ncode_dir: downloads/code\npermalink_defaults:\n# Directory #目录\nsource_dir: source #源文件目录\npublic_dir: public #生成的网页文件目录\n# Writing #写作\nnew_post_name: :title.md #新文章标题\ndefault_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）\ntitlecase: false #标题转换成大写\nexternal_link: true #在新选项卡中打开连接\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nhighlight: #语法高亮\n  enable: true #是否启用\n  line_number: true #显示行号\n  tab_replace:\n# Category & Tag #分类和标签\ndefault_category: uncategorized #默认分类\ncategory_map:\ntag_map:\n# Archives\n2: 开启分页\n1: 禁用分页\n0: 全部禁用\narchive: 2\ncategory: 2\ntag: 2\n# Server #本地服务器\nport: 4000 #端口号\nserver_ip: localhost #IP 地址\nlogger: false\nlogger_format: dev\n# Date / Time format #日期时间格式\ndate_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/\ntime_format: H:mm:ss\n# Pagination #分页\nper_page: 10 #每页文章数，设置成 0 禁用分页\npagination_dir: page\n# Disqus #Disqus评论，替换为多说\ndisqus_shortname:\n# Extensions #拓展插件\ntheme: landscape-plus #主题\nexclude_generator:\nplugins: #插件，例如生成 RSS 和站点地图的\n- hexo-generator-feed\n- hexo-generator-sitemap\n# Deployment #部署，将 lmintlcx 改成用户名\ndeploy:\n  type: git\n  repo: 刚刚github创库地址.git\n  branch: master\n\n```\n**注意**\n\n    配置文件的冒号“:”后面有一个空格\n\n    repo: 刚刚github创库地址.git 如：https://github.com/kriry/kriry.github.io.git\n\n\n### 五 ：发布到Github\n```\n1: 生成SSH密钥\nssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，则密码为空。\n在～.ssh下，得到两个文件id_rsa和id_rsa.pub。\n2： 在GitHub上添加SSH密钥\n打开id_rsa.pub，复制全文。 https://github.com/settings/ssh ，Add SSH key，粘贴进去。\n3： 部署：\n$ hexo server  //可以先本地预览看看,浏览器访问：http://localhost:4000\n$ hexo generate  //重新生成静态博客的所有内容\n$ npm install hexo-deployer-git --save  //安装git部署插件\n$ hexo deploy  //发布到Github,访问：http://kriry.github.io\n每次发表新文章部署按这样的流程：\n$ hexo clean\n$ hexo generate\n$ hexo deploy\n\n```\n","source":"_posts/Github-Pages结合Hexo搭建博客.md","raw":"---\ntitle: Github-Pages结合Hexo搭建博客\ndate: 2016-01-12 17:20\ntags:\n - Github\n - hexo\n---\n\n###  Github-Pages结合Hexo搭建博客\n\n### 一 : 环境准备\n\n- 安装Git\n- 安装Node.js\n\n### 二 : Hexo安装\n```\nnpm install -g hexo-cli\n常用命令：\nhexo help #查看帮助\nhexo init #初始化一个目录\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成网页，可以在 public 目录查看整个网站的文件\nhexo server #本地预览，'Ctrl+C'关闭\nhexo deploy #部署.deploy目录\nhexo clean #清除缓存，**强烈建议执行命令前先清理缓存，部署前先删除 .deploy 文件夹**\n简写：\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n\n```\n### 三 ：Setup\n```\n$ hexo init folder\n$ cd folder\n$ npm install\n\nhexo目录结构\n├── .deploy #需要部署的文件\n├── node_modules #Hexo插件\n├── public #生成的静态网页文件\n├── scaffolds #模板\n├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里\n ├── _drafts #草稿\n └── _posts #文章\n├── themes #主题\n├── _config.yml #全局配置文件\n└── package.json\n\n```\n### 四 ：设置_config.yml\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n# Site #站点信息\ntitle:  #标题\nsubtitle:  #副标题\ndescription:  #站点描述，给搜索引擎看的\nauthor:  #作者\nemail:  #电子邮箱\nlanguage: zh-CN #语言\n# URL #链接格式\nurl:  #网址\nroot: / #根目录\npermalink: :year/:month/:day/:title/ #文章的链接格式\ntag_dir: tags #标签目录\narchive_dir: archives #存档目录\ncategory_dir: categories #分类目录\ncode_dir: downloads/code\npermalink_defaults:\n# Directory #目录\nsource_dir: source #源文件目录\npublic_dir: public #生成的网页文件目录\n# Writing #写作\nnew_post_name: :title.md #新文章标题\ndefault_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）\ntitlecase: false #标题转换成大写\nexternal_link: true #在新选项卡中打开连接\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nhighlight: #语法高亮\n  enable: true #是否启用\n  line_number: true #显示行号\n  tab_replace:\n# Category & Tag #分类和标签\ndefault_category: uncategorized #默认分类\ncategory_map:\ntag_map:\n# Archives\n2: 开启分页\n1: 禁用分页\n0: 全部禁用\narchive: 2\ncategory: 2\ntag: 2\n# Server #本地服务器\nport: 4000 #端口号\nserver_ip: localhost #IP 地址\nlogger: false\nlogger_format: dev\n# Date / Time format #日期时间格式\ndate_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/\ntime_format: H:mm:ss\n# Pagination #分页\nper_page: 10 #每页文章数，设置成 0 禁用分页\npagination_dir: page\n# Disqus #Disqus评论，替换为多说\ndisqus_shortname:\n# Extensions #拓展插件\ntheme: landscape-plus #主题\nexclude_generator:\nplugins: #插件，例如生成 RSS 和站点地图的\n- hexo-generator-feed\n- hexo-generator-sitemap\n# Deployment #部署，将 lmintlcx 改成用户名\ndeploy:\n  type: git\n  repo: 刚刚github创库地址.git\n  branch: master\n\n```\n**注意**\n\n    配置文件的冒号“:”后面有一个空格\n\n    repo: 刚刚github创库地址.git 如：https://github.com/kriry/kriry.github.io.git\n\n\n### 五 ：发布到Github\n```\n1: 生成SSH密钥\nssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，则密码为空。\n在～.ssh下，得到两个文件id_rsa和id_rsa.pub。\n2： 在GitHub上添加SSH密钥\n打开id_rsa.pub，复制全文。 https://github.com/settings/ssh ，Add SSH key，粘贴进去。\n3： 部署：\n$ hexo server  //可以先本地预览看看,浏览器访问：http://localhost:4000\n$ hexo generate  //重新生成静态博客的所有内容\n$ npm install hexo-deployer-git --save  //安装git部署插件\n$ hexo deploy  //发布到Github,访问：http://kriry.github.io\n每次发表新文章部署按这样的流程：\n$ hexo clean\n$ hexo generate\n$ hexo deploy\n\n```\n","slug":"Github-Pages结合Hexo搭建博客","published":1,"updated":"2017-07-01T13:18:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8dw0nfh0002qnjxn3luwe37","content":"<h3 id=\"Github-Pages结合Hexo搭建博客\"><a href=\"#Github-Pages结合Hexo搭建博客\" class=\"headerlink\" title=\"Github-Pages结合Hexo搭建博客\"></a>Github-Pages结合Hexo搭建博客</h3><h3 id=\"一-环境准备\"><a href=\"#一-环境准备\" class=\"headerlink\" title=\"一 : 环境准备\"></a>一 : 环境准备</h3><ul>\n<li>安装Git</li>\n<li>安装Node.js</li>\n</ul>\n<h3 id=\"二-Hexo安装\"><a href=\"#二-Hexo安装\" class=\"headerlink\" title=\"二 : Hexo安装\"></a>二 : Hexo安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div><div class=\"line\">常用命令：</div><div class=\"line\">hexo help #查看帮助</div><div class=\"line\">hexo init #初始化一个目录</div><div class=\"line\">hexo new &quot;postName&quot; #新建文章</div><div class=\"line\">hexo new page &quot;pageName&quot; #新建页面</div><div class=\"line\">hexo generate #生成网页，可以在 public 目录查看整个网站的文件</div><div class=\"line\">hexo server #本地预览，&apos;Ctrl+C&apos;关闭</div><div class=\"line\">hexo deploy #部署.deploy目录</div><div class=\"line\">hexo clean #清除缓存，**强烈建议执行命令前先清理缓存，部署前先删除 .deploy 文件夹**</div><div class=\"line\">简写：</div><div class=\"line\">hexo n == hexo new</div><div class=\"line\">hexo g == hexo generate</div><div class=\"line\">hexo s == hexo server</div><div class=\"line\">hexo d == hexo deploy</div></pre></td></tr></table></figure>\n<h3 id=\"三-：Setup\"><a href=\"#三-：Setup\" class=\"headerlink\" title=\"三 ：Setup\"></a>三 ：Setup</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo init folder</div><div class=\"line\">$ cd folder</div><div class=\"line\">$ npm install</div><div class=\"line\"></div><div class=\"line\">hexo目录结构</div><div class=\"line\">├── .deploy #需要部署的文件</div><div class=\"line\">├── node_modules #Hexo插件</div><div class=\"line\">├── public #生成的静态网页文件</div><div class=\"line\">├── scaffolds #模板</div><div class=\"line\">├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里</div><div class=\"line\"> ├── _drafts #草稿</div><div class=\"line\"> └── _posts #文章</div><div class=\"line\">├── themes #主题</div><div class=\"line\">├── _config.yml #全局配置文件</div><div class=\"line\">└── package.json</div></pre></td></tr></table></figure>\n<h3 id=\"四-：设置-config-yml\"><a href=\"#四-：设置-config-yml\" class=\"headerlink\" title=\"四 ：设置_config.yml\"></a>四 ：设置_config.yml</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: http://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"># Site #站点信息</div><div class=\"line\">title:  #标题</div><div class=\"line\">subtitle:  #副标题</div><div class=\"line\">description:  #站点描述，给搜索引擎看的</div><div class=\"line\">author:  #作者</div><div class=\"line\">email:  #电子邮箱</div><div class=\"line\">language: zh-CN #语言</div><div class=\"line\"># URL #链接格式</div><div class=\"line\">url:  #网址</div><div class=\"line\">root: / #根目录</div><div class=\"line\">permalink: :year/:month/:day/:title/ #文章的链接格式</div><div class=\"line\">tag_dir: tags #标签目录</div><div class=\"line\">archive_dir: archives #存档目录</div><div class=\"line\">category_dir: categories #分类目录</div><div class=\"line\">code_dir: downloads/code</div><div class=\"line\">permalink_defaults:</div><div class=\"line\"># Directory #目录</div><div class=\"line\">source_dir: source #源文件目录</div><div class=\"line\">public_dir: public #生成的网页文件目录</div><div class=\"line\"># Writing #写作</div><div class=\"line\">new_post_name: :title.md #新文章标题</div><div class=\"line\">default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）</div><div class=\"line\">titlecase: false #标题转换成大写</div><div class=\"line\">external_link: true #在新选项卡中打开连接</div><div class=\"line\">filename_case: 0</div><div class=\"line\">render_drafts: false</div><div class=\"line\">post_asset_folder: false</div><div class=\"line\">relative_link: false</div><div class=\"line\">highlight: #语法高亮</div><div class=\"line\">  enable: true #是否启用</div><div class=\"line\">  line_number: true #显示行号</div><div class=\"line\">  tab_replace:</div><div class=\"line\"># Category &amp; Tag #分类和标签</div><div class=\"line\">default_category: uncategorized #默认分类</div><div class=\"line\">category_map:</div><div class=\"line\">tag_map:</div><div class=\"line\"># Archives</div><div class=\"line\">2: 开启分页</div><div class=\"line\">1: 禁用分页</div><div class=\"line\">0: 全部禁用</div><div class=\"line\">archive: 2</div><div class=\"line\">category: 2</div><div class=\"line\">tag: 2</div><div class=\"line\"># Server #本地服务器</div><div class=\"line\">port: 4000 #端口号</div><div class=\"line\">server_ip: localhost #IP 地址</div><div class=\"line\">logger: false</div><div class=\"line\">logger_format: dev</div><div class=\"line\"># Date / Time format #日期时间格式</div><div class=\"line\">date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/</div><div class=\"line\">time_format: H:mm:ss</div><div class=\"line\"># Pagination #分页</div><div class=\"line\">per_page: 10 #每页文章数，设置成 0 禁用分页</div><div class=\"line\">pagination_dir: page</div><div class=\"line\"># Disqus #Disqus评论，替换为多说</div><div class=\"line\">disqus_shortname:</div><div class=\"line\"># Extensions #拓展插件</div><div class=\"line\">theme: landscape-plus #主题</div><div class=\"line\">exclude_generator:</div><div class=\"line\">plugins: #插件，例如生成 RSS 和站点地图的</div><div class=\"line\">- hexo-generator-feed</div><div class=\"line\">- hexo-generator-sitemap</div><div class=\"line\"># Deployment #部署，将 lmintlcx 改成用户名</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repo: 刚刚github创库地址.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p><strong>注意</strong></p>\n<pre><code>配置文件的冒号“:”后面有一个空格\n\nrepo: 刚刚github创库地址.git 如：https://github.com/kriry/kriry.github.io.git\n</code></pre><h3 id=\"五-：发布到Github\"><a href=\"#五-：发布到Github\" class=\"headerlink\" title=\"五 ：发布到Github\"></a>五 ：发布到Github</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">1: 生成SSH密钥</div><div class=\"line\">ssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，则密码为空。</div><div class=\"line\">在～.ssh下，得到两个文件id_rsa和id_rsa.pub。</div><div class=\"line\">2： 在GitHub上添加SSH密钥</div><div class=\"line\">打开id_rsa.pub，复制全文。 https://github.com/settings/ssh ，Add SSH key，粘贴进去。</div><div class=\"line\">3： 部署：</div><div class=\"line\">$ hexo server  //可以先本地预览看看,浏览器访问：http://localhost:4000</div><div class=\"line\">$ hexo generate  //重新生成静态博客的所有内容</div><div class=\"line\">$ npm install hexo-deployer-git --save  //安装git部署插件</div><div class=\"line\">$ hexo deploy  //发布到Github,访问：http://kriry.github.io</div><div class=\"line\">每次发表新文章部署按这样的流程：</div><div class=\"line\">$ hexo clean</div><div class=\"line\">$ hexo generate</div><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Github-Pages结合Hexo搭建博客\"><a href=\"#Github-Pages结合Hexo搭建博客\" class=\"headerlink\" title=\"Github-Pages结合Hexo搭建博客\"></a>Github-Pages结合Hexo搭建博客</h3><h3 id=\"一-环境准备\"><a href=\"#一-环境准备\" class=\"headerlink\" title=\"一 : 环境准备\"></a>一 : 环境准备</h3><ul>\n<li>安装Git</li>\n<li>安装Node.js</li>\n</ul>\n<h3 id=\"二-Hexo安装\"><a href=\"#二-Hexo安装\" class=\"headerlink\" title=\"二 : Hexo安装\"></a>二 : Hexo安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div><div class=\"line\">常用命令：</div><div class=\"line\">hexo help #查看帮助</div><div class=\"line\">hexo init #初始化一个目录</div><div class=\"line\">hexo new &quot;postName&quot; #新建文章</div><div class=\"line\">hexo new page &quot;pageName&quot; #新建页面</div><div class=\"line\">hexo generate #生成网页，可以在 public 目录查看整个网站的文件</div><div class=\"line\">hexo server #本地预览，&apos;Ctrl+C&apos;关闭</div><div class=\"line\">hexo deploy #部署.deploy目录</div><div class=\"line\">hexo clean #清除缓存，**强烈建议执行命令前先清理缓存，部署前先删除 .deploy 文件夹**</div><div class=\"line\">简写：</div><div class=\"line\">hexo n == hexo new</div><div class=\"line\">hexo g == hexo generate</div><div class=\"line\">hexo s == hexo server</div><div class=\"line\">hexo d == hexo deploy</div></pre></td></tr></table></figure>\n<h3 id=\"三-：Setup\"><a href=\"#三-：Setup\" class=\"headerlink\" title=\"三 ：Setup\"></a>三 ：Setup</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo init folder</div><div class=\"line\">$ cd folder</div><div class=\"line\">$ npm install</div><div class=\"line\"></div><div class=\"line\">hexo目录结构</div><div class=\"line\">├── .deploy #需要部署的文件</div><div class=\"line\">├── node_modules #Hexo插件</div><div class=\"line\">├── public #生成的静态网页文件</div><div class=\"line\">├── scaffolds #模板</div><div class=\"line\">├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里</div><div class=\"line\"> ├── _drafts #草稿</div><div class=\"line\"> └── _posts #文章</div><div class=\"line\">├── themes #主题</div><div class=\"line\">├── _config.yml #全局配置文件</div><div class=\"line\">└── package.json</div></pre></td></tr></table></figure>\n<h3 id=\"四-：设置-config-yml\"><a href=\"#四-：设置-config-yml\" class=\"headerlink\" title=\"四 ：设置_config.yml\"></a>四 ：设置_config.yml</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hexo Configuration</div><div class=\"line\">## Docs: http://hexo.io/docs/configuration.html</div><div class=\"line\">## Source: https://github.com/hexojs/hexo/</div><div class=\"line\"># Site #站点信息</div><div class=\"line\">title:  #标题</div><div class=\"line\">subtitle:  #副标题</div><div class=\"line\">description:  #站点描述，给搜索引擎看的</div><div class=\"line\">author:  #作者</div><div class=\"line\">email:  #电子邮箱</div><div class=\"line\">language: zh-CN #语言</div><div class=\"line\"># URL #链接格式</div><div class=\"line\">url:  #网址</div><div class=\"line\">root: / #根目录</div><div class=\"line\">permalink: :year/:month/:day/:title/ #文章的链接格式</div><div class=\"line\">tag_dir: tags #标签目录</div><div class=\"line\">archive_dir: archives #存档目录</div><div class=\"line\">category_dir: categories #分类目录</div><div class=\"line\">code_dir: downloads/code</div><div class=\"line\">permalink_defaults:</div><div class=\"line\"># Directory #目录</div><div class=\"line\">source_dir: source #源文件目录</div><div class=\"line\">public_dir: public #生成的网页文件目录</div><div class=\"line\"># Writing #写作</div><div class=\"line\">new_post_name: :title.md #新文章标题</div><div class=\"line\">default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）</div><div class=\"line\">titlecase: false #标题转换成大写</div><div class=\"line\">external_link: true #在新选项卡中打开连接</div><div class=\"line\">filename_case: 0</div><div class=\"line\">render_drafts: false</div><div class=\"line\">post_asset_folder: false</div><div class=\"line\">relative_link: false</div><div class=\"line\">highlight: #语法高亮</div><div class=\"line\">  enable: true #是否启用</div><div class=\"line\">  line_number: true #显示行号</div><div class=\"line\">  tab_replace:</div><div class=\"line\"># Category &amp; Tag #分类和标签</div><div class=\"line\">default_category: uncategorized #默认分类</div><div class=\"line\">category_map:</div><div class=\"line\">tag_map:</div><div class=\"line\"># Archives</div><div class=\"line\">2: 开启分页</div><div class=\"line\">1: 禁用分页</div><div class=\"line\">0: 全部禁用</div><div class=\"line\">archive: 2</div><div class=\"line\">category: 2</div><div class=\"line\">tag: 2</div><div class=\"line\"># Server #本地服务器</div><div class=\"line\">port: 4000 #端口号</div><div class=\"line\">server_ip: localhost #IP 地址</div><div class=\"line\">logger: false</div><div class=\"line\">logger_format: dev</div><div class=\"line\"># Date / Time format #日期时间格式</div><div class=\"line\">date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/</div><div class=\"line\">time_format: H:mm:ss</div><div class=\"line\"># Pagination #分页</div><div class=\"line\">per_page: 10 #每页文章数，设置成 0 禁用分页</div><div class=\"line\">pagination_dir: page</div><div class=\"line\"># Disqus #Disqus评论，替换为多说</div><div class=\"line\">disqus_shortname:</div><div class=\"line\"># Extensions #拓展插件</div><div class=\"line\">theme: landscape-plus #主题</div><div class=\"line\">exclude_generator:</div><div class=\"line\">plugins: #插件，例如生成 RSS 和站点地图的</div><div class=\"line\">- hexo-generator-feed</div><div class=\"line\">- hexo-generator-sitemap</div><div class=\"line\"># Deployment #部署，将 lmintlcx 改成用户名</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repo: 刚刚github创库地址.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure>\n<p><strong>注意</strong></p>\n<pre><code>配置文件的冒号“:”后面有一个空格\n\nrepo: 刚刚github创库地址.git 如：https://github.com/kriry/kriry.github.io.git\n</code></pre><h3 id=\"五-：发布到Github\"><a href=\"#五-：发布到Github\" class=\"headerlink\" title=\"五 ：发布到Github\"></a>五 ：发布到Github</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">1: 生成SSH密钥</div><div class=\"line\">ssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，则密码为空。</div><div class=\"line\">在～.ssh下，得到两个文件id_rsa和id_rsa.pub。</div><div class=\"line\">2： 在GitHub上添加SSH密钥</div><div class=\"line\">打开id_rsa.pub，复制全文。 https://github.com/settings/ssh ，Add SSH key，粘贴进去。</div><div class=\"line\">3： 部署：</div><div class=\"line\">$ hexo server  //可以先本地预览看看,浏览器访问：http://localhost:4000</div><div class=\"line\">$ hexo generate  //重新生成静态博客的所有内容</div><div class=\"line\">$ npm install hexo-deployer-git --save  //安装git部署插件</div><div class=\"line\">$ hexo deploy  //发布到Github,访问：http://kriry.github.io</div><div class=\"line\">每次发表新文章部署按这样的流程：</div><div class=\"line\">$ hexo clean</div><div class=\"line\">$ hexo generate</div><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n"},{"title":"Polymer 2.x Cheat Sheet","date":"2017-07-11T12:41:33.809Z","_content":"\n\nThis is a cheat sheet for the [Polymer 2.x](https://www.polymer-project.org/) library.\n\n\n- Defining an element\n- Extending an element\n- Defining a mixin\n- Lifecycle methods\n- Data binding\n- Observers\n- Listeners\n- Properties block\n- Observing added and removed children\n- Style modules\n- Styling with custom properties and - - mixins\n- Binding helper elements\n\n## Defining an element\n\nDocs: [1.x -> 2.x upgrade guide](https://www.polymer-project.org/2.0/docs/upgrade),\n[registering an element](https://www.polymer-project.org/2.0/docs/devguide/registering-elements),\n[shared style modules](https://www.polymer-project.org/2.0/docs/devguide/style-shadow-dom#style-modules).\n\n```html\n<link rel=\"import\" href=\"bower_components/polymer/polymer-element.html\">\n<dom-module id=\"element-name\">\n  <template>\n    <!-- Use one of these style declarations, but not both -->\n    <!-- Use this if you don’t want to include a shared style -->\n    <style></style>\n    <!-- Use this if you want to include a shared style -->\n    <style include=\"some-style-module-name\"></style>\n  </template>\n  <script>\n    class MyElement extends Polymer.Element {\n      static get is() { return 'element-name'; }\n      // All of these are optional. Only keep the ones you need.\n      static get properties() { ... }\n      static get observers() { ... }\n    }\n\n    // Associate the new class with an element name\n    customElements.define(MyElement.is, MyElement);\n  </script>\n</dom-module>\n```\n\nTo get the class definition for a particular custom tag, you can use\n`customElements.get('element-name')`.\n\n## Extending an element\n\nDocs: [extending elements](https://www.polymer-project.org/2.0/docs/devguide/custom-elements#extending-other-elements), [inherited templates](https://www.polymer-project.org/2.0/docs/devguide/dom-template#inherited-templates).\n\nInstead of `Polymer.Element`, a custom element can extend a different element):\n```js\nclass ParentElement extends Polymer.Element {\n  /* ... */\n}\nclass ChildElement extends ParentElement {\n  /* ... */\n}\n```\n\nTo change or add to the parent's template, override the `template` getter:\n\n```html\n<dom-module id=\"child-element\">\n  <template>\n    <style> /* ... */ </style>\n    <span>bonus!</span>\n   </template>\n  <script>\n    var childTemplate;\n    var childTemplate = Polymer.DomModule.import('child-element', 'template');\n    var parentTemplate = ParentElement.template.cloneNode(true);\n    // Or however you want to assemble these.\n    childTemplate.content.insertBefore(parentTemplate.firstChild, parentTemplate);\n\n    class ChildElement extends ParentElement {\n      static get is() { return 'child-element'; }\n      // Note: the more work you do here, the slower your element is to\n      // boot up. You should probably do the template assembling once, in a\n      // static method outside your class (like above).\n      static get template() {\n        return childTemplate;\n      }\n    }\n    customElements.define(ChildElement.is, ChildElement);\n  </script>\n</dom-module>\n```\n\nIf you don't know the parent class, you can also use:\n\n```js\nclass ChildElement extends customElement.get('parent-element') {\n  /* ... */\n}\n```\n\n## Defining a mixin\n\nDocs: [mixins](https://www.polymer-project.org/2.0/docs/devguide/custom-elements#mixins),\n[hybrid elements](https://www.polymer-project.org/2.0/docs/devguide/hybrid-elements).\n\nDefining a class expression mixin to share implementation between different elements:\n\n```html\n<script>\n  MyMixin = function(superClass) {\n    return class extends superClass {\n      // Code that you want common to elements.\n      // If you're going to override a lifecycle method, remember that a) you\n      // might need to call super but b) it might not exist\n      connectedCallback() {\n        if (super.connectedCallback) {\n          super.connectedCallback();\n        }\n        /* ... */\n      }\n    }\n  }\n</script>\n```\n\nUsing the mixin in an element definition:\n\n```html\n<dom-module id=\"element-name\">\n  <template><!-- ... --></template>\n  <script>\n    // This could also be a sequence:\n    //class MyElement extends AnotherMixin(MyMixin(Polymer.Element)) { … }\n    class MyElement extends MyMixin(Polymer.Element) {\n      static get is() { return 'element-name' }\n      /* ... */\n    }\n    customElements.define(MyElement.is, MyElement);\n  </script>\n</dom-module>\n```\n\nUsing hybrid behaviors (defined in the 1.x syntax) as mixins:\n\n```html\n<dom-module id=\"element-name\">\n  <template><!-- ... --></template>\n  <script>\n    class MyElement extends Polymer.mixinBehaviors([MyBehavior, MyBehavior2], Polymer.Element) {\n     static get is() { return 'element-name' }\n     /* ... */\n    }\n    customElements.define('element-name', MyElement);\n  </script>\n</dom-module>\n```\n\n## Lifecycle methods\n\nDocs: [lifecycle callbacks](https://www.polymer-project.org/2.0/docs/devguide/custom-elements#element-lifecycle),\n[ready](https://www.polymer-project.org/2.0/docs/devguide/custom-elements#one-time-initialization).\n\n```js\nclass MyElement extends Polymer.Element {\n constructor() { super(); /* ... */}\n ready() { super.ready(); /* ... */}\n connectedCallback() { super.connectedCallback(); /* ... */}\n disconnectedCallback() { super.disconnectedCallback(); /* ... */}\n attributeChangedCallback() { super.attributeChangedCallback(); /* ... */}\n}\n```\n\n## Data binding\nDocs: [data binding](https://www.polymer-project.org/2.0/docs/devguide/data-binding),\n[attribute binding](https://www.polymer-project.org/2.0/docs/devguide/data-binding#attribute-binding),\n[binding to array items](https://www.polymer-project.org/2.0/docs/devguide/data-binding#bind-array-item),\n[computed bindings](https://www.polymer-project.org/2.0/docs/devguide/data-binding#annotated-computed).\n\nDon't forget: Polymer [camel-cases](https://www.polymer-project.org/2.0/docs/devguide/properties#property-name-mapping) properties, so if in JavaScript you use `myProperty`,\nin HTML you would use `my-property`.\n\n**One way** binding: when `myProperty` changes, `theirProperty` gets updated:\n\n```html\n<some-element their-property=\"[[myProperty]]\"></some-element>\n```\n\n**Two way** binding: when `myProperty` changes, `theirProperty` gets updated,\nand vice versa:\n\n```html\n<some-element their-property=\"{{myProperty}}\"></some-element>\n```\n\n**Attribute binding**: when `myProperty` is `true`, the element is hidden; when it's\n`false`, the element is visible. The difference between attribute and property\nbinding is that property binding is equivalent to `someElement.someProp = value`,\nwhereas attribute binding is equivalent to: `someElement.setAttribute(someProp, value)`\n\n```html\n<some-element hidden$=\"[[myProperty]]\"></some-element>\n```\n\n**Computed binding**: binding to the `class` attribute will recompile styles when\n`myProperty` changes:\n\n```html\n<some-element class$=\"[[_computeSomething(myProperty)]]\"></some-element>\n<script>\n_computeSomething: function(prop) {\n  return prop ? 'a-class-name' : 'another-class-name';\n}\n</script>\n```\n\n## Observers\n\nDocs: [observers](https://www.polymer-project.org/2.0/docs/devguide/observers),\n[multi-property observers](https://www.polymer-project.org/2.0/docs/devguide/observers#multi-property-observers),\n[observing array mutations](https://www.polymer-project.org/2.0/docs/devguide/observers#array-observation),\n[adding observers dynamically](https://www.polymer-project.org/2.0/docs/devguide/observers#dynamic-observers).\n\nAdding an `observer` in the `properties` block lets you observe changes in the\nvalue of a property:\n\n```js\nstatic get properties() {\n  return {\n    myProperty: {\n      observer: '_myPropertyChanged'\n    }\n  }\n}\n\n// The second argument is optional, and gives you the\n// previous value of the property, before the update:\n_myPropertyChanged(value, /*oldValue */) { /* ... */ }\n```\n\nIn the `observers` block:\n\n```js\nstatic get observers() {\n  return [\n    '_doSomething(myProperty)',\n    '_multiPropertyObserver(myProperty, anotherProperty)',\n    '_observerForASubProperty(user.name)',\n    // Below, items can be an array or an object:'\n    '_observerForABunchOfSubPaths(items.*)'\n  ]\n}\n```\n\nAdding an observer dynamically for a property `otherProperty`:\n```js\n// Define a method\n_otherPropertyChanged(value) { /* ... */ }\n// Call it when `otherPropety` changes\nthis._createPropertyObserver('otherProperty', '_otherPropertyChanged', true);\n```\n\n## Listeners\nIn Polymer 2.0, we recommend that rather than using the `listeners` block,\nyou #useThePlatform and define event listeners yourself:\n\n```js\nready() {\n  super.ready();\n  window.addEventListener('some-event', () => this.someFunction());\n}\n```\n\nThere is a [PR](https://github.com/Polymer/polymer/pull/4632) out to add a\ndeclarative listener block as a mixin. Stay tuned!\n\n## Properties block\n\nDocs: [declared properties](https://www.polymer-project.org/2.0/docs/devguide/properties),\n[object/array properties](https://www.polymer-project.org/2.0/docs/devguide/properties#configuring-object-and-array-properties),\n[read-only properties](https://www.polymer-project.org/2.0/docs/devguide/properties#read-only),\n[computed properties](https://www.polymer-project.org/2.0/docs/devguide/observers#computed-properties),\n[adding computed properties dynamically](https://www.polymer-project.org/2.0/docs/devguide/observers#add-a-computed-property-dynamically).\n\nThere are all the possible things you can use in the `properties`\nblock. Don't just use all of them because you can; some (like `reflectToAttribute`\n  and `notify`) can have performance implications.\n\n```js\nstatic get properties() {\n  return {\n    basic: {\n      type: Boolean | Number | String | Array | Object,\n\n      // Default value of the property can be one of the types above, eg:\n      value: true,\n\n      // For an Array or Object, you must return it from a function\n      // (otherwise the array will be defined on the prototype\n      // and not the instance):\n      value: function() { return ['cheese', 'pepperoni', 'more-cheese'] },\n\n      reflectToAttribute: true | false,\n      readOnly: true | false,\n      notify: true | false\n    },\n\n    // Computed properties are essentially read-only, and can only be\n    // updated when their dependencies change.\n    basicComputedProperty: {\n      computed: '_someFunction(myProperty, anotherProperty)'\n    }\n  }\n}\n```\n\nAdding a computed property dynamically:\n```js\nthis._createComputedProperty('newProperty', '_computeNewProperty(prop1,prop2)', true);\n```\n\n## Observing added and removed children\n\nDocs: [Shadow DOM distribution](https://www.polymer-project.org/2.0/docs/devguide/shadow-dom#shadow-dom-and-composition),\n[observe nodes](https://www.polymer-project.org/2.0/docs/upgrade#polymer-dom-apis).\n\nIf you have a content node for distribution:\n\n```html\n<template>\n  <slot></slot>\n</template>\n```\nAnd you want to be notified when nodes have been added/removed:\n\n```html\n<!-- You need to import the observer -->\n<link rel=\"import\" href=\"/bower_components/polymer/lib/utils/flattened-nodes-observer.html\">\n\n<script>\nclass MyElement extends Polymer.Element {\n  /* ... */\n  connectedCallback: function() {\n    super.connectedCallback();\n    this._observer = new Polymer.FlattenedNodesObserver(function(info) {\n    // info is {addedNodes: [...], removedNodes: [...]}\n    });\n  }\n  disconnectedCallback: function() {\n    super.disconnectedCallback();\n    this._observer.disconnect();\n  }\n}\n</script>\n```\n\n## Style modules\nDocs: [shared style modules](https://www.polymer-project.org/2.0/docs/devguide/style-shadow-dom#style-modules).\n\nDefining styles that will be shared across different elements, in a file called\n`my-shared-styles.html` (for example):\n\n```html\n<dom-module id=\"my-shared-styles\">\n  <template>\n    <style>\n      .red { color: red; }\n      /* Custom property defined in the global scope */\n      html {\n        --the-best-red: #e91e63;\n      }\n    </style>\n  </template>\n</dom-module>\n```\n\nInclude the shared style in a custom element:\n\n```html\n<link rel=\"import\" href=\"my-shared-styles.html\">\n<dom-module id=\"element-name\">\n  <template>\n    <style include=\"my-shared-styles\">\n      /* Other styles in here */\n    </style>\n  </template>\n  <script>\n    class MyElement extends Polymer.Element {\n      /* ... */\n    }\n  </script>\n</dom-module>\n```\n\nInclude the shared style in the main document:\n\n```html\n<html>\n<head>\n  <!-- Import the custom-style element -->\n  <link rel=\"import\" href=\"components/polymer/lib/elements/custom-style.html\">\n  <link rel=\"import\" href=\"my-shared-styles.html\">\n  <custom-style>\n    <style include=\"my-shared-styles\">\n      /* Other styles in here */\n    </style>\n  </custom-style>\n</head>\n<body>...</body>\n</html>\n```\n\n## Styling with custom properties and mixins\n\nDocs: [styling](https://www.polymer-project.org/2.0/docs/devguide/style-shadow-dom),\n[CSS properties](https://www.polymer-project.org/2.0/docs/devguide/custom-css-properties),\n[CSS mixins](https://www.polymer-project.org/2.0/docs/devguide/custom-css-properties#use-custom-css-mixins),\n[shim limitations](https://www.polymer-project.org/2.0/docs/devguide/custom-css-properties#custom-properties-shim-limitations)\n\nNote that the examples below depend on browser support for custom properties and mixins.\n\nDefining a custom property:\n\n```css\nhtml /* or :host etc. */{\n  --my-custom-radius: 5px;\n}\n```\n\nUsing a custom property:\n\n```css\n.my-image {\n  border-radius: var(--my-custom-radius);\n}\n```\n\nUsing a custom property with a fallback:\n\n```css\n.my-image {\n  border-radius: var(--my-custom-radius, 3px);\n}\n```\n\nUsing a custom property with a custom property fallback:\n\n```css\n.my-image {\n  border-radius: var(--my-custom-radius, var(--my-fallback));\n}\n```\n\nIf you want to use mixins, you need to include the CSS mixins shim.\nFor how to use the shim and its limitations, check the docs linked at the\nbeginning of the section.\n```html\n<link rel=\"import\" href=\"/bower_components/shadycss/apply-shim.html\">\n```\n\nDefining a mixin:\n\n```css\nsome-custom-element {\n  --my-custom-mixin: {\n    border-radius: 5px;\n  };\n}\n```\n\nUsing a mixin:\n\n```css\n.my-image {\n  @apply --my-custom-mixin;\n}\n```\n\n## Binding helper elements\n\nDocs: [dom-repeat](https://www.polymer-project.org/2.0/docs/devguide/templates#dom-repeat),\n[dom-bind](https://www.polymer-project.org/2.0/docs/devguide/templates#dom-bind),\n[dom-if](https://www.polymer-project.org/2.0/docs/devguide/templates#dom-if)\n\nThere are two ways to use the helper elements:\n- inside a Polymer element/Polymer managed template: just use the `<template is=...>`\nsyntax, without the wrapper, for example:\n\n```html\n<template is=\"dom-repeat\">\n  ...\n</template>\n```\n- outside of a Polymer managed template: use the `<dom-...>` wrapper element\naround a `<template>`, for example:\n\n```html\n<dom-repeat>\n  <template>\n    ...\n  </template>\n</dom-repeat>\n```\n\n\n`dom-repeat` stamps and binds a template for each item in an array:\n\n```html\n<link rel=\"import\" href=\"components/polymer/lib/elements/dom-repeat.html\">\n<dom-repeat items=\"[[employees]]\">\n  <template>\n    <div>First name: <span>[[item.first]]</span></div>\n    <div>Last name: <span>[[item.last]]</span></div>\n  </template>\n</dom-repeat>\n```\n\n`dom-bind` stamps itself into the main document and adds a binding scope:\n\n```html\n<link rel=\"import\" href=\"components/polymer/lib/elements/dom-bind.html\">\n<html>\n<body>\n  <dom-bind>\n    <template>\n      <paper-input value=\"{{myText}}\"></paper-input>\n      <span>You typed: [[myText]]</span>\n    </template>\n  </dom-bind>\n</body>\n<html>\n```\n\n`dom-if` stamps itself conditionally based on a property's value:\n\n```html\n<link rel=\"import\" href=\"components/polymer/lib/elements/dom-if.html\">\n<dom-if if=\"[[myProperty]]\">\n  <template>\n    <span>This content will appear when myProperty is truthy.</span>\n  </template>\n</dom-if>  \n```\n\n> 原文出处：[Polymer 2.x Cheat Sheet](https://meowni.ca/posts/polymer-2-cheatsheet/).","source":"_posts/Polymer 2.x Cheat Sheet.md","raw":"---\ntitle: \"Polymer 2.x Cheat Sheet\"\ndate: 2017-06-12 154:20\ntags:\n - Polymer\n - Web\n---\n\n\nThis is a cheat sheet for the [Polymer 2.x](https://www.polymer-project.org/) library.\n\n\n- Defining an element\n- Extending an element\n- Defining a mixin\n- Lifecycle methods\n- Data binding\n- Observers\n- Listeners\n- Properties block\n- Observing added and removed children\n- Style modules\n- Styling with custom properties and - - mixins\n- Binding helper elements\n\n## Defining an element\n\nDocs: [1.x -> 2.x upgrade guide](https://www.polymer-project.org/2.0/docs/upgrade),\n[registering an element](https://www.polymer-project.org/2.0/docs/devguide/registering-elements),\n[shared style modules](https://www.polymer-project.org/2.0/docs/devguide/style-shadow-dom#style-modules).\n\n```html\n<link rel=\"import\" href=\"bower_components/polymer/polymer-element.html\">\n<dom-module id=\"element-name\">\n  <template>\n    <!-- Use one of these style declarations, but not both -->\n    <!-- Use this if you don’t want to include a shared style -->\n    <style></style>\n    <!-- Use this if you want to include a shared style -->\n    <style include=\"some-style-module-name\"></style>\n  </template>\n  <script>\n    class MyElement extends Polymer.Element {\n      static get is() { return 'element-name'; }\n      // All of these are optional. Only keep the ones you need.\n      static get properties() { ... }\n      static get observers() { ... }\n    }\n\n    // Associate the new class with an element name\n    customElements.define(MyElement.is, MyElement);\n  </script>\n</dom-module>\n```\n\nTo get the class definition for a particular custom tag, you can use\n`customElements.get('element-name')`.\n\n## Extending an element\n\nDocs: [extending elements](https://www.polymer-project.org/2.0/docs/devguide/custom-elements#extending-other-elements), [inherited templates](https://www.polymer-project.org/2.0/docs/devguide/dom-template#inherited-templates).\n\nInstead of `Polymer.Element`, a custom element can extend a different element):\n```js\nclass ParentElement extends Polymer.Element {\n  /* ... */\n}\nclass ChildElement extends ParentElement {\n  /* ... */\n}\n```\n\nTo change or add to the parent's template, override the `template` getter:\n\n```html\n<dom-module id=\"child-element\">\n  <template>\n    <style> /* ... */ </style>\n    <span>bonus!</span>\n   </template>\n  <script>\n    var childTemplate;\n    var childTemplate = Polymer.DomModule.import('child-element', 'template');\n    var parentTemplate = ParentElement.template.cloneNode(true);\n    // Or however you want to assemble these.\n    childTemplate.content.insertBefore(parentTemplate.firstChild, parentTemplate);\n\n    class ChildElement extends ParentElement {\n      static get is() { return 'child-element'; }\n      // Note: the more work you do here, the slower your element is to\n      // boot up. You should probably do the template assembling once, in a\n      // static method outside your class (like above).\n      static get template() {\n        return childTemplate;\n      }\n    }\n    customElements.define(ChildElement.is, ChildElement);\n  </script>\n</dom-module>\n```\n\nIf you don't know the parent class, you can also use:\n\n```js\nclass ChildElement extends customElement.get('parent-element') {\n  /* ... */\n}\n```\n\n## Defining a mixin\n\nDocs: [mixins](https://www.polymer-project.org/2.0/docs/devguide/custom-elements#mixins),\n[hybrid elements](https://www.polymer-project.org/2.0/docs/devguide/hybrid-elements).\n\nDefining a class expression mixin to share implementation between different elements:\n\n```html\n<script>\n  MyMixin = function(superClass) {\n    return class extends superClass {\n      // Code that you want common to elements.\n      // If you're going to override a lifecycle method, remember that a) you\n      // might need to call super but b) it might not exist\n      connectedCallback() {\n        if (super.connectedCallback) {\n          super.connectedCallback();\n        }\n        /* ... */\n      }\n    }\n  }\n</script>\n```\n\nUsing the mixin in an element definition:\n\n```html\n<dom-module id=\"element-name\">\n  <template><!-- ... --></template>\n  <script>\n    // This could also be a sequence:\n    //class MyElement extends AnotherMixin(MyMixin(Polymer.Element)) { … }\n    class MyElement extends MyMixin(Polymer.Element) {\n      static get is() { return 'element-name' }\n      /* ... */\n    }\n    customElements.define(MyElement.is, MyElement);\n  </script>\n</dom-module>\n```\n\nUsing hybrid behaviors (defined in the 1.x syntax) as mixins:\n\n```html\n<dom-module id=\"element-name\">\n  <template><!-- ... --></template>\n  <script>\n    class MyElement extends Polymer.mixinBehaviors([MyBehavior, MyBehavior2], Polymer.Element) {\n     static get is() { return 'element-name' }\n     /* ... */\n    }\n    customElements.define('element-name', MyElement);\n  </script>\n</dom-module>\n```\n\n## Lifecycle methods\n\nDocs: [lifecycle callbacks](https://www.polymer-project.org/2.0/docs/devguide/custom-elements#element-lifecycle),\n[ready](https://www.polymer-project.org/2.0/docs/devguide/custom-elements#one-time-initialization).\n\n```js\nclass MyElement extends Polymer.Element {\n constructor() { super(); /* ... */}\n ready() { super.ready(); /* ... */}\n connectedCallback() { super.connectedCallback(); /* ... */}\n disconnectedCallback() { super.disconnectedCallback(); /* ... */}\n attributeChangedCallback() { super.attributeChangedCallback(); /* ... */}\n}\n```\n\n## Data binding\nDocs: [data binding](https://www.polymer-project.org/2.0/docs/devguide/data-binding),\n[attribute binding](https://www.polymer-project.org/2.0/docs/devguide/data-binding#attribute-binding),\n[binding to array items](https://www.polymer-project.org/2.0/docs/devguide/data-binding#bind-array-item),\n[computed bindings](https://www.polymer-project.org/2.0/docs/devguide/data-binding#annotated-computed).\n\nDon't forget: Polymer [camel-cases](https://www.polymer-project.org/2.0/docs/devguide/properties#property-name-mapping) properties, so if in JavaScript you use `myProperty`,\nin HTML you would use `my-property`.\n\n**One way** binding: when `myProperty` changes, `theirProperty` gets updated:\n\n```html\n<some-element their-property=\"[[myProperty]]\"></some-element>\n```\n\n**Two way** binding: when `myProperty` changes, `theirProperty` gets updated,\nand vice versa:\n\n```html\n<some-element their-property=\"{{myProperty}}\"></some-element>\n```\n\n**Attribute binding**: when `myProperty` is `true`, the element is hidden; when it's\n`false`, the element is visible. The difference between attribute and property\nbinding is that property binding is equivalent to `someElement.someProp = value`,\nwhereas attribute binding is equivalent to: `someElement.setAttribute(someProp, value)`\n\n```html\n<some-element hidden$=\"[[myProperty]]\"></some-element>\n```\n\n**Computed binding**: binding to the `class` attribute will recompile styles when\n`myProperty` changes:\n\n```html\n<some-element class$=\"[[_computeSomething(myProperty)]]\"></some-element>\n<script>\n_computeSomething: function(prop) {\n  return prop ? 'a-class-name' : 'another-class-name';\n}\n</script>\n```\n\n## Observers\n\nDocs: [observers](https://www.polymer-project.org/2.0/docs/devguide/observers),\n[multi-property observers](https://www.polymer-project.org/2.0/docs/devguide/observers#multi-property-observers),\n[observing array mutations](https://www.polymer-project.org/2.0/docs/devguide/observers#array-observation),\n[adding observers dynamically](https://www.polymer-project.org/2.0/docs/devguide/observers#dynamic-observers).\n\nAdding an `observer` in the `properties` block lets you observe changes in the\nvalue of a property:\n\n```js\nstatic get properties() {\n  return {\n    myProperty: {\n      observer: '_myPropertyChanged'\n    }\n  }\n}\n\n// The second argument is optional, and gives you the\n// previous value of the property, before the update:\n_myPropertyChanged(value, /*oldValue */) { /* ... */ }\n```\n\nIn the `observers` block:\n\n```js\nstatic get observers() {\n  return [\n    '_doSomething(myProperty)',\n    '_multiPropertyObserver(myProperty, anotherProperty)',\n    '_observerForASubProperty(user.name)',\n    // Below, items can be an array or an object:'\n    '_observerForABunchOfSubPaths(items.*)'\n  ]\n}\n```\n\nAdding an observer dynamically for a property `otherProperty`:\n```js\n// Define a method\n_otherPropertyChanged(value) { /* ... */ }\n// Call it when `otherPropety` changes\nthis._createPropertyObserver('otherProperty', '_otherPropertyChanged', true);\n```\n\n## Listeners\nIn Polymer 2.0, we recommend that rather than using the `listeners` block,\nyou #useThePlatform and define event listeners yourself:\n\n```js\nready() {\n  super.ready();\n  window.addEventListener('some-event', () => this.someFunction());\n}\n```\n\nThere is a [PR](https://github.com/Polymer/polymer/pull/4632) out to add a\ndeclarative listener block as a mixin. Stay tuned!\n\n## Properties block\n\nDocs: [declared properties](https://www.polymer-project.org/2.0/docs/devguide/properties),\n[object/array properties](https://www.polymer-project.org/2.0/docs/devguide/properties#configuring-object-and-array-properties),\n[read-only properties](https://www.polymer-project.org/2.0/docs/devguide/properties#read-only),\n[computed properties](https://www.polymer-project.org/2.0/docs/devguide/observers#computed-properties),\n[adding computed properties dynamically](https://www.polymer-project.org/2.0/docs/devguide/observers#add-a-computed-property-dynamically).\n\nThere are all the possible things you can use in the `properties`\nblock. Don't just use all of them because you can; some (like `reflectToAttribute`\n  and `notify`) can have performance implications.\n\n```js\nstatic get properties() {\n  return {\n    basic: {\n      type: Boolean | Number | String | Array | Object,\n\n      // Default value of the property can be one of the types above, eg:\n      value: true,\n\n      // For an Array or Object, you must return it from a function\n      // (otherwise the array will be defined on the prototype\n      // and not the instance):\n      value: function() { return ['cheese', 'pepperoni', 'more-cheese'] },\n\n      reflectToAttribute: true | false,\n      readOnly: true | false,\n      notify: true | false\n    },\n\n    // Computed properties are essentially read-only, and can only be\n    // updated when their dependencies change.\n    basicComputedProperty: {\n      computed: '_someFunction(myProperty, anotherProperty)'\n    }\n  }\n}\n```\n\nAdding a computed property dynamically:\n```js\nthis._createComputedProperty('newProperty', '_computeNewProperty(prop1,prop2)', true);\n```\n\n## Observing added and removed children\n\nDocs: [Shadow DOM distribution](https://www.polymer-project.org/2.0/docs/devguide/shadow-dom#shadow-dom-and-composition),\n[observe nodes](https://www.polymer-project.org/2.0/docs/upgrade#polymer-dom-apis).\n\nIf you have a content node for distribution:\n\n```html\n<template>\n  <slot></slot>\n</template>\n```\nAnd you want to be notified when nodes have been added/removed:\n\n```html\n<!-- You need to import the observer -->\n<link rel=\"import\" href=\"/bower_components/polymer/lib/utils/flattened-nodes-observer.html\">\n\n<script>\nclass MyElement extends Polymer.Element {\n  /* ... */\n  connectedCallback: function() {\n    super.connectedCallback();\n    this._observer = new Polymer.FlattenedNodesObserver(function(info) {\n    // info is {addedNodes: [...], removedNodes: [...]}\n    });\n  }\n  disconnectedCallback: function() {\n    super.disconnectedCallback();\n    this._observer.disconnect();\n  }\n}\n</script>\n```\n\n## Style modules\nDocs: [shared style modules](https://www.polymer-project.org/2.0/docs/devguide/style-shadow-dom#style-modules).\n\nDefining styles that will be shared across different elements, in a file called\n`my-shared-styles.html` (for example):\n\n```html\n<dom-module id=\"my-shared-styles\">\n  <template>\n    <style>\n      .red { color: red; }\n      /* Custom property defined in the global scope */\n      html {\n        --the-best-red: #e91e63;\n      }\n    </style>\n  </template>\n</dom-module>\n```\n\nInclude the shared style in a custom element:\n\n```html\n<link rel=\"import\" href=\"my-shared-styles.html\">\n<dom-module id=\"element-name\">\n  <template>\n    <style include=\"my-shared-styles\">\n      /* Other styles in here */\n    </style>\n  </template>\n  <script>\n    class MyElement extends Polymer.Element {\n      /* ... */\n    }\n  </script>\n</dom-module>\n```\n\nInclude the shared style in the main document:\n\n```html\n<html>\n<head>\n  <!-- Import the custom-style element -->\n  <link rel=\"import\" href=\"components/polymer/lib/elements/custom-style.html\">\n  <link rel=\"import\" href=\"my-shared-styles.html\">\n  <custom-style>\n    <style include=\"my-shared-styles\">\n      /* Other styles in here */\n    </style>\n  </custom-style>\n</head>\n<body>...</body>\n</html>\n```\n\n## Styling with custom properties and mixins\n\nDocs: [styling](https://www.polymer-project.org/2.0/docs/devguide/style-shadow-dom),\n[CSS properties](https://www.polymer-project.org/2.0/docs/devguide/custom-css-properties),\n[CSS mixins](https://www.polymer-project.org/2.0/docs/devguide/custom-css-properties#use-custom-css-mixins),\n[shim limitations](https://www.polymer-project.org/2.0/docs/devguide/custom-css-properties#custom-properties-shim-limitations)\n\nNote that the examples below depend on browser support for custom properties and mixins.\n\nDefining a custom property:\n\n```css\nhtml /* or :host etc. */{\n  --my-custom-radius: 5px;\n}\n```\n\nUsing a custom property:\n\n```css\n.my-image {\n  border-radius: var(--my-custom-radius);\n}\n```\n\nUsing a custom property with a fallback:\n\n```css\n.my-image {\n  border-radius: var(--my-custom-radius, 3px);\n}\n```\n\nUsing a custom property with a custom property fallback:\n\n```css\n.my-image {\n  border-radius: var(--my-custom-radius, var(--my-fallback));\n}\n```\n\nIf you want to use mixins, you need to include the CSS mixins shim.\nFor how to use the shim and its limitations, check the docs linked at the\nbeginning of the section.\n```html\n<link rel=\"import\" href=\"/bower_components/shadycss/apply-shim.html\">\n```\n\nDefining a mixin:\n\n```css\nsome-custom-element {\n  --my-custom-mixin: {\n    border-radius: 5px;\n  };\n}\n```\n\nUsing a mixin:\n\n```css\n.my-image {\n  @apply --my-custom-mixin;\n}\n```\n\n## Binding helper elements\n\nDocs: [dom-repeat](https://www.polymer-project.org/2.0/docs/devguide/templates#dom-repeat),\n[dom-bind](https://www.polymer-project.org/2.0/docs/devguide/templates#dom-bind),\n[dom-if](https://www.polymer-project.org/2.0/docs/devguide/templates#dom-if)\n\nThere are two ways to use the helper elements:\n- inside a Polymer element/Polymer managed template: just use the `<template is=...>`\nsyntax, without the wrapper, for example:\n\n```html\n<template is=\"dom-repeat\">\n  ...\n</template>\n```\n- outside of a Polymer managed template: use the `<dom-...>` wrapper element\naround a `<template>`, for example:\n\n```html\n<dom-repeat>\n  <template>\n    ...\n  </template>\n</dom-repeat>\n```\n\n\n`dom-repeat` stamps and binds a template for each item in an array:\n\n```html\n<link rel=\"import\" href=\"components/polymer/lib/elements/dom-repeat.html\">\n<dom-repeat items=\"[[employees]]\">\n  <template>\n    <div>First name: <span>[[item.first]]</span></div>\n    <div>Last name: <span>[[item.last]]</span></div>\n  </template>\n</dom-repeat>\n```\n\n`dom-bind` stamps itself into the main document and adds a binding scope:\n\n```html\n<link rel=\"import\" href=\"components/polymer/lib/elements/dom-bind.html\">\n<html>\n<body>\n  <dom-bind>\n    <template>\n      <paper-input value=\"{{myText}}\"></paper-input>\n      <span>You typed: [[myText]]</span>\n    </template>\n  </dom-bind>\n</body>\n<html>\n```\n\n`dom-if` stamps itself conditionally based on a property's value:\n\n```html\n<link rel=\"import\" href=\"components/polymer/lib/elements/dom-if.html\">\n<dom-if if=\"[[myProperty]]\">\n  <template>\n    <span>This content will appear when myProperty is truthy.</span>\n  </template>\n</dom-if>  \n```\n\n> 原文出处：[Polymer 2.x Cheat Sheet](https://meowni.ca/posts/polymer-2-cheatsheet/).","slug":"Polymer 2.x Cheat Sheet","published":1,"updated":"2017-06-25T06:33:37.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8dw0nfn0005qnjxfqx22bsy","content":"<p>This is a cheat sheet for the <a href=\"https://www.polymer-project.org/\" target=\"_blank\" rel=\"external\">Polymer 2.x</a> library.</p>\n<ul>\n<li>Defining an element</li>\n<li>Extending an element</li>\n<li>Defining a mixin</li>\n<li>Lifecycle methods</li>\n<li>Data binding</li>\n<li>Observers</li>\n<li>Listeners</li>\n<li>Properties block</li>\n<li>Observing added and removed children</li>\n<li>Style modules</li>\n<li>Styling with custom properties and - - mixins</li>\n<li>Binding helper elements</li>\n</ul>\n<h2 id=\"Defining-an-element\"><a href=\"#Defining-an-element\" class=\"headerlink\" title=\"Defining an element\"></a>Defining an element</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/upgrade\" target=\"_blank\" rel=\"external\">1.x -&gt; 2.x upgrade guide</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/registering-elements\" target=\"_blank\" rel=\"external\">registering an element</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/style-shadow-dom#style-modules\" target=\"_blank\" rel=\"external\">shared style modules</a>.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"bower_components/polymer/polymer-element.html\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-module</span> <span class=\"attr\">id</span>=<span class=\"string\">\"element-name\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- Use one of these style declarations, but not both --&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- Use this if you don’t want to include a shared style --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- Use this if you want to include a shared style --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">include</span>=<span class=\"string\">\"some-style-module-name\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">    class MyElement extends Polymer.Element &#123;</div><div class=\"line\">      static get is() &#123; return 'element-name'; &#125;</div><div class=\"line\">      // All of these are optional. Only keep the ones you need.</div><div class=\"line\">      static get properties() &#123; ... &#125;</div><div class=\"line\">      static get observers() &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Associate the new class with an element name</div><div class=\"line\">    customElements.define(MyElement.is, MyElement);</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-module</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>To get the class definition for a particular custom tag, you can use<br><code>customElements.get(&#39;element-name&#39;)</code>.</p>\n<h2 id=\"Extending-an-element\"><a href=\"#Extending-an-element\" class=\"headerlink\" title=\"Extending an element\"></a>Extending an element</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-elements#extending-other-elements\" target=\"_blank\" rel=\"external\">extending elements</a>, <a href=\"https://www.polymer-project.org/2.0/docs/devguide/dom-template#inherited-templates\" target=\"_blank\" rel=\"external\">inherited templates</a>.</p>\n<p>Instead of <code>Polymer.Element</code>, a custom element can extend a different element):<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParentElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">Polymer</span>.<span class=\"title\">Element</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">ParentElement</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>To change or add to the parent’s template, override the <code>template</code> getter:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-module</span> <span class=\"attr\">id</span>=<span class=\"string\">\"child-element\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> /* ... */ </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>bonus!<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">    <span class=\"keyword\">var</span> childTemplate;</div><div class=\"line\">    <span class=\"keyword\">var</span> childTemplate = Polymer.DomModule.import(<span class=\"string\">'child-element'</span>, <span class=\"string\">'template'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> parentTemplate = ParentElement.template.cloneNode(<span class=\"literal\">true</span>);</div><div class=\"line\">    <span class=\"comment\">// Or however you want to assemble these.</span></div><div class=\"line\">    childTemplate.content.insertBefore(parentTemplate.firstChild, parentTemplate);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">ParentElement</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">static</span> get is() &#123; <span class=\"keyword\">return</span> <span class=\"string\">'child-element'</span>; &#125;</div><div class=\"line\">      <span class=\"comment\">// Note: the more work you do here, the slower your element is to</span></div><div class=\"line\">      <span class=\"comment\">// boot up. You should probably do the template assembling once, in a</span></div><div class=\"line\">      <span class=\"comment\">// static method outside your class (like above).</span></div><div class=\"line\">      <span class=\"keyword\">static</span> get template() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> childTemplate;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    customElements.define(ChildElement.is, ChildElement);</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-module</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>If you don’t know the parent class, you can also use:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">customElement</span>.<span class=\"title\">get</span>('<span class=\"title\">parent</span>-<span class=\"title\">element</span>') </span>&#123;</div><div class=\"line\">  <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Defining-a-mixin\"><a href=\"#Defining-a-mixin\" class=\"headerlink\" title=\"Defining a mixin\"></a>Defining a mixin</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-elements#mixins\" target=\"_blank\" rel=\"external\">mixins</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/hybrid-elements\" target=\"_blank\" rel=\"external\">hybrid elements</a>.</p>\n<p>Defining a class expression mixin to share implementation between different elements:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">  MyMixin = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">superClass</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">superClass</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// Code that you want common to elements.</span></div><div class=\"line\">      <span class=\"comment\">// If you're going to override a lifecycle method, remember that a) you</span></div><div class=\"line\">      <span class=\"comment\">// might need to call super but b) it might not exist</span></div><div class=\"line\">      connectedCallback() &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">super</span>.connectedCallback) &#123;</div><div class=\"line\">          <span class=\"keyword\">super</span>.connectedCallback();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">/* ... */</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Using the mixin in an element definition:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-module</span> <span class=\"attr\">id</span>=<span class=\"string\">\"element-name\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span><span class=\"comment\">&lt;!-- ... --&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">    <span class=\"comment\">// This could also be a sequence:</span></div><div class=\"line\">    <span class=\"comment\">//class MyElement extends AnotherMixin(MyMixin(Polymer.Element)) &#123; … &#125;</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyMixin</span>(<span class=\"title\">Polymer</span>.<span class=\"title\">Element</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">static</span> get is() &#123; <span class=\"keyword\">return</span> <span class=\"string\">'element-name'</span> &#125;</div><div class=\"line\">      <span class=\"comment\">/* ... */</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    customElements.define(MyElement.is, MyElement);</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-module</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Using hybrid behaviors (defined in the 1.x syntax) as mixins:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-module</span> <span class=\"attr\">id</span>=<span class=\"string\">\"element-name\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span><span class=\"comment\">&lt;!-- ... --&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">    class MyElement extends Polymer.mixinBehaviors([MyBehavior, MyBehavior2], Polymer.Element) &#123;</div><div class=\"line\">     static get is() &#123; return 'element-name' &#125;</div><div class=\"line\">     /* ... */</div><div class=\"line\">    &#125;</div><div class=\"line\">    customElements.define('element-name', MyElement);</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-module</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"Lifecycle-methods\"><a href=\"#Lifecycle-methods\" class=\"headerlink\" title=\"Lifecycle methods\"></a>Lifecycle methods</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-elements#element-lifecycle\" target=\"_blank\" rel=\"external\">lifecycle callbacks</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-elements#one-time-initialization\" target=\"_blank\" rel=\"external\">ready</a>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">Polymer</span>.<span class=\"title\">Element</span> </span>&#123;</div><div class=\"line\"> <span class=\"keyword\">constructor</span>() &#123; <span class=\"keyword\">super</span>(); <span class=\"comment\">/* ... */</span>&#125;</div><div class=\"line\"> ready() &#123; <span class=\"keyword\">super</span>.ready(); <span class=\"comment\">/* ... */</span>&#125;</div><div class=\"line\"> connectedCallback() &#123; <span class=\"keyword\">super</span>.connectedCallback(); <span class=\"comment\">/* ... */</span>&#125;</div><div class=\"line\"> disconnectedCallback() &#123; <span class=\"keyword\">super</span>.disconnectedCallback(); <span class=\"comment\">/* ... */</span>&#125;</div><div class=\"line\"> attributeChangedCallback() &#123; <span class=\"keyword\">super</span>.attributeChangedCallback(); <span class=\"comment\">/* ... */</span>&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Data-binding\"><a href=\"#Data-binding\" class=\"headerlink\" title=\"Data binding\"></a>Data binding</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/data-binding\" target=\"_blank\" rel=\"external\">data binding</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/data-binding#attribute-binding\" target=\"_blank\" rel=\"external\">attribute binding</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/data-binding#bind-array-item\" target=\"_blank\" rel=\"external\">binding to array items</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/data-binding#annotated-computed\" target=\"_blank\" rel=\"external\">computed bindings</a>.</p>\n<p>Don’t forget: Polymer <a href=\"https://www.polymer-project.org/2.0/docs/devguide/properties#property-name-mapping\" target=\"_blank\" rel=\"external\">camel-cases</a> properties, so if in JavaScript you use <code>myProperty</code>,<br>in HTML you would use <code>my-property</code>.</p>\n<p><strong>One way</strong> binding: when <code>myProperty</code> changes, <code>theirProperty</code> gets updated:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">some-element</span> <span class=\"attr\">their-property</span>=<span class=\"string\">\"[[myProperty]]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">some-element</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>Two way</strong> binding: when <code>myProperty</code> changes, <code>theirProperty</code> gets updated,<br>and vice versa:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">some-element</span> <span class=\"attr\">their-property</span>=<span class=\"string\">\"&#123;&#123;myProperty&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">some-element</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>Attribute binding</strong>: when <code>myProperty</code> is <code>true</code>, the element is hidden; when it’s<br><code>false</code>, the element is visible. The difference between attribute and property<br>binding is that property binding is equivalent to <code>someElement.someProp = value</code>,<br>whereas attribute binding is equivalent to: <code>someElement.setAttribute(someProp, value)</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">some-element</span> <span class=\"attr\">hidden</span>$=<span class=\"string\">\"[[myProperty]]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">some-element</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>Computed binding</strong>: binding to the <code>class</code> attribute will recompile styles when<br><code>myProperty</code> changes:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">some-element</span> <span class=\"attr\">class</span>$=<span class=\"string\">\"[[_computeSomething(myProperty)]]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">some-element</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">_computeSomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prop</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> prop ? <span class=\"string\">'a-class-name'</span> : <span class=\"string\">'another-class-name'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"Observers\"><a href=\"#Observers\" class=\"headerlink\" title=\"Observers\"></a>Observers</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/observers\" target=\"_blank\" rel=\"external\">observers</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/observers#multi-property-observers\" target=\"_blank\" rel=\"external\">multi-property observers</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/observers#array-observation\" target=\"_blank\" rel=\"external\">observing array mutations</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/observers#dynamic-observers\" target=\"_blank\" rel=\"external\">adding observers dynamically</a>.</p>\n<p>Adding an <code>observer</code> in the <code>properties</code> block lets you observe changes in the<br>value of a property:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> get properties() &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">myProperty</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">observer</span>: <span class=\"string\">'_myPropertyChanged'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// The second argument is optional, and gives you the</span></div><div class=\"line\"><span class=\"comment\">// previous value of the property, before the update:</span></div><div class=\"line\">_myPropertyChanged(value, <span class=\"comment\">/*oldValue */</span>) &#123; <span class=\"comment\">/* ... */</span> &#125;</div></pre></td></tr></table></figure>\n<p>In the <code>observers</code> block:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> get observers() &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [</div><div class=\"line\">    <span class=\"string\">'_doSomething(myProperty)'</span>,</div><div class=\"line\">    <span class=\"string\">'_multiPropertyObserver(myProperty, anotherProperty)'</span>,</div><div class=\"line\">    <span class=\"string\">'_observerForASubProperty(user.name)'</span>,</div><div class=\"line\">    <span class=\"comment\">// Below, items can be an array or an object:'</span></div><div class=\"line\">    <span class=\"string\">'_observerForABunchOfSubPaths(items.*)'</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Adding an observer dynamically for a property <code>otherProperty</code>:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Define a method</span></div><div class=\"line\">_otherPropertyChanged(value) &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\"><span class=\"comment\">// Call it when `otherPropety` changes</span></div><div class=\"line\"><span class=\"keyword\">this</span>._createPropertyObserver(<span class=\"string\">'otherProperty'</span>, <span class=\"string\">'_otherPropertyChanged'</span>, <span class=\"literal\">true</span>);</div></pre></td></tr></table></figure></p>\n<h2 id=\"Listeners\"><a href=\"#Listeners\" class=\"headerlink\" title=\"Listeners\"></a>Listeners</h2><p>In Polymer 2.0, we recommend that rather than using the <code>listeners</code> block,<br>you #useThePlatform and define event listeners yourself:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ready() &#123;</div><div class=\"line\">  <span class=\"keyword\">super</span>.ready();</div><div class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'some-event'</span>, () =&gt; <span class=\"keyword\">this</span>.someFunction());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>There is a <a href=\"https://github.com/Polymer/polymer/pull/4632\" target=\"_blank\" rel=\"external\">PR</a> out to add a<br>declarative listener block as a mixin. Stay tuned!</p>\n<h2 id=\"Properties-block\"><a href=\"#Properties-block\" class=\"headerlink\" title=\"Properties block\"></a>Properties block</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/properties\" target=\"_blank\" rel=\"external\">declared properties</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/properties#configuring-object-and-array-properties\" target=\"_blank\" rel=\"external\">object/array properties</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/properties#read-only\" target=\"_blank\" rel=\"external\">read-only properties</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/observers#computed-properties\" target=\"_blank\" rel=\"external\">computed properties</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/observers#add-a-computed-property-dynamically\" target=\"_blank\" rel=\"external\">adding computed properties dynamically</a>.</p>\n<p>There are all the possible things you can use in the <code>properties</code><br>block. Don’t just use all of them because you can; some (like <code>reflectToAttribute</code><br>  and <code>notify</code>) can have performance implications.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> get properties() &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">basic</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Boolean</span> | <span class=\"built_in\">Number</span> | <span class=\"built_in\">String</span> | <span class=\"built_in\">Array</span> | <span class=\"built_in\">Object</span>,</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// Default value of the property can be one of the types above, eg:</span></div><div class=\"line\">      value: <span class=\"literal\">true</span>,</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// For an Array or Object, you must return it from a function</span></div><div class=\"line\">      <span class=\"comment\">// (otherwise the array will be defined on the prototype</span></div><div class=\"line\">      <span class=\"comment\">// and not the instance):</span></div><div class=\"line\">      value: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> [<span class=\"string\">'cheese'</span>, <span class=\"string\">'pepperoni'</span>, <span class=\"string\">'more-cheese'</span>] &#125;,</div><div class=\"line\"></div><div class=\"line\">      <span class=\"attr\">reflectToAttribute</span>: <span class=\"literal\">true</span> | <span class=\"literal\">false</span>,</div><div class=\"line\">      <span class=\"attr\">readOnly</span>: <span class=\"literal\">true</span> | <span class=\"literal\">false</span>,</div><div class=\"line\">      <span class=\"attr\">notify</span>: <span class=\"literal\">true</span> | <span class=\"literal\">false</span></div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Computed properties are essentially read-only, and can only be</span></div><div class=\"line\">    <span class=\"comment\">// updated when their dependencies change.</span></div><div class=\"line\">    basicComputedProperty: &#123;</div><div class=\"line\">      <span class=\"attr\">computed</span>: <span class=\"string\">'_someFunction(myProperty, anotherProperty)'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Adding a computed property dynamically:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>._createComputedProperty(<span class=\"string\">'newProperty'</span>, <span class=\"string\">'_computeNewProperty(prop1,prop2)'</span>, <span class=\"literal\">true</span>);</div></pre></td></tr></table></figure></p>\n<h2 id=\"Observing-added-and-removed-children\"><a href=\"#Observing-added-and-removed-children\" class=\"headerlink\" title=\"Observing added and removed children\"></a>Observing added and removed children</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/shadow-dom#shadow-dom-and-composition\" target=\"_blank\" rel=\"external\">Shadow DOM distribution</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/upgrade#polymer-dom-apis\" target=\"_blank\" rel=\"external\">observe nodes</a>.</p>\n<p>If you have a content node for distribution:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>And you want to be notified when nodes have been added/removed:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- You need to import the observer --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/bower_components/polymer/lib/utils/flattened-nodes-observer.html\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">Polymer</span>.<span class=\"title\">Element</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">/* ... */</span></div><div class=\"line\">  connectedCallback: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.connectedCallback();</div><div class=\"line\">    <span class=\"keyword\">this</span>._observer = <span class=\"keyword\">new</span> Polymer.FlattenedNodesObserver(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">info</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// info is &#123;addedNodes: [...], removedNodes: [...]&#125;</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  disconnectedCallback: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.disconnectedCallback();</div><div class=\"line\">    <span class=\"keyword\">this</span>._observer.disconnect();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"Style-modules\"><a href=\"#Style-modules\" class=\"headerlink\" title=\"Style modules\"></a>Style modules</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/style-shadow-dom#style-modules\" target=\"_blank\" rel=\"external\">shared style modules</a>.</p>\n<p>Defining styles that will be shared across different elements, in a file called<br><code>my-shared-styles.html</code> (for example):</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-module</span> <span class=\"attr\">id</span>=<span class=\"string\">\"my-shared-styles\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">      .red &#123; color: red; &#125;</div><div class=\"line\">      /* Custom property defined in the global scope */</div><div class=\"line\">      html &#123;</div><div class=\"line\">        --the-best-red: #e91e63;</div><div class=\"line\">      &#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-module</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Include the shared style in a custom element:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"my-shared-styles.html\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-module</span> <span class=\"attr\">id</span>=<span class=\"string\">\"element-name\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">include</span>=<span class=\"string\">\"my-shared-styles\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">      /* Other styles in here */</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">Polymer</span>.<span class=\"title\">Element</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">/* ... */</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-module</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Include the shared style in the main document:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- Import the custom-style element --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"components/polymer/lib/elements/custom-style.html\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"my-shared-styles.html\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">custom-style</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">include</span>=<span class=\"string\">\"my-shared-styles\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">      /* Other styles in here */</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">custom-style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"Styling-with-custom-properties-and-mixins\"><a href=\"#Styling-with-custom-properties-and-mixins\" class=\"headerlink\" title=\"Styling with custom properties and mixins\"></a>Styling with custom properties and mixins</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/style-shadow-dom\" target=\"_blank\" rel=\"external\">styling</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-css-properties\" target=\"_blank\" rel=\"external\">CSS properties</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-css-properties#use-custom-css-mixins\" target=\"_blank\" rel=\"external\">CSS mixins</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-css-properties#custom-properties-shim-limitations\" target=\"_blank\" rel=\"external\">shim limitations</a></p>\n<p>Note that the examples below depend on browser support for custom properties and mixins.</p>\n<p>Defining a custom property:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span> <span class=\"comment\">/* or :host etc. */</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">--my-custom-radius</span>: <span class=\"number\">5px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Using a custom property:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.my-image</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"built_in\">var</span>(--my-custom-radius);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Using a custom property with a fallback:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.my-image</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"built_in\">var</span>(--my-custom-radius, 3px);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Using a custom property with a custom property fallback:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.my-image</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"built_in\">var</span>(--my-custom-radius, var(--my-fallback));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>If you want to use mixins, you need to include the CSS mixins shim.<br>For how to use the shim and its limitations, check the docs linked at the<br>beginning of the section.<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/bower_components/shadycss/apply-shim.html\"</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>Defining a mixin:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">some-custom-element</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">--my-custom-mixin</span>: &#123;</div><div class=\"line\">    border-radius: <span class=\"number\">5px</span>;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Using a mixin:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.my-image &#123;</div><div class=\"line\">  @apply --my-custom-mixin;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Binding-helper-elements\"><a href=\"#Binding-helper-elements\" class=\"headerlink\" title=\"Binding helper elements\"></a>Binding helper elements</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/templates#dom-repeat\" target=\"_blank\" rel=\"external\">dom-repeat</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/templates#dom-bind\" target=\"_blank\" rel=\"external\">dom-bind</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/templates#dom-if\" target=\"_blank\" rel=\"external\">dom-if</a></p>\n<p>There are two ways to use the helper elements:</p>\n<ul>\n<li>inside a Polymer element/Polymer managed template: just use the <code>&lt;template is=...&gt;</code><br>syntax, without the wrapper, for example:</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">\"dom-repeat\"</span>&gt;</span></div><div class=\"line\">  ...</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li>outside of a Polymer managed template: use the <code>&lt;dom-...&gt;</code> wrapper element<br>around a <code>&lt;template&gt;</code>, for example:</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-repeat</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    ...</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-repeat</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>dom-repeat</code> stamps and binds a template for each item in an array:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"components/polymer/lib/elements/dom-repeat.html\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-repeat</span> <span class=\"attr\">items</span>=<span class=\"string\">\"[[employees]]\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>First name: <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>[[item.first]]<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Last name: <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>[[item.last]]<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-repeat</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>dom-bind</code> stamps itself into the main document and adds a binding scope:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"components/polymer/lib/elements/dom-bind.html\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dom-bind</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">paper-input</span> <span class=\"attr\">value</span>=<span class=\"string\">\"&#123;&#123;myText&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">paper-input</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>You typed: [[myText]]<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dom-bind</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>dom-if</code> stamps itself conditionally based on a property’s value:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"components/polymer/lib/elements/dom-if.html\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-if</span> <span class=\"attr\">if</span>=<span class=\"string\">\"[[myProperty]]\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>This content will appear when myProperty is truthy.<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-if</span>&gt;</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>原文出处：<a href=\"https://meowni.ca/posts/polymer-2-cheatsheet/\" target=\"_blank\" rel=\"external\">Polymer 2.x Cheat Sheet</a>.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>This is a cheat sheet for the <a href=\"https://www.polymer-project.org/\" target=\"_blank\" rel=\"external\">Polymer 2.x</a> library.</p>\n<ul>\n<li>Defining an element</li>\n<li>Extending an element</li>\n<li>Defining a mixin</li>\n<li>Lifecycle methods</li>\n<li>Data binding</li>\n<li>Observers</li>\n<li>Listeners</li>\n<li>Properties block</li>\n<li>Observing added and removed children</li>\n<li>Style modules</li>\n<li>Styling with custom properties and - - mixins</li>\n<li>Binding helper elements</li>\n</ul>\n<h2 id=\"Defining-an-element\"><a href=\"#Defining-an-element\" class=\"headerlink\" title=\"Defining an element\"></a>Defining an element</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/upgrade\" target=\"_blank\" rel=\"external\">1.x -&gt; 2.x upgrade guide</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/registering-elements\" target=\"_blank\" rel=\"external\">registering an element</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/style-shadow-dom#style-modules\" target=\"_blank\" rel=\"external\">shared style modules</a>.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"bower_components/polymer/polymer-element.html\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-module</span> <span class=\"attr\">id</span>=<span class=\"string\">\"element-name\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- Use one of these style declarations, but not both --&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- Use this if you don’t want to include a shared style --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">    <span class=\"comment\">&lt;!-- Use this if you want to include a shared style --&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">include</span>=<span class=\"string\">\"some-style-module-name\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">    class MyElement extends Polymer.Element &#123;</div><div class=\"line\">      static get is() &#123; return 'element-name'; &#125;</div><div class=\"line\">      // All of these are optional. Only keep the ones you need.</div><div class=\"line\">      static get properties() &#123; ... &#125;</div><div class=\"line\">      static get observers() &#123; ... &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // Associate the new class with an element name</div><div class=\"line\">    customElements.define(MyElement.is, MyElement);</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-module</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>To get the class definition for a particular custom tag, you can use<br><code>customElements.get(&#39;element-name&#39;)</code>.</p>\n<h2 id=\"Extending-an-element\"><a href=\"#Extending-an-element\" class=\"headerlink\" title=\"Extending an element\"></a>Extending an element</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-elements#extending-other-elements\" target=\"_blank\" rel=\"external\">extending elements</a>, <a href=\"https://www.polymer-project.org/2.0/docs/devguide/dom-template#inherited-templates\" target=\"_blank\" rel=\"external\">inherited templates</a>.</p>\n<p>Instead of <code>Polymer.Element</code>, a custom element can extend a different element):<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParentElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">Polymer</span>.<span class=\"title\">Element</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">ParentElement</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>To change or add to the parent’s template, override the <code>template</code> getter:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-module</span> <span class=\"attr\">id</span>=<span class=\"string\">\"child-element\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"> /* ... */ </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>bonus!<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">    <span class=\"keyword\">var</span> childTemplate;</div><div class=\"line\">    <span class=\"keyword\">var</span> childTemplate = Polymer.DomModule.import(<span class=\"string\">'child-element'</span>, <span class=\"string\">'template'</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> parentTemplate = ParentElement.template.cloneNode(<span class=\"literal\">true</span>);</div><div class=\"line\">    <span class=\"comment\">// Or however you want to assemble these.</span></div><div class=\"line\">    childTemplate.content.insertBefore(parentTemplate.firstChild, parentTemplate);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">ParentElement</span> </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">static</span> get is() &#123; <span class=\"keyword\">return</span> <span class=\"string\">'child-element'</span>; &#125;</div><div class=\"line\">      <span class=\"comment\">// Note: the more work you do here, the slower your element is to</span></div><div class=\"line\">      <span class=\"comment\">// boot up. You should probably do the template assembling once, in a</span></div><div class=\"line\">      <span class=\"comment\">// static method outside your class (like above).</span></div><div class=\"line\">      <span class=\"keyword\">static</span> get template() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> childTemplate;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    customElements.define(ChildElement.is, ChildElement);</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-module</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>If you don’t know the parent class, you can also use:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChildElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">customElement</span>.<span class=\"title\">get</span>('<span class=\"title\">parent</span>-<span class=\"title\">element</span>') </span>&#123;</div><div class=\"line\">  <span class=\"comment\">/* ... */</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Defining-a-mixin\"><a href=\"#Defining-a-mixin\" class=\"headerlink\" title=\"Defining a mixin\"></a>Defining a mixin</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-elements#mixins\" target=\"_blank\" rel=\"external\">mixins</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/hybrid-elements\" target=\"_blank\" rel=\"external\">hybrid elements</a>.</p>\n<p>Defining a class expression mixin to share implementation between different elements:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">  MyMixin = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">superClass</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">superClass</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">// Code that you want common to elements.</span></div><div class=\"line\">      <span class=\"comment\">// If you're going to override a lifecycle method, remember that a) you</span></div><div class=\"line\">      <span class=\"comment\">// might need to call super but b) it might not exist</span></div><div class=\"line\">      connectedCallback() &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">super</span>.connectedCallback) &#123;</div><div class=\"line\">          <span class=\"keyword\">super</span>.connectedCallback();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">/* ... */</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Using the mixin in an element definition:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-module</span> <span class=\"attr\">id</span>=<span class=\"string\">\"element-name\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span><span class=\"comment\">&lt;!-- ... --&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">    <span class=\"comment\">// This could also be a sequence:</span></div><div class=\"line\">    <span class=\"comment\">//class MyElement extends AnotherMixin(MyMixin(Polymer.Element)) &#123; … &#125;</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyMixin</span>(<span class=\"title\">Polymer</span>.<span class=\"title\">Element</span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">static</span> get is() &#123; <span class=\"keyword\">return</span> <span class=\"string\">'element-name'</span> &#125;</div><div class=\"line\">      <span class=\"comment\">/* ... */</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    customElements.define(MyElement.is, MyElement);</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-module</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Using hybrid behaviors (defined in the 1.x syntax) as mixins:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-module</span> <span class=\"attr\">id</span>=<span class=\"string\">\"element-name\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span><span class=\"comment\">&lt;!-- ... --&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">    class MyElement extends Polymer.mixinBehaviors([MyBehavior, MyBehavior2], Polymer.Element) &#123;</div><div class=\"line\">     static get is() &#123; return 'element-name' &#125;</div><div class=\"line\">     /* ... */</div><div class=\"line\">    &#125;</div><div class=\"line\">    customElements.define('element-name', MyElement);</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-module</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"Lifecycle-methods\"><a href=\"#Lifecycle-methods\" class=\"headerlink\" title=\"Lifecycle methods\"></a>Lifecycle methods</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-elements#element-lifecycle\" target=\"_blank\" rel=\"external\">lifecycle callbacks</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-elements#one-time-initialization\" target=\"_blank\" rel=\"external\">ready</a>.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">Polymer</span>.<span class=\"title\">Element</span> </span>&#123;</div><div class=\"line\"> <span class=\"keyword\">constructor</span>() &#123; <span class=\"keyword\">super</span>(); <span class=\"comment\">/* ... */</span>&#125;</div><div class=\"line\"> ready() &#123; <span class=\"keyword\">super</span>.ready(); <span class=\"comment\">/* ... */</span>&#125;</div><div class=\"line\"> connectedCallback() &#123; <span class=\"keyword\">super</span>.connectedCallback(); <span class=\"comment\">/* ... */</span>&#125;</div><div class=\"line\"> disconnectedCallback() &#123; <span class=\"keyword\">super</span>.disconnectedCallback(); <span class=\"comment\">/* ... */</span>&#125;</div><div class=\"line\"> attributeChangedCallback() &#123; <span class=\"keyword\">super</span>.attributeChangedCallback(); <span class=\"comment\">/* ... */</span>&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Data-binding\"><a href=\"#Data-binding\" class=\"headerlink\" title=\"Data binding\"></a>Data binding</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/data-binding\" target=\"_blank\" rel=\"external\">data binding</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/data-binding#attribute-binding\" target=\"_blank\" rel=\"external\">attribute binding</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/data-binding#bind-array-item\" target=\"_blank\" rel=\"external\">binding to array items</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/data-binding#annotated-computed\" target=\"_blank\" rel=\"external\">computed bindings</a>.</p>\n<p>Don’t forget: Polymer <a href=\"https://www.polymer-project.org/2.0/docs/devguide/properties#property-name-mapping\" target=\"_blank\" rel=\"external\">camel-cases</a> properties, so if in JavaScript you use <code>myProperty</code>,<br>in HTML you would use <code>my-property</code>.</p>\n<p><strong>One way</strong> binding: when <code>myProperty</code> changes, <code>theirProperty</code> gets updated:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">some-element</span> <span class=\"attr\">their-property</span>=<span class=\"string\">\"[[myProperty]]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">some-element</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>Two way</strong> binding: when <code>myProperty</code> changes, <code>theirProperty</code> gets updated,<br>and vice versa:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">some-element</span> <span class=\"attr\">their-property</span>=<span class=\"string\">\"&#123;&#123;myProperty&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">some-element</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>Attribute binding</strong>: when <code>myProperty</code> is <code>true</code>, the element is hidden; when it’s<br><code>false</code>, the element is visible. The difference between attribute and property<br>binding is that property binding is equivalent to <code>someElement.someProp = value</code>,<br>whereas attribute binding is equivalent to: <code>someElement.setAttribute(someProp, value)</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">some-element</span> <span class=\"attr\">hidden</span>$=<span class=\"string\">\"[[myProperty]]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">some-element</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><strong>Computed binding</strong>: binding to the <code>class</code> attribute will recompile styles when<br><code>myProperty</code> changes:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">some-element</span> <span class=\"attr\">class</span>$=<span class=\"string\">\"[[_computeSomething(myProperty)]]\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">some-element</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">_computeSomething: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prop</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> prop ? <span class=\"string\">'a-class-name'</span> : <span class=\"string\">'another-class-name'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"Observers\"><a href=\"#Observers\" class=\"headerlink\" title=\"Observers\"></a>Observers</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/observers\" target=\"_blank\" rel=\"external\">observers</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/observers#multi-property-observers\" target=\"_blank\" rel=\"external\">multi-property observers</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/observers#array-observation\" target=\"_blank\" rel=\"external\">observing array mutations</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/observers#dynamic-observers\" target=\"_blank\" rel=\"external\">adding observers dynamically</a>.</p>\n<p>Adding an <code>observer</code> in the <code>properties</code> block lets you observe changes in the<br>value of a property:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> get properties() &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">myProperty</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">observer</span>: <span class=\"string\">'_myPropertyChanged'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// The second argument is optional, and gives you the</span></div><div class=\"line\"><span class=\"comment\">// previous value of the property, before the update:</span></div><div class=\"line\">_myPropertyChanged(value, <span class=\"comment\">/*oldValue */</span>) &#123; <span class=\"comment\">/* ... */</span> &#125;</div></pre></td></tr></table></figure>\n<p>In the <code>observers</code> block:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> get observers() &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> [</div><div class=\"line\">    <span class=\"string\">'_doSomething(myProperty)'</span>,</div><div class=\"line\">    <span class=\"string\">'_multiPropertyObserver(myProperty, anotherProperty)'</span>,</div><div class=\"line\">    <span class=\"string\">'_observerForASubProperty(user.name)'</span>,</div><div class=\"line\">    <span class=\"comment\">// Below, items can be an array or an object:'</span></div><div class=\"line\">    <span class=\"string\">'_observerForABunchOfSubPaths(items.*)'</span></div><div class=\"line\">  ]</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Adding an observer dynamically for a property <code>otherProperty</code>:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Define a method</span></div><div class=\"line\">_otherPropertyChanged(value) &#123; <span class=\"comment\">/* ... */</span> &#125;</div><div class=\"line\"><span class=\"comment\">// Call it when `otherPropety` changes</span></div><div class=\"line\"><span class=\"keyword\">this</span>._createPropertyObserver(<span class=\"string\">'otherProperty'</span>, <span class=\"string\">'_otherPropertyChanged'</span>, <span class=\"literal\">true</span>);</div></pre></td></tr></table></figure></p>\n<h2 id=\"Listeners\"><a href=\"#Listeners\" class=\"headerlink\" title=\"Listeners\"></a>Listeners</h2><p>In Polymer 2.0, we recommend that rather than using the <code>listeners</code> block,<br>you #useThePlatform and define event listeners yourself:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ready() &#123;</div><div class=\"line\">  <span class=\"keyword\">super</span>.ready();</div><div class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'some-event'</span>, () =&gt; <span class=\"keyword\">this</span>.someFunction());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>There is a <a href=\"https://github.com/Polymer/polymer/pull/4632\" target=\"_blank\" rel=\"external\">PR</a> out to add a<br>declarative listener block as a mixin. Stay tuned!</p>\n<h2 id=\"Properties-block\"><a href=\"#Properties-block\" class=\"headerlink\" title=\"Properties block\"></a>Properties block</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/properties\" target=\"_blank\" rel=\"external\">declared properties</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/properties#configuring-object-and-array-properties\" target=\"_blank\" rel=\"external\">object/array properties</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/properties#read-only\" target=\"_blank\" rel=\"external\">read-only properties</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/observers#computed-properties\" target=\"_blank\" rel=\"external\">computed properties</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/observers#add-a-computed-property-dynamically\" target=\"_blank\" rel=\"external\">adding computed properties dynamically</a>.</p>\n<p>There are all the possible things you can use in the <code>properties</code><br>block. Don’t just use all of them because you can; some (like <code>reflectToAttribute</code><br>  and <code>notify</code>) can have performance implications.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> get properties() &#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    <span class=\"attr\">basic</span>: &#123;</div><div class=\"line\">      <span class=\"attr\">type</span>: <span class=\"built_in\">Boolean</span> | <span class=\"built_in\">Number</span> | <span class=\"built_in\">String</span> | <span class=\"built_in\">Array</span> | <span class=\"built_in\">Object</span>,</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// Default value of the property can be one of the types above, eg:</span></div><div class=\"line\">      value: <span class=\"literal\">true</span>,</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// For an Array or Object, you must return it from a function</span></div><div class=\"line\">      <span class=\"comment\">// (otherwise the array will be defined on the prototype</span></div><div class=\"line\">      <span class=\"comment\">// and not the instance):</span></div><div class=\"line\">      value: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> [<span class=\"string\">'cheese'</span>, <span class=\"string\">'pepperoni'</span>, <span class=\"string\">'more-cheese'</span>] &#125;,</div><div class=\"line\"></div><div class=\"line\">      <span class=\"attr\">reflectToAttribute</span>: <span class=\"literal\">true</span> | <span class=\"literal\">false</span>,</div><div class=\"line\">      <span class=\"attr\">readOnly</span>: <span class=\"literal\">true</span> | <span class=\"literal\">false</span>,</div><div class=\"line\">      <span class=\"attr\">notify</span>: <span class=\"literal\">true</span> | <span class=\"literal\">false</span></div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Computed properties are essentially read-only, and can only be</span></div><div class=\"line\">    <span class=\"comment\">// updated when their dependencies change.</span></div><div class=\"line\">    basicComputedProperty: &#123;</div><div class=\"line\">      <span class=\"attr\">computed</span>: <span class=\"string\">'_someFunction(myProperty, anotherProperty)'</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Adding a computed property dynamically:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>._createComputedProperty(<span class=\"string\">'newProperty'</span>, <span class=\"string\">'_computeNewProperty(prop1,prop2)'</span>, <span class=\"literal\">true</span>);</div></pre></td></tr></table></figure></p>\n<h2 id=\"Observing-added-and-removed-children\"><a href=\"#Observing-added-and-removed-children\" class=\"headerlink\" title=\"Observing added and removed children\"></a>Observing added and removed children</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/shadow-dom#shadow-dom-and-composition\" target=\"_blank\" rel=\"external\">Shadow DOM distribution</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/upgrade#polymer-dom-apis\" target=\"_blank\" rel=\"external\">observe nodes</a>.</p>\n<p>If you have a content node for distribution:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>And you want to be notified when nodes have been added/removed:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">&lt;!-- You need to import the observer --&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/bower_components/polymer/lib/utils/flattened-nodes-observer.html\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">Polymer</span>.<span class=\"title\">Element</span> </span>&#123;</div><div class=\"line\">  <span class=\"comment\">/* ... */</span></div><div class=\"line\">  connectedCallback: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.connectedCallback();</div><div class=\"line\">    <span class=\"keyword\">this</span>._observer = <span class=\"keyword\">new</span> Polymer.FlattenedNodesObserver(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">info</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// info is &#123;addedNodes: [...], removedNodes: [...]&#125;</span></div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">  disconnectedCallback: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">super</span>.disconnectedCallback();</div><div class=\"line\">    <span class=\"keyword\">this</span>._observer.disconnect();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"Style-modules\"><a href=\"#Style-modules\" class=\"headerlink\" title=\"Style modules\"></a>Style modules</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/style-shadow-dom#style-modules\" target=\"_blank\" rel=\"external\">shared style modules</a>.</p>\n<p>Defining styles that will be shared across different elements, in a file called<br><code>my-shared-styles.html</code> (for example):</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-module</span> <span class=\"attr\">id</span>=<span class=\"string\">\"my-shared-styles\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">      .red &#123; color: red; &#125;</div><div class=\"line\">      /* Custom property defined in the global scope */</div><div class=\"line\">      html &#123;</div><div class=\"line\">        --the-best-red: #e91e63;</div><div class=\"line\">      &#125;</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-module</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Include the shared style in a custom element:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"my-shared-styles.html\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-module</span> <span class=\"attr\">id</span>=<span class=\"string\">\"element-name\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">include</span>=<span class=\"string\">\"my-shared-styles\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">      /* Other styles in here */</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">Polymer</span>.<span class=\"title\">Element</span> </span>&#123;</div><div class=\"line\">      <span class=\"comment\">/* ... */</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-module</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>Include the shared style in the main document:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"comment\">&lt;!-- Import the custom-style element --&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"components/polymer/lib/elements/custom-style.html\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"my-shared-styles.html\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">custom-style</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">include</span>=<span class=\"string\">\"my-shared-styles\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\">      /* Other styles in here */</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">custom-style</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<h2 id=\"Styling-with-custom-properties-and-mixins\"><a href=\"#Styling-with-custom-properties-and-mixins\" class=\"headerlink\" title=\"Styling with custom properties and mixins\"></a>Styling with custom properties and mixins</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/style-shadow-dom\" target=\"_blank\" rel=\"external\">styling</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-css-properties\" target=\"_blank\" rel=\"external\">CSS properties</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-css-properties#use-custom-css-mixins\" target=\"_blank\" rel=\"external\">CSS mixins</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/custom-css-properties#custom-properties-shim-limitations\" target=\"_blank\" rel=\"external\">shim limitations</a></p>\n<p>Note that the examples below depend on browser support for custom properties and mixins.</p>\n<p>Defining a custom property:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">html</span> <span class=\"comment\">/* or :host etc. */</span>&#123;</div><div class=\"line\">  <span class=\"attribute\">--my-custom-radius</span>: <span class=\"number\">5px</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Using a custom property:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.my-image</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"built_in\">var</span>(--my-custom-radius);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Using a custom property with a fallback:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.my-image</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"built_in\">var</span>(--my-custom-radius, 3px);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Using a custom property with a custom property fallback:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.my-image</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"built_in\">var</span>(--my-custom-radius, var(--my-fallback));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>If you want to use mixins, you need to include the CSS mixins shim.<br>For how to use the shim and its limitations, check the docs linked at the<br>beginning of the section.<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/bower_components/shadycss/apply-shim.html\"</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>Defining a mixin:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">some-custom-element</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">--my-custom-mixin</span>: &#123;</div><div class=\"line\">    border-radius: <span class=\"number\">5px</span>;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Using a mixin:</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">.my-image &#123;</div><div class=\"line\">  @apply --my-custom-mixin;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Binding-helper-elements\"><a href=\"#Binding-helper-elements\" class=\"headerlink\" title=\"Binding helper elements\"></a>Binding helper elements</h2><p>Docs: <a href=\"https://www.polymer-project.org/2.0/docs/devguide/templates#dom-repeat\" target=\"_blank\" rel=\"external\">dom-repeat</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/templates#dom-bind\" target=\"_blank\" rel=\"external\">dom-bind</a>,<br><a href=\"https://www.polymer-project.org/2.0/docs/devguide/templates#dom-if\" target=\"_blank\" rel=\"external\">dom-if</a></p>\n<p>There are two ways to use the helper elements:</p>\n<ul>\n<li>inside a Polymer element/Polymer managed template: just use the <code>&lt;template is=...&gt;</code><br>syntax, without the wrapper, for example:</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">is</span>=<span class=\"string\">\"dom-repeat\"</span>&gt;</span></div><div class=\"line\">  ...</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div></pre></td></tr></table></figure>\n<ul>\n<li>outside of a Polymer managed template: use the <code>&lt;dom-...&gt;</code> wrapper element<br>around a <code>&lt;template&gt;</code>, for example:</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-repeat</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    ...</div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-repeat</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>dom-repeat</code> stamps and binds a template for each item in an array:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"components/polymer/lib/elements/dom-repeat.html\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-repeat</span> <span class=\"attr\">items</span>=<span class=\"string\">\"[[employees]]\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>First name: <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>[[item.first]]<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Last name: <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>[[item.last]]<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-repeat</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>dom-bind</code> stamps itself into the main document and adds a binding scope:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"components/polymer/lib/elements/dom-bind.html\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dom-bind</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">paper-input</span> <span class=\"attr\">value</span>=<span class=\"string\">\"&#123;&#123;myText&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">paper-input</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>You typed: [[myText]]<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dom-bind</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p><code>dom-if</code> stamps itself conditionally based on a property’s value:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"import\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"components/polymer/lib/elements/dom-if.html\"</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dom-if</span> <span class=\"attr\">if</span>=<span class=\"string\">\"[[myProperty]]\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>This content will appear when myProperty is truthy.<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dom-if</span>&gt;</span></div></pre></td></tr></table></figure>\n<blockquote>\n<p>原文出处：<a href=\"https://meowni.ca/posts/polymer-2-cheatsheet/\" target=\"_blank\" rel=\"external\">Polymer 2.x Cheat Sheet</a>.</p>\n</blockquote>\n"},{"title":"Postgresql安装使用","date":"2016-11-12T06:20:00.000Z","_content":"\n[PostgreSQL新手入门](http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html)\n\n## 1： [安装postgresql](https://www.postgresql.org/download/linux/ubuntu/)\n\nkriry@ubuntu:$ \n\n1- 创建文件 /etc/apt/sources.list.d/pgdg.list, 添加下面一行：\n    deb http://apt.postgresql.org/pub/repos/apt/ xenial-pgdg main\n\n2- 导入 repository signing key, and update the package lists\nwget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | \\\n  sudo apt-key add -\n\n3- 更新数据仓库\n    sudo apt-get update\n\n4- 安装postgresql\n    apt-get install postgresql-9.6\n\n## 2：确定用户\npostgresql安装后，默认只有一个postgres超级用户，所以要新增至少一个用户作为非超级用户普通使用，可以将当前系统的用户或新创建一个用户使用。 如：sudo adduser dbuser   //新建用户\n\nkriry@ubuntu:~$ sudo su - postgres   // 切换到postgres\npostgres@ubuntu:~$ psql                 // 使用psql修改密码\npostgres=# \\password postgres   // 修改密码命令然后设置修改\npostgres=# \\q                    //退出\n\n## 3：服务器配置及初始化（默认当前系统的用户）\nkriry@ubuntu:~$ \n\n配置及数据目录到环境变量：/home/kriry/.bashrc（若是新建用户，则将以下配置添加到新建用户的环境变量中。如：/home/dbuser/.bashrc).若不想每个用户各自配置可以配置在/etc/profile系统环境变量中.\n注意：目录：PGDATA，PGHOME，PATH，LD_LIBRARY_PATH要sudo赋予数据库使用用户权限（如：kriry/dbuser）\nexport PGHOME=/usr/lib/postgresql/9.6\nexport PATH=$PGHOME/bin:$PATH\nexport PGDATA=/usr/local/pgsql/data\nexport LD_LIBRARY_PATH=$PGHOME/lib\n\n初始化数据库数据集簇\ninitdb -D /usr/local/pgsql/data\n\n启动数据库服务器\npostgres -D /usr/local/pgsql/data\n\n## 4：配置数据库用户及数据库\n\nkriry@ubuntu:~$  sudo su - postgres   // 切换到postgres\npostgres@ubuntu:~$ psql\npostgres=# select rolname from pg_roles;     //查看现有用户\npostgres=# SELECT datname FROM pg_database;  //查看现有数据库的集合 \npostgres=# create role dbuser with LOGIN CREATEDB PASSWORD 'password'; //创建系统使用用户同名数据库角色用户并附与权限\npostgres=# CREATE DATABASE dbname OWNER rolename;       //创建数据库\npostgres=# \\q\npostgres@ubuntu:~$ su dbuser    //切换到使用用户\nkriry@ubuntu:~$ systemctl enable postgresql    //开机启动\nkriry@ubuntu:~$ systemctl start postgresql     //启动服务\nkriry@ubuntu:~$ systemctl restart postgresql   //重启\nkriry@ubuntu:~$ systemctl stop postgresql     //停止\nkriry@ubuntu:~$ sudo netstat -natp|grep postgres    //查看端口\n\n登录数据库\npsql -U dbuser -d exampledb -h 127.0.0.1 -p 5432\n\n查看postgresql服务：\n    service --status-all                //查看本机所有服务状态\n    systemctl status                    //查看本机所有服务状态\n    systemctl status postgresql         //查看postgresql服务状态\n\n\n导入SQL ：psql  -U username -W -d dbname -f xx.sql\n","source":"_posts/Postgresql安装使用.md","raw":"---\ntitle: Postgresql安装使用\ndate: 2016-11-12 14:20\ntags:\n - Postgresql\n---\n\n[PostgreSQL新手入门](http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html)\n\n## 1： [安装postgresql](https://www.postgresql.org/download/linux/ubuntu/)\n\nkriry@ubuntu:$ \n\n1- 创建文件 /etc/apt/sources.list.d/pgdg.list, 添加下面一行：\n    deb http://apt.postgresql.org/pub/repos/apt/ xenial-pgdg main\n\n2- 导入 repository signing key, and update the package lists\nwget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | \\\n  sudo apt-key add -\n\n3- 更新数据仓库\n    sudo apt-get update\n\n4- 安装postgresql\n    apt-get install postgresql-9.6\n\n## 2：确定用户\npostgresql安装后，默认只有一个postgres超级用户，所以要新增至少一个用户作为非超级用户普通使用，可以将当前系统的用户或新创建一个用户使用。 如：sudo adduser dbuser   //新建用户\n\nkriry@ubuntu:~$ sudo su - postgres   // 切换到postgres\npostgres@ubuntu:~$ psql                 // 使用psql修改密码\npostgres=# \\password postgres   // 修改密码命令然后设置修改\npostgres=# \\q                    //退出\n\n## 3：服务器配置及初始化（默认当前系统的用户）\nkriry@ubuntu:~$ \n\n配置及数据目录到环境变量：/home/kriry/.bashrc（若是新建用户，则将以下配置添加到新建用户的环境变量中。如：/home/dbuser/.bashrc).若不想每个用户各自配置可以配置在/etc/profile系统环境变量中.\n注意：目录：PGDATA，PGHOME，PATH，LD_LIBRARY_PATH要sudo赋予数据库使用用户权限（如：kriry/dbuser）\nexport PGHOME=/usr/lib/postgresql/9.6\nexport PATH=$PGHOME/bin:$PATH\nexport PGDATA=/usr/local/pgsql/data\nexport LD_LIBRARY_PATH=$PGHOME/lib\n\n初始化数据库数据集簇\ninitdb -D /usr/local/pgsql/data\n\n启动数据库服务器\npostgres -D /usr/local/pgsql/data\n\n## 4：配置数据库用户及数据库\n\nkriry@ubuntu:~$  sudo su - postgres   // 切换到postgres\npostgres@ubuntu:~$ psql\npostgres=# select rolname from pg_roles;     //查看现有用户\npostgres=# SELECT datname FROM pg_database;  //查看现有数据库的集合 \npostgres=# create role dbuser with LOGIN CREATEDB PASSWORD 'password'; //创建系统使用用户同名数据库角色用户并附与权限\npostgres=# CREATE DATABASE dbname OWNER rolename;       //创建数据库\npostgres=# \\q\npostgres@ubuntu:~$ su dbuser    //切换到使用用户\nkriry@ubuntu:~$ systemctl enable postgresql    //开机启动\nkriry@ubuntu:~$ systemctl start postgresql     //启动服务\nkriry@ubuntu:~$ systemctl restart postgresql   //重启\nkriry@ubuntu:~$ systemctl stop postgresql     //停止\nkriry@ubuntu:~$ sudo netstat -natp|grep postgres    //查看端口\n\n登录数据库\npsql -U dbuser -d exampledb -h 127.0.0.1 -p 5432\n\n查看postgresql服务：\n    service --status-all                //查看本机所有服务状态\n    systemctl status                    //查看本机所有服务状态\n    systemctl status postgresql         //查看postgresql服务状态\n\n\n导入SQL ：psql  -U username -W -d dbname -f xx.sql\n","slug":"Postgresql安装使用","published":1,"updated":"2017-08-28T11:19:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8dw0nfq0007qnjx6mw4pfck","content":"<p><a href=\"http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html\" target=\"_blank\" rel=\"external\">PostgreSQL新手入门</a></p>\n<h2 id=\"1：-安装postgresql\"><a href=\"#1：-安装postgresql\" class=\"headerlink\" title=\"1： 安装postgresql\"></a>1： <a href=\"https://www.postgresql.org/download/linux/ubuntu/\" target=\"_blank\" rel=\"external\">安装postgresql</a></h2><p>kriry@ubuntu:$ </p>\n<p>1- 创建文件 /etc/apt/sources.list.d/pgdg.list, 添加下面一行：<br>    deb <a href=\"http://apt.postgresql.org/pub/repos/apt/\" target=\"_blank\" rel=\"external\">http://apt.postgresql.org/pub/repos/apt/</a> xenial-pgdg main</p>\n<p>2- 导入 repository signing key, and update the package lists<br>wget –quiet -O - <a href=\"https://www.postgresql.org/media/keys/ACCC4CF8.asc\" target=\"_blank\" rel=\"external\">https://www.postgresql.org/media/keys/ACCC4CF8.asc</a> | \\<br>  sudo apt-key add -</p>\n<p>3- 更新数据仓库<br>    sudo apt-get update</p>\n<p>4- 安装postgresql<br>    apt-get install postgresql-9.6</p>\n<h2 id=\"2：确定用户\"><a href=\"#2：确定用户\" class=\"headerlink\" title=\"2：确定用户\"></a>2：确定用户</h2><p>postgresql安装后，默认只有一个postgres超级用户，所以要新增至少一个用户作为非超级用户普通使用，可以将当前系统的用户或新创建一个用户使用。 如：sudo adduser dbuser   //新建用户</p>\n<p>kriry@ubuntu:~$ sudo su - postgres   // 切换到postgres<br>postgres@ubuntu:~$ psql                 // 使用psql修改密码<br>postgres=# \\password postgres   // 修改密码命令然后设置修改<br>postgres=# \\q                    //退出</p>\n<h2 id=\"3：服务器配置及初始化（默认当前系统的用户）\"><a href=\"#3：服务器配置及初始化（默认当前系统的用户）\" class=\"headerlink\" title=\"3：服务器配置及初始化（默认当前系统的用户）\"></a>3：服务器配置及初始化（默认当前系统的用户）</h2><p>kriry@ubuntu:~$ </p>\n<p>配置及数据目录到环境变量：/home/kriry/.bashrc（若是新建用户，则将以下配置添加到新建用户的环境变量中。如：/home/dbuser/.bashrc).若不想每个用户各自配置可以配置在/etc/profile系统环境变量中.<br>注意：目录：PGDATA，PGHOME，PATH，LD_LIBRARY_PATH要sudo赋予数据库使用用户权限（如：kriry/dbuser）<br>export PGHOME=/usr/lib/postgresql/9.6<br>export PATH=$PGHOME/bin:$PATH<br>export PGDATA=/usr/local/pgsql/data<br>export LD_LIBRARY_PATH=$PGHOME/lib</p>\n<p>初始化数据库数据集簇<br>initdb -D /usr/local/pgsql/data</p>\n<p>启动数据库服务器<br>postgres -D /usr/local/pgsql/data</p>\n<h2 id=\"4：配置数据库用户及数据库\"><a href=\"#4：配置数据库用户及数据库\" class=\"headerlink\" title=\"4：配置数据库用户及数据库\"></a>4：配置数据库用户及数据库</h2><p>kriry@ubuntu:~$  sudo su - postgres   // 切换到postgres<br>postgres@ubuntu:~$ psql<br>postgres=# select rolname from pg_roles;     //查看现有用户<br>postgres=# SELECT datname FROM pg_database;  //查看现有数据库的集合<br>postgres=# create role dbuser with LOGIN CREATEDB PASSWORD ‘password’; //创建系统使用用户同名数据库角色用户并附与权限<br>postgres=# CREATE DATABASE dbname OWNER rolename;       //创建数据库<br>postgres=# \\q<br>postgres@ubuntu:~$ su dbuser    //切换到使用用户<br>kriry@ubuntu:~$ systemctl enable postgresql    //开机启动<br>kriry@ubuntu:~$ systemctl start postgresql     //启动服务<br>kriry@ubuntu:~$ systemctl restart postgresql   //重启<br>kriry@ubuntu:~$ systemctl stop postgresql     //停止<br>kriry@ubuntu:~$ sudo netstat -natp|grep postgres    //查看端口</p>\n<p>登录数据库<br>psql -U dbuser -d exampledb -h 127.0.0.1 -p 5432</p>\n<p>查看postgresql服务：<br>    service –status-all                //查看本机所有服务状态<br>    systemctl status                    //查看本机所有服务状态<br>    systemctl status postgresql         //查看postgresql服务状态</p>\n<p>导入SQL ：psql  -U username -W -d dbname -f xx.sql</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html\" target=\"_blank\" rel=\"external\">PostgreSQL新手入门</a></p>\n<h2 id=\"1：-安装postgresql\"><a href=\"#1：-安装postgresql\" class=\"headerlink\" title=\"1： 安装postgresql\"></a>1： <a href=\"https://www.postgresql.org/download/linux/ubuntu/\" target=\"_blank\" rel=\"external\">安装postgresql</a></h2><p>kriry@ubuntu:$ </p>\n<p>1- 创建文件 /etc/apt/sources.list.d/pgdg.list, 添加下面一行：<br>    deb <a href=\"http://apt.postgresql.org/pub/repos/apt/\" target=\"_blank\" rel=\"external\">http://apt.postgresql.org/pub/repos/apt/</a> xenial-pgdg main</p>\n<p>2- 导入 repository signing key, and update the package lists<br>wget –quiet -O - <a href=\"https://www.postgresql.org/media/keys/ACCC4CF8.asc\" target=\"_blank\" rel=\"external\">https://www.postgresql.org/media/keys/ACCC4CF8.asc</a> | \\<br>  sudo apt-key add -</p>\n<p>3- 更新数据仓库<br>    sudo apt-get update</p>\n<p>4- 安装postgresql<br>    apt-get install postgresql-9.6</p>\n<h2 id=\"2：确定用户\"><a href=\"#2：确定用户\" class=\"headerlink\" title=\"2：确定用户\"></a>2：确定用户</h2><p>postgresql安装后，默认只有一个postgres超级用户，所以要新增至少一个用户作为非超级用户普通使用，可以将当前系统的用户或新创建一个用户使用。 如：sudo adduser dbuser   //新建用户</p>\n<p>kriry@ubuntu:~$ sudo su - postgres   // 切换到postgres<br>postgres@ubuntu:~$ psql                 // 使用psql修改密码<br>postgres=# \\password postgres   // 修改密码命令然后设置修改<br>postgres=# \\q                    //退出</p>\n<h2 id=\"3：服务器配置及初始化（默认当前系统的用户）\"><a href=\"#3：服务器配置及初始化（默认当前系统的用户）\" class=\"headerlink\" title=\"3：服务器配置及初始化（默认当前系统的用户）\"></a>3：服务器配置及初始化（默认当前系统的用户）</h2><p>kriry@ubuntu:~$ </p>\n<p>配置及数据目录到环境变量：/home/kriry/.bashrc（若是新建用户，则将以下配置添加到新建用户的环境变量中。如：/home/dbuser/.bashrc).若不想每个用户各自配置可以配置在/etc/profile系统环境变量中.<br>注意：目录：PGDATA，PGHOME，PATH，LD_LIBRARY_PATH要sudo赋予数据库使用用户权限（如：kriry/dbuser）<br>export PGHOME=/usr/lib/postgresql/9.6<br>export PATH=$PGHOME/bin:$PATH<br>export PGDATA=/usr/local/pgsql/data<br>export LD_LIBRARY_PATH=$PGHOME/lib</p>\n<p>初始化数据库数据集簇<br>initdb -D /usr/local/pgsql/data</p>\n<p>启动数据库服务器<br>postgres -D /usr/local/pgsql/data</p>\n<h2 id=\"4：配置数据库用户及数据库\"><a href=\"#4：配置数据库用户及数据库\" class=\"headerlink\" title=\"4：配置数据库用户及数据库\"></a>4：配置数据库用户及数据库</h2><p>kriry@ubuntu:~$  sudo su - postgres   // 切换到postgres<br>postgres@ubuntu:~$ psql<br>postgres=# select rolname from pg_roles;     //查看现有用户<br>postgres=# SELECT datname FROM pg_database;  //查看现有数据库的集合<br>postgres=# create role dbuser with LOGIN CREATEDB PASSWORD ‘password’; //创建系统使用用户同名数据库角色用户并附与权限<br>postgres=# CREATE DATABASE dbname OWNER rolename;       //创建数据库<br>postgres=# \\q<br>postgres@ubuntu:~$ su dbuser    //切换到使用用户<br>kriry@ubuntu:~$ systemctl enable postgresql    //开机启动<br>kriry@ubuntu:~$ systemctl start postgresql     //启动服务<br>kriry@ubuntu:~$ systemctl restart postgresql   //重启<br>kriry@ubuntu:~$ systemctl stop postgresql     //停止<br>kriry@ubuntu:~$ sudo netstat -natp|grep postgres    //查看端口</p>\n<p>登录数据库<br>psql -U dbuser -d exampledb -h 127.0.0.1 -p 5432</p>\n<p>查看postgresql服务：<br>    service –status-all                //查看本机所有服务状态<br>    systemctl status                    //查看本机所有服务状态<br>    systemctl status postgresql         //查看postgresql服务状态</p>\n<p>导入SQL ：psql  -U username -W -d dbname -f xx.sql</p>\n"},{"title":"Rust数据类型详解","date":"2015-08-15T10:40:00.000Z","_content":"\n# 一：原生类型\n- 布尔类型（bool）：有两个值true和false。\n- 字符类型 (char)：表示单个Unicode值，存储为4个字节。Rust支持(u8)单字节字符b'H',仅限制于ASCII字符。\n- 数值类型 (int/float)：有符号整数 (i8,i16,i32,i64,isize)、无符号整数 (u8,u16,u32,u64,usize) 浮点数(f32,f64).整形默认为i32，浮点型默认为f64.\n- 字符串类型(str)：Unicode string slices.分为字符串切片&str和堆分配字符串String，字符串切片是静态分配，有固定大小，且不可变，堆分配字符串是可变的。Rust还支持单字节字符串b\"Hello\"和原始字节字符串使用br#\"hello\"#，仅限于ASCII字符,不需要对特殊字符进行转义。\n- 指针 ( pointer )：最底层的是裸指针\\*const T和\\*mut T，但解引用它们是不安全的，必须放到unsafe块里。\n- 函数 ( fn )：具有函数类型的变量实质上是一个函数指针。\n- 元类型：即()，其唯一的值也是()。\n\n# 二：复合类型\n- 数组  ( array )：具有固定大小，并且元素都是同种类型，表示[T; N]，标准库动态的数组即向量 Vec。不多于32个元素的数组在值传递时是自动复制的.数组切片(&[T])：一个数组引用部分数据并且不需要拷贝，可表示为&[T]。\n- 元组  ( tuple )：固定大小的有序列表，每个元素都有自己的类型，通过解构或者索引来获得元素的值。可使用==和!=运算符来判断是否相同，不多于12个元素的元组在值传递时是自动复制的。\n\n# 三：自定义类型\n- 结构体(struct) : \n- 枚举(enum) : \n\n# 四：标准库数据类型\n- String : A UTF-8 encoded, growable string.\n- Box : \n- Sequences: Vec, VecDeque, LinkedList\n- Maps: HashMap, BTreeMap\n- Sets: HashSet, BTreeSet\n- Misc: BinaryHeap\n\n## 字符串\n\n一个*字符串*是一串UTF-8字节编码的Unicode量级值的序列。所有的字符串都确保是有效编码的UTF-8序列。另外，字符串并不以null结尾并且可以包含null字节。Rust有两种主要的字符串类型：`&str`和`String`。让我们先看看`&str`。这叫做*字符串片段*（*string slices*）。字符串常量是`&'static str`类型的：\n\n```rust\nlet greeting = \"Hello there.\"; // greeting: &'static str\n```\n\n`\"Hello there.\"`是一个字符串常量而它的类型是`&'static str`。字符串常量是静态分配的字符串切片，也就是说它储存在我们编译好的程序中，并且整个程序的运行过程中一直存在。这个`greeting`绑定了一个静态分配的字符串的引用。任何接受一个字符串切片的函数也接受一个字符串常量。\n\n字符串常量可以跨多行。有两种形式。第一种会包含新行符和之前的空格：\n\n```rust\nlet s = \"foo\n    bar\";\n\nassert_eq!(\"foo\\n        bar\", s);\n```\n\n第二种，带有`\\`，会去掉空格和新行符：\n\n```rust\nlet s = \"foo\\\n    bar\";\n\nassert_eq!(\"foobar\", s);\n```\n\nRust 当然不仅仅只有`&str`。一个`String`，是一个在堆上分配的字符串。这个字符串可以增长，并且也保证是UTF-8编码的。`String`通常通过一个字符串片段调用`to_string`方法转换而来。\n\n```rust\nlet mut s = \"Hello\".to_string(); // mut s: String\nprintln!(\"{}\", s);\n\ns.push_str(\", world.\");\nprintln!(\"{}\", s);\n```\n\n`String`可以通过一个`&`强制转换为`&str`：\n\n```rust\nfn takes_slice(slice: &str) {\n    println!(\"Got: {}\", slice);\n}\n\nfn main() {\n    let s = \"Hello\".to_string();\n    takes_slice(&s);\n}\n```\n\n这种强制转换并不发生在接受`&str`的trait而不是`&str`本身作为参数的函数上。例如，[TcpStream::connect](http://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.connect)，有一个`ToSocketAddrs`类型的参数。`&str`可以不用转换不过`String`必须使用`&*`显式转换。\n\n```rust\nuse std::net::TcpStream;\n\nTcpStream::connect(\"192.168.0.1:3000\"); // &str parameter\n\nlet addr_string = \"192.168.0.1:3000\".to_string();\nTcpStream::connect(&*addr_string); // convert addr_string to &str\n```\n\n把`String`转换为`&str`的代价很小，不过从`&str`转换到`String`涉及到分配内存。除非必要，没有理由这样做！\n\n## 索引（Indexing）\n\n因为字符串是有效UTF-8编码的，它不支持索引：\n\n```rust\nlet s = \"hello\";\n\nprintln!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n```\n\n通常，用`[]`访问一个数组是非常快的。不过，字符串中每个UTF-8编码的字符可以是多个字节，你必须遍历字符串来找到字符串的第N个字符。这个操作的代价相当高，而且我们不想误导读者。更进一步来讲，Unicode实际上并没有定义什么“字符”。我们可以选择把字符串看作一个串独立的字节，或者代码点（codepoints）：\n\n```rust\nlet hachiko = \"忠犬ハチ公\";\n\nfor b in hachiko.as_bytes() {\n    print!(\"{}, \", b);\n}\n\nprintln!(\"\");\n\nfor c in hachiko.chars() {\n    print!(\"{}, \", c);\n}\n\nprintln!(\"\");\n```\n\n这会打印出：\n\n```text\n229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,\n忠, 犬, ハ, チ, 公,\n```\n\n如你所见，这有比`char`更多的字节。\n\n你可以这样来获取跟索引相似的东西：\n\n```rust\n# let hachiko = \"忠犬ハチ公\";\nlet dog = hachiko.chars().nth(1); // kinda like hachiko[1]\n```\n\n这强调了我们不得不遍历整个`char`的列表。\n\n你可以使用切片语法来获取一个字符串的切片：\n\n```rust\nlet dog = \"hachiko\";\nlet hachi = &dog[0..5];\n```\n\n注意这里是*字节*偏移，而不是*字符*偏移。所以如下代码在运行时会失败：\n\n```rust\nlet dog = \"忠犬ハチ公\";\nlet hachi = &dog[0..2];\n```\n\n给出如下错误：\n\n```text\nthread '<main>' panicked at 'index 0 and/or 2 in `忠犬ハチ公` do not lie on\ncharacter boundary'\n```\n\n### 拼接字符串：(结果是String)\n1. &str不能直接拼接，\n2. 拼接的首个字符串必须是String，之后的String需要一个 & 转换成 &str，这个功能叫做 Deref  转换。\n3. 满足1，2条件的String与&str可以多个交叉拼接。\n\n这是因为`&String`可以自动转换为一个`&str`。这个功能叫做** `Deref`转换**。\n\n```rust\nlet    hello      =  \"Hello\".to_string();        // String\nlet    hello_str  =  \"Hello!\";                 // &'static str\nlet    world      =  \"World!\".to_string();      \nlet    world_str  =  \"World!\";             \nlet    tom        =  \"tom!\".to_string();  \nlet    tom_str    =  \"tom!\";\nlet    lucy       =  \"lucy!\".to_string();  \nlet    lucy_str   =  \"lucy!\";\nlet    lilei      =  \"lilei!\".to_string();  \nlet    lilei_str  =  \"lilei!\";\n\nlet    hello_world  =  hello + world_str;\nlet    hello_world  =  hello + &world;\nlet    hello_world  =  hello + world_str + tom_str + lucy_str;\nlet    hello_world  =  hello + &world + &tom + &lucy;\nlet    hello_world  =  hello + hello_str + &world + world_str + tom_str + &tom + &lucy + &lilei + lucy_str + lilei_str;\n```\n\n\n## 元组（Tuples）\n元组（tuples）是固定大小的有序列表。如下：\n\n```rust\nlet x = (1, \"hello\");\nlet x: (i32, &str) = (1, \"hello\");\n\nlet mut x = (1, 2); // x: (i32, i32)\nlet y = (2, 3); // y: (i32, i32)\nlet\te\t=\tx.1;\nx = y;\n```\n\n你可以通过一个*解构let*（*destructuring let*）访问元组中的字段。下面是一个例子：\n\n```rust\nlet (x, y, z) = (1, 2, 3);\n\nprintln!(\"x is {}\", x);\n```\n\n可以在`let`左侧写一个模式，如果它能匹配右侧的话，我们可以一次写多个绑定。这种情况下，`let`“解构”或“拆开”了元组，并分成了三个绑定。\n\n你可以一个逗号来消除一个单元素元组和一个括号中的值的歧义：\n\n```rust\n(0,); // single-element tuple\n(0); // zero \n```\n\n### 元组索引（Tuple Indexing）\n你也可以用索引语法访问一个元组的字段,它使用`.`\n\n```rust\nlet tuple = (1, 2, 3);\n\nlet x = tuple.0;\nprintln!(\"x is {}\", x);\n```\n\n### 数组(array)与Vec\n\n**定义数组**：\n```rust\nlet mut array: [i32; 3] = [0; 3];   // 方式一\nlet arr = [8,\t9,\t10];            // 方式二\narray[1] = 1;\narray[2] = 2;\n\nassert_eq!([1, 2], &array[1..]);\n\n// This loop prints: 0 1 2\nfor x in &array {\n    print!(\"{} \", x);\n}\n```\n\n Vec : pronounced 'Vector'是一个动态或“可增长”的数组，被实现为标准库类型[`Vec<T>`](http://doc.rust-lang.org/std/Vec/)（其中`<T>`是一个[泛型](Generics 泛型.md)语句）。Vec总是在堆上分配数据。Vec与数组切片就像`String`与`&str`一样。你可以使用`vec!`宏来创建它：\n\n```rust\nlet v1: Vec<i32> = Vec::new();    // 方式一\nlet v = vec![1, 2, 3, 4, 5];    // v: Vec<i32>   方式二\nlet\tv2 = vec![0;10];\t        //\t声明一个初始长度为10的值全为0的动态数组\n```\n\n（与我们之前使用`println!`宏时不一样，我们在`vec!`中使用中括号`[]`。为了方便，Rust 允许你使用上述各种情况。）\n\n对于重复初始值有另一种形式的`vec!`：\n\n```rust\nlet v = vec![0; 10]; // ten zeroes\n```\n\n#### 访问元素\n为了Vec特定索引的值，我们使用`[]`,索引从`0`开始，所以第3个元素是`v[2]`.\n\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet r0 = v[1];\nlet r1 = &v[2];             //当引用一个不存在的元素时，会造成panic!.\nlet r2 = v.get(3);           //当引用一个不存在的元素时，返回None.\nprintln!(\"The third element of v is{}, {},{}\", r0, r1,r2);\n```\n\n另外值得注意的是你必须用`usize`类型的值来索引：\n\n```rust\nlet v = vec![1, 2, 3, 4, 5];\n\nlet i: usize = 0;\nlet j: i32 = 0;\n\n// works\nv[i];\n\n// doesn’t\nv[j];\n```\n\n用非`usize`类型索引的话会给出类似如下的错误：\n\n```text\nerror: the trait `core::ops::Index<i32>` is not implemented for the type\n`collections::Vec::Vec<_>` [E0277]\nv[j];\n^~~~\nnote: the type `collections::Vec::Vec<_>` cannot be indexed by `i32`\nerror: aborting due to previous error\n```\n\n信息中有很多标点符号，不过核心意思是：你不能用`i32`来索引。\n\n#### 越界访问（Out-of-bounds Access）\n\n如果你尝试访问并不存在的索引：\n\n```rust\nlet v = vec![1, 2, 3];\nprintln!(\"Item 7 is {}\", v[7]);\n```\n\n那么当前的线程会**panic**并输出如下信息：\n\n```text\nthread '<main>' panicked at 'index out of bounds: the len is 3 but the index is 7'\n```\n\n如果你想处理越界错误而不是 panic，你可以使用像[`get`](http://doc.rust-lang.org/std/Vec/struct.Vec.html#method.get)或[`get_mut`](http://doc.rust-lang.org/std/Vec/struct.Vec.html#method.get)这样的方法，他们当给出一个无效的索引时返回`None`：\n\n```rust\nlet v = vec![1, 2, 3];\nmatch v.get(7) {\n    Some(x) => println!(\"Item 7 is {}\", x),\n    None => println!(\"Sorry, this Vector is too short.\")\n}\n```\n\n使用枚举来储存多种类型\n```rust\n\nenum SpreadsheetCell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\n\nlet row = vec![\n    SpreadsheetCell::Int(3),\n    SpreadsheetCell::Text(String::from(\"blue\")),\n    SpreadsheetCell::Float(10.12),\n];\n```\n\n#### 迭代\n当你有了一个Vector，我可以用`for`来迭代它的元素。有3个版本：\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the Vector and its element {}\", i);\n}\n```\n\nVector还有很多有用的方法，你可以看看[Vector的API文档](http://doc.rust-lang.org/nightly/std/Vec/)了解它们。\n\n## 数组切片（Slices）\n一个*切片*（*slice*）是一个数组的引用（或者“视图”）。它有利于安全，有效的访问数组的一部分而不用进行拷贝。比如，你可能只想要引用读入到内存的文件中的一行。原理上，片段并不是直接创建的，而是引用一个已经存在的变量。片段有预定义的长度，可以是可变也可以是不可变的。\n\n### 切片语法\n\n你可以用一个`&`和`[]`的组合从多种数据类型创建一个切片。`&`表明切片类似于**引用**，带有一个范围的`[]`，允许你定义切片的长度：\n\n```rust\nlet a = [0, 1, 2, 3, 4];\nlet complete = &a[..]; // A slice containing all of the elements in a\nlet middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3\n```\n\n片段拥有`&[T]`类型。当我们涉及到**泛型**时会讨论这个`T`。\n\n你可以在[标准库文档](http://doc.rust-lang.org/stable/std/primitive.slice.html)中找到更多关于`slices`的文档。\n\n\n## 函数\n函数也有一个类型！它们看起来像这样：\n\n```rust\nfn foo(x: i32) -> i32 { x }\n\nlet x: fn(i32) -> i32 = foo;\n```\n\n在这个例子中，`x`是一个“函数指针”，指向一个获取一个`i32`参数并返回一个`i32`值的函数。\n\n## 表达式 VS 语句\nRust 主要是一个基于表达式的语言。只有两种语句，其它的一切都是表达式。\n\n表达式返回一个值，而语句不是。这就是为什么这里我们以“不是所有控制路径都返回一个值”结束：`x + 1;`语句不返回一个值。Rust 中有两种类型的语句：“声明语句”和“表达式语句”。其余的一切是表达式。让我们先讨论下声明语句。\n\n在 Rust 中，使用`let`引入一个绑定并*不是*一个表达式。下面的代码会产生一个编译时错误：\n\n```rust\nlet x = (let y = 5); // expected identifier, found keyword `let`\n```\n\n编译器告诉我们这里它期望看到表达式的开头，而`let`只能开始一个语句，不是一个表达式。\n\n注意赋值一个已经绑定过的变量（例如，`y = 5`）仍是一个表达式，即使它的（返回）值并不是特别有用。不像其它语言中赋值语句返回它赋的值（例如，前面例子中的`5`），在 Rust 中赋值的值是一个空的元组`()`：\n\n```rust\nlet mut y = 5;\n\nlet x = (y = 6);  // x has the value `()`, not `6`\n```\n\nRust中第二种语句是*表达式语句*。它的目的是把任何表达式变为语句。在实践环境中，Rust 语法期望语句后跟其它语句。这意味着你用分号来分隔各个表达式。这意味着Rust看起来很像大部分其它使用分号做为语句结尾的语言，并且你会看到分号出现在几乎每一行你看到的 Rust 代码。\n\n那么我们说“几乎”的例外是神马呢？你已经见过它了，在这些代码中：\n\n```rust\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n```\n\n我们的函数声称它返回一个`i32`，不过带有一个分号，它会返回一个`()`。Rust意识到这可能不是我们想要的，并在我们之前看到的错误中建议我们去掉分号。\n\n## 提早返回（Early returns）\n不过提早返回,Rust确实有这么一个关键字，`return`,使用`return`作为函数的最后一行是可行的，不过被认为是一个糟糕的风格：\n\n```rust\nfn foo(x: i32) -> i32 {\n    return x;\n\n    // we never run this code!\n    x + 1\n}\n```\n\n## 发散函数（Diverging functions）\nRust有些特殊的语法叫“发散函数”，这些函数并不返回：\n\n```rust\nfn diverges() -> ! {\n    panic!(\"This function never returns!\");\n}\n```\n\n`panic!`是一个宏，类似我们已经见过的`println!()`。与`println!()`不同的是，`panic!()`导致当前的执行线程崩溃并返回指定的信息。因为这个函数会崩溃，所以它不会返回，所以它拥有一个类型`!`，它代表“发散”。\n\n如果你添加一个叫做`diverges()`的函数并运行，你将会得到一些像这样的输出：\n\n```text\nthread ‘<main>’ panicked at ‘This function never returns!’, hello.rs:2\n```\n\n如果你想要更多信息，你可以设定`RUST_BACKTRACE`环境变量来获取 backtrace ：\n\n```bash\n$ RUST_BACKTRACE=1 ./diverges\nthread '<main>' panicked at 'This function never returns!', hello.rs:2\nstack backtrace:\n   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r\n   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w\n   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw\n   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650\n   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa\n   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa\n   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231\n   8:     0x7f402773d1d8 - __rust_try\n   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w\n  10:     0x7f4027738a19 - main\n  11:     0x7f402694ab44 - __libc_start_main\n  12:     0x7f40277386c8 - <unknown>\n  13:                0x0 - <unknown>\n```\n\n`RUST_BACKTRACE`也可以用于 Cargo 的`run`命令：\n\n```bash\n$ RUST_BACKTRACE=1 cargo run\n     Running `target/debug/diverges`\nthread '<main>' panicked at 'This function never returns!', hello.rs:2\nstack backtrace:\n   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r\n   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w\n   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw\n   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650\n   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa\n   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa\n   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231\n   8:     0x7f402773d1d8 - __rust_try\n   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w\n  10:     0x7f4027738a19 - main\n  11:     0x7f402694ab44 - __libc_start_main\n  12:     0x7f40277386c8 - <unknown>\n  13:                0x0 - <unknown>\n```\n\n发散函数可以被用作任何类型：\n\n```rust\nfn diverges() -> ! {\n   panic!(\"This function never returns!\");\n}\nlet x: i32 = diverges();\nlet x: String = diverges();\n```\n\n## 函数指针\n\n我们也可以创建指向函数的变量绑定：\n\n```rust\nlet f: fn(i32) -> i32;\n```\n\n`f`是一个指向一个获取`i32`作为参数并返回`i32`的函数的变量绑定。例如：\n\n```rust\nfn plus_one(i: i32) -> i32 {\n    i + 1\n}\n\n// without type inference\nlet f: fn(i32) -> i32 = plus_one;\n\n// with type inference\nlet f = plus_one;\n```\n\n你可以用`f`来调用这个函数：\n\n```rust\n# fn plus_one(i: i32) -> i32 { i + 1 }\n# let f = plus_one;\nlet six = f(5);\n```\n## 高阶函数\n  高阶函数与普通函数的不同在于，它可以使用一个或多个函数作为参数，可以将函数作为返回值。rust的函数是first class type，所以支持高阶函数。而，由于rust是一个强类型的语言，如果要将函数作为参数或返回值，首先需要搞明白函数的类型。下面先说函数的类型，再说函数作为参数和返回值。\n\n#### 函数类型\n  前面说过，关键字`fn`可以用来定义函数。除此以外，它还用来构造函数类型。与函数定义主要的不同是，构造函数类型不需要函数名、参数名和函数体。在Rust Reference中的描述如下：\n  > The function type constructor fn forms new function types. A function type consists of a possibly-empty set of function-type modifiers (such as unsafe or extern), a sequence of input types and an output type.\n\n  来看一个简单例子：\n  ```rust\nfn inc(n: i32) -> i32 {//函数定义\n  n + 1\n}\n\ntype IncType = fn(i32) -> i32;//函数类型\n\nfn main() {\n  let func: IncType = inc;\n  println!(\"3 + 1 = {}\", func(3));\n}\n  ```\n  上例首先使用`fn`定义了`inc`函数，它有一个`i32`类型参数，返回`i32`类型的值。然后再用`fn`定义了一个函数类型，这个函数类型有i32类型的参数和i32类型的返回值，并用`type`关键字定义了它的别名`IncType`。在`main`函数中定义了一个变量`func`，其类型就为`IncType`，并赋值为`inc`，然后在`pirntln`宏中调用：`func(3)`。可以看到，`inc`函数的类型其实就是`IncType`。  \n  这里有一个问题，我们将`inc`赋值给了`func`，而不是`&inc`，这样是将`inc`函数的拥有权转给了`func`吗，赋值后还可以以`inc()`形式调用`inc`函数吗？先来看一个例子：\n  ```rust\nfn main() {\n  let func: IncType = inc;\n  println!(\"3 + 1 = {}\", func(3));\n  println!(\"3 + 1 = {}\", inc(3));\n}\n\ntype IncType = fn(i32) -> i32;\n\nfn inc(n: i32) -> i32 {\n  n + 1\n}\n  ```\n  我们将上例保存在rs源文件中，再用rustc编译，发现并没有报错，并且运行也得到我们想要的结果：\n  ```\n3 + 1 = 4\n3 + 1 = 4\n  ```\n  这说明，赋值时，`inc`函数的所有权并没有被转移到`func`变量上，而是更像不可变引用。在rust中，函数的所有权是不能转移的，我们给函数类型的变量赋值时，赋给的一般是函数的指针，所以rust中的函数类型，就像是C/C++中的函数指针，当然，rust的函数类型更安全。可见，rust的函数类型，其实应该是属于指针类型（Pointer Type）。rust的Pointer Type有两种，一种为引用（Reference`&`），另一种为原始指针（Raw pointer `*`），详细内容请看[Rust Reference 8.18 Pointer Types](http://doc.rust-lang.org/reference.html#pointer-types)。而rust的函数类型应是引用类型，因为它是安全的，而原始指针则是不安全的，要使用原始指针，必须使用`unsafe`关键字声明。\n\n#### 函数作为参数\n  函数作为参数，其声明与普通参数一样。看下例：\n  ```rust\nfn main() {\n  println!(\"3 + 1 = {}\", process(3, inc));\n  println!(\"3 - 1 = {}\", process(3, dec));\n}\n\nfn inc(n: i32) -> i32 {\n  n + 1\n}\n\nfn dec(n: i32) -> i32 {\n  n - 1\n}\n\nfn process(n: i32, func: fn(i32) -> i32) -> i32 {\n  func(n)\n}\n  ```\n  例子中，`process`就是一个高阶函数，它有两个参数，一个类型为`i32`的`n`，另一个类型为`fn(i32)->i32`的函数`func`，返回一个`i32`类型的参数；它在函数体内以`n`作为参数调用`func`函数，返回`func`函数的返回值。运行可以得到以下结果：\n  ```\n3 + 1 = 4\n3 - 1 = 2\n  ```\n  不过，这不是函数作为参数的唯一声明方法，使用泛型函数配合特质（`trait`）也是可以的，因为rust的函数都会实现一个`trait`:`FnOnce`、`Fn`或`FnMut`。将上例中的`process`函数定义换成以下形式是等价的：\n  ```rust\nfn process<F>(n: i32, func: F) -> i32\n    where F: Fn(i32) -> i32 {\n    func(n)\n}\n  ```\n\n#### 函数作为返回值\n  函数作为返回值，其生命与普通函数的返回值类型声明一样。看例子：\n  ```rust\nfn main() {\n   let a = [1,2,3,4,5,6,7];\n   let mut b = Vec::<i32>::new();\n   for i in &a {\n       b.push(get_func(*i)(*i));\n   }\n   println!(\"{:?}\", b);\n}\n\nfn get_func(n: i32) -> fn(i32) -> i32 {\n    fn inc(n: i32) -> i32 {\n        n + 1\n    }\n    fn dec(n: i32) -> i32 {\n        n - 1\n    }\n    if n % 2 == 0 {\n        inc\n    } else {\n        dec\n    }\n}\n  ```\n  例子中的高阶函数为`get_func`，它接收一个i32类型的函数，返回一个类型为`fn(i32) -> i32`的函数，若传入的参数为偶数，返回`inc`，否则返回`dec`。这里需要注意的是，`inc`函数和`dec`函数都定义在`get_func`内。在函数内定义函数在很多其他语言中是不支持的，不过rust支持，这也是rust灵活和强大的一个体现。不过，在函数中定义的函数，不能包含函数中（环境中）的变量，若要包含，应该闭包。\n\n#### 返回多个值\n\nrust的函数不支持多返回值,但是我们可以利用元组来返回多个值,配合rust的模式匹配,使用起来十分灵活。先看例子:\n```rust\nfn main() {\n    let (p2,p3) = pow_2_3(789);\n    println!(\"pow 2 of 789 is {}.\", p2);\n\tprintln!(\"pow 3 of 789 is {}.\", p3);\n}\nfn pow_2_3(n: i32) -> (i32, i32) {\n\t(n*n, n*n*n)\n}\n```\n可以看到,上例中, pow_2_3函数接收一个i32类型的值,返回其二次方和三次方的值,这两个值包装在一个元组中返回。在 main函数中, let语句就可以使用模式匹配将函数返回的元组进行解构,将这两个返回值分别赋给 p2和p3,从而可以得到 789二次方的值和三次方的值。\n\n# 二：复合类型\n\n## 1. 结构体\n\n结构体是一个创建更复杂数据类型的方法,大写字母开头并且驼峰命名法.结构体中的值默认是不可变的.\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let origin = Point { x: 0, y: 0 }; // origin: Point\n    let mut do = Point { x: 1, y: 2 };\n    do.x = 5;\n\n    println!(\"The origin is at ({}, {})\", origin.x, origin.y);\n    println!(\"The origin is at ({}, {})\", do.x, do.y);\n}\n```\n\nRust 在语言级别不支持字段可变性，可变性是绑定的一个属性，不是结构体自身的。如果你习惯于字段级别的可变性，这开始可能看起来有点奇怪，不过这样明显地简化了问题。它甚至可以让你使变量只可变一段临时时间：\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let mut point = Point { x: 0, y: 0 };\n\n    point.x = 5;\n\n    let point = point; // now immutable\n\n    point.y = 6; // this causes an error\n}\n```\n\n你的结构体仍然可以包含`&mut`指针，它会给你一些类型的可变性：\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nstruct PointRef<'a> {\n    x: &'a mut i32,\n    y: &'a mut i32,\n}\n\nfn main() {\n    let mut point = Point { x: 0, y: 0 };\n\n    {\n        let r = PointRef { x: &mut point.x, y: &mut point.y };\n\n        *r.x = 5;\n        *r.y = 6;\n    }\n\n    assert_eq!(5, point.x);\n    assert_eq!(6, point.y);\n}\n```\n\n## 更新语法（Update syntax）\n一个包含`..`的`struct`表明你想要使用一些其它结构体的拷贝的一些值。例如：\n\n```rust\nstruct Point3d {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nlet mut point = Point3d { x: 0, y: 0, z: 0 };\npoint = Point3d { y: 1, .. point };\n```\n\n这给了`point`一个新的`y`，不过保留了`x`和`z`的值。这也并不必要是同样的`struct`，你可以在创建新结构体时使用这个语法，并会拷贝你未指定的值：\n\n```rust\n# struct Point3d {\n#     x: i32,\n#     y: i32,\n#     z: i32,\n# }\nlet origin = Point3d { x: 0, y: 0, z: 0 };\nlet point = Point3d { z: 1, x: 2, .. origin };\n```\n\n## 元组结构体\nRust有像另一个[元组](Primitive Types 原生类型.md#tuples)和结构体的混合体的数据类型。元组结构体有一个名字，不过它的字段没有。他们用`struct`关键字声明，并元组前面带有一个名字：\n\n```rust\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\n//这里`black`和`origin`并不相等，即使它们有一模一样的值：\nlet black = Color(0, 0, 0);\nlet origin = Point(0, 0, 0);\n```\n\n使用结构体几乎总是好于使用元组结构体。不过有种情况元组结构体非常有用，就是当元组结构体只有一个元素时。我们管它叫*新类型*（*newtype*），因为你创建了一个与元素相似的类型：\n\n```rust\nstruct Inches(i32);\n\nlet length = Inches(10);\n\nlet Inches(integer_length) = length;\nprintln!(\"length is {} inches\", integer_length);\n```\n\n如你所见，你可以通过一个解构`let`来提取内部的整型，就像我们在讲元组时说的那样，`let Inches(integer_length)`给`integer_length`赋值为`10`。\n\n## 类单元结构体（Unit-like structs）\n你可以定义一个没有任何成员的结构体：\n\n```rust\nstruct Electron {} // Use empty braces...\nstruct Proton;     // ...or just a semicolon.\n\n// Use the same notation when creating an instance.\nlet x = Electron {};\nlet y = Proton;\n```\n\n这样的结构体叫做“类单元”因为它与一个空元组类似，`()`，这有时叫做“单元”。就像一个元组结构体，它定义了一个新类型。\n\n就它本身来看没什么用（虽然有时它可以作为一个标记类型），不过在与其它功能的结合中，它可以变得有用。例如，一个库可能请求你创建一个实现了一个特定特性的结构来处理事件。如果你并不需要在结构中存储任何数据，你可以仅仅创建一个类单元结构体。\n\n## 2. 枚举\n\nRust 中的一个`enum`是一个代表数个可能变量的数据的类型。每个变量都可选是否关联数据：\n\n```rust\nenum Message {\n    Quit,\n    ChangeColor(i32, i32, i32),\n    Move { x: i32, y: i32 },\n    Write(String),\n}\n```\n\n定义变量的语法与用来定义结构体的语法类似：你可以有不带数据的变量（像类单元结构体），带有命名数据的变量，和带有未命名数据的变量（像元组结构体）。然而，不像单独的结构体定义，一个`enum`是一个单独的类型。一个枚举的值可以匹配任何一个变量。因为这个原因，枚举有时被叫做“集合类型”：枚举可能值的集合是每一个变量可能值的集合的总和。\n\n我们使用`::`语法来使用每个变量的名字：它们包含在`enum`名字自身中。这样的话，以下的情况都是可行的：\n\n```rust\nenum Message {\n     Move { x: i32, y: i32 },\n}\nlet x: Message = Message::Move { x: 3, y: 4 };\n\nenum BoardGameTurn {\n    Move { squares: i32 },\n    Pass,\n}\n\nlet y: BoardGameTurn = BoardGameTurn::Move { squares: 1 };\n```\n\n这两个变量都叫做`Move`，不过他们包含在枚举名字中，他们可以无冲突的使用。\n\n枚举类型的一个值包含它是哪个变量的信息，以及任何与变量相关的数据。这有时被作为一个“标记的联合”被提及。因为数据包括一个“标签”表明它的类型是什么。编译器使用这个信息来确保安全的访问枚举中的数据。例如，我们不能简单的尝试解构一个枚举值，就像它是其中一个可能的变体那样：\n\n```rust\nfn process_color_change(msg: Message) {\n    let Message::ChangeColor(r, g, b) = msg; // compile-time error\n}\n```\n\n不支持这些操作（比较操作）可能看起来更像限制。不过这是一个我们可以克服的限制。有两种方法：我们自己实现相等（比较），或通过[`match` ](Match 匹配.md)表达式模式匹配变量，你会在下一部分学到它。我们还不够了解Rust如何实现相等，不过我们会在[特性](Traits.md)找到它们。\n\n## 构造器作为函数（Constructors as functions）\n一个枚举的构造器总是可以像函数一样使用。例如：\n\n```rust\nenum Message {\nWrite(String),\n}\nlet m = Message::Write(\"Hello, world\".to_string());\n```\n\n与下面是一样的：\n\n```rust\nenum Message {\nWrite(String),\n}\nfn foo(x: String) -> Message {\n    Message::Write(x)\n}\n\nlet x = foo(\"Hello, world\".to_string());\n```\n\n这对我们没有什么直接的帮助，直到我们要用到[闭包](Closures 闭包.md)时，这时我们要考虑将函数作为参数传递给其他函数。例如，使用[迭代器](Iterators 迭代器.md)，我们可以这样把一个`String`的Vector转换为一个`Message::Write`的Vector：\n\n```rust\nenum Message {\nWrite(String),\n}\n\nlet v = vec![\"Hello\".to_string(), \"World\".to_string()];\n\nlet v1: Vec<Message> = v.into_iter().map(Message::Write).collect();\n```\n\n# 三：不定长类型\n\n大部分类型有一个特定的大小，以字节为单位，它们在编译时是已知的。例如，一个`i32`是32位大，或者4个字节。然而，有些类型有益于表达，却没有一个定义的大小。它们叫做“不定长”或者“动态大小”类型。一个例子是`[T]`。这个类型代表一个特定数量`t`的序列。不过我们并不知道有多少，所以大小是未知的。\n\nRust知道几个这样的类型，不过它们有一些限制。这有三个：\n\n1. 我们只能通过指针操作一个不定长类型的实例。`&[T]`刚好能正常工作，不过`[T]`不行。一个` &[T]`能正常工作，不过一个`[T]`不行。\n2. 变量和参数不能拥有动态大小类型。\n3. 只有一个`struct`的最后一个字段可能拥有一个动态大小类型；其它字段则不可以拥有动态大小类型。枚举变量不可以用动态大小类型作为数据。\n\n所以为什么这很重要？好吧，因为`[T]`只能用在一个指针之后，如果我们没有对不定长类型的语言支持，它将不可能这么写：\n\n```rust\nimpl Foo for str {\n```\n\n或者\n\n```rust\nimpl<T> Foo for [T] {\n```\n\n相反，你将不得不这么写：\n\n```rust\nimpl Foo for &str {\n```\n\n意味深长的是，这个实现将只能用于[引用](References and Borrowing 引用和借用.md)，并且不能用于其它类型的指针。通过`impl for str`，所有指针，包括（在一些地方，这里会有bug需要修复）用户自定义的智能指针，可以使用这个`impl`。\n\n## `?Sized`\n如果你想要写一个接受动态大小类型的函数，你可以使用这个特殊的限制，`?Sized`：\n\n```rust\nstruct Foo<T: ?Sized> {\n    f: T,\n}\n```\n这个`?`，读作“`T`可能是`Sized`的”，意味着这个限制是特殊的：它让我们的匹配更宽松，而不是相反。这几乎像每个`T`都隐式拥有` T: Sized`一样，`?`放松了这个默认（限制）。\n\n# 四：关联类型\n\n关联类型是Rust类型系统中非常强大的一部分。它涉及到‘类型族’的概念，换句话说，就是把多种类型归于一类。这个描述可能比较抽象，所以让我们深入研究一个例子。如果你想编写一个`Graph`trait，你需要泛型化两个类型：点类型和边类型。所以你可能会像这样写一个trait，`Graph<N, E>`：\n\n```rust\ntrait Graph<N, E> {\n    fn has_edge(&self, &N, &N) -> bool;\n    fn edges(&self, &N) -> Vec<E>;\n    // etc\n}\n```\n\n虽然这可以工作，不过显得很尴尬，例如，任何需要一个`Graph`作为参数的函数都需要泛型化的`N`ode和`E`dge类型：\n\n```rust\nfn distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> u32 { ... }\n```\n\n我们的距离计算并不需要`Edge`类型，所以函数签名中`E`只是写着玩的。\n\n我们需要的是对于每一种`Graph`类型，都使用一个特定的的`N`ode和`E`dge类型。我们可以用关联类型来做到这一点：\n\n```rust\ntrait Graph {\n    type N;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n    // etc\n}\n```\n\n现在，我们使用一个抽象的`Graph`了：\n\n```rust\nfn distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> uint { ... }\n```\n\n这里不再需要处理`E`dge类型了。\n\n让我们更详细的回顾一下。\n\n## 定义关联类型\n让我们构建一个`Graph`trait。这里是定义：\n\n```rust\ntrait Graph {\n    type N;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n}\n```\n\n十分简单。关联类型使用`type`关键字，并出现在trait体和函数中。\n\n这些`type`声明跟函数定义一样。例如，如果我们想`N`类型实现`Display`，这样我们就可以打印出点类型，我们可以这样写：\n\n```rust\nuse std::fmt;\n\ntrait Graph {\n    type N: fmt::Display;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n}\n```\n\n## 实现关联类型\n\n就像任何 trait，使用关联类型的 trait 用`impl`关键字来提供实现。下面是一个`Graph`的简单实现：\n\n```rust\n# trait Graph {\n#     type N;\n#     type E;\n#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n# }\nstruct Node;\n\nstruct Edge;\n\nstruct MyGraph;\n\nimpl Graph for MyGraph {\n    type N = Node;\n    type E = Edge;\n\n    fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n        true\n    }\n\n    fn edges(&self, n: &Node) -> Vec<Edge> {\n        Vec::new()\n    }\n}\n```\n\n这个可笑的实现总是返回`true`和一个空的`Vec<Edge>`，不过它提供了如何实现这类 trait 的思路。首先我们需要3个`struct`，一个代表图，一个代表点，还有一个代表边。如果使用别的类型更合理，也可以那样做，我们只是准备使用`struct`来代表这 3 个类型。\n\n接下来是`impl`行，它就像其它任何 trait 的实现。\n\n在这里，我们使用`=`来定义我们的关联类型。trait 使用的名字出现在`=`的左边，而我们`impl`的具体类型出现在右边。最后，我们在函数声明中使用具体类型。\n\n## trait 对象和关联类型\n\n这里还有另外一个我们需要讨论的语法：trait对象。如果你创建一个关联类型的trait对象，像这样：\n\n```rust\n# trait Graph {\n#     type N;\n#     type E;\n#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n# }\n# struct Node;\n# struct Edge;\n# struct MyGraph;\n# impl Graph for MyGraph {\n#     type N = Node;\n#     type E = Edge;\n#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n#         true\n#     }\n#     fn edges(&self, n: &Node) -> Vec<Edge> {\n#         Vec::new()\n#     }\n# }\nlet graph = MyGraph;\nlet obj = Box::new(graph) as Box<Graph>;\n```\n\n你会得到两个错误：\n\n```text\nerror: the value of the associated type `E` (from the trait `main::Graph`) must\nbe specified [E0191]\nlet obj = Box::new(graph) as Box<Graph>;\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n24:44 error: the value of the associated type `N` (from the trait\n`main::Graph`) must be specified [E0191]\nlet obj = Box::new(graph) as Box<Graph>;\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n```\n\n我们不能这样创建一个trait对象，因为我们并不知道关联的类型。相反，我们可以这样写：\n\n```rust\n# trait Graph {\n#     type N;\n#     type E;\n#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n# }\n# struct Node;\n# struct Edge;\n# struct MyGraph;\n# impl Graph for MyGraph {\n#     type N = Node;\n#     type E = Edge;\n#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n#         true\n#     }\n#     fn edges(&self, n: &Node) -> Vec<Edge> {\n#         Vec::new()\n#     }\n# }\nlet graph = MyGraph;\nlet obj = Box::new(graph) as Box<Graph<N=Node, E=Edge>>;\n```\n\n`N=Node`语法允许我们提供一个具体类型，`Node`，作为`N`类型参数。`E=Edge`也是一样。如果我们不提供这个限制，我们不能确定应该`impl`那个来匹配trait对象。\n\n\n\n关联类型是Rust类型系统中非常强大的一部分。它涉及到‘类型族’的概念，换句话说，就是把多种类型归于一类。这个描述可能比较抽象，所以让我们深入研究一个例子。如果你想编写一个`Graph`trait，你需要泛型化两个类型：点类型和边类型。所以你可能会像这样写一个trait，`Graph<N, E>`：\n\n```rust\ntrait Graph<N, E> {\n    fn has_edge(&self, &N, &N) -> bool;\n    fn edges(&self, &N) -> Vec<E>;\n    // etc\n}\n```\n\n虽然这可以工作，不过显得很尴尬，例如，任何需要一个`Graph`作为参数的函数都需要泛型化的`N`ode和`E`dge类型：\n\n```rust\nfn distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> u32 { ... }\n```\n\n我们的距离计算并不需要`Edge`类型，所以函数签名中`E`只是写着玩的。\n\n我们需要的是对于每一种`Graph`类型，都使用一个特定的的`N`ode和`E`dge类型。我们可以用关联类型来做到这一点：\n\n```rust\ntrait Graph {\n    type N;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n    // etc\n}\n```\n\n现在，我们使用一个抽象的`Graph`了：\n\n```rust\nfn distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> uint { ... }\n```\n\n这里不再需要处理`E`dge类型了。\n\n让我们更详细的回顾一下。\n\n## 定义关联类型\n让我们构建一个`Graph`trait。这里是定义：\n\n```rust\ntrait Graph {\n    type N;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n}\n```\n\n十分简单。关联类型使用`type`关键字，并出现在trait体和函数中。\n\n这些`type`声明跟函数定义一样。例如，如果我们想`N`类型实现`Display`，这样我们就可以打印出点类型，我们可以这样写：\n\n```rust\nuse std::fmt;\n\ntrait Graph {\n    type N: fmt::Display;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n}\n```\n\n## 实现关联类型\n\n就像任何 trait，使用关联类型的 trait 用`impl`关键字来提供实现。下面是一个`Graph`的简单实现：\n\n```rust\n# trait Graph {\n#     type N;\n#     type E;\n#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n# }\nstruct Node;\n\nstruct Edge;\n\nstruct MyGraph;\n\nimpl Graph for MyGraph {\n    type N = Node;\n    type E = Edge;\n\n    fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n        true\n    }\n\n    fn edges(&self, n: &Node) -> Vec<Edge> {\n        Vec::new()\n    }\n}\n```\n\n这个可笑的实现总是返回`true`和一个空的`Vec<Edge>`，不过它提供了如何实现这类 trait 的思路。首先我们需要3个`struct`，一个代表图，一个代表点，还有一个代表边。如果使用别的类型更合理，也可以那样做，我们只是准备使用`struct`来代表这 3 个类型。\n\n接下来是`impl`行，它就像其它任何 trait 的实现。\n\n在这里，我们使用`=`来定义我们的关联类型。trait 使用的名字出现在`=`的左边，而我们`impl`的具体类型出现在右边。最后，我们在函数声明中使用具体类型。\n\n## trait 对象和关联类型\n\n这里还有另外一个我们需要讨论的语法：trait对象。如果你创建一个关联类型的trait对象，像这样：\n\n```rust\n# trait Graph {\n#     type N;\n#     type E;\n#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n# }\n# struct Node;\n# struct Edge;\n# struct MyGraph;\n# impl Graph for MyGraph {\n#     type N = Node;\n#     type E = Edge;\n#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n#         true\n#     }\n#     fn edges(&self, n: &Node) -> Vec<Edge> {\n#         Vec::new()\n#     }\n# }\nlet graph = MyGraph;\nlet obj = Box::new(graph) as Box<Graph>;\n```\n\n你会得到两个错误：\n\n```text\nerror: the value of the associated type `E` (from the trait `main::Graph`) must\nbe specified [E0191]\nlet obj = Box::new(graph) as Box<Graph>;\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n24:44 error: the value of the associated type `N` (from the trait\n`main::Graph`) must be specified [E0191]\nlet obj = Box::new(graph) as Box<Graph>;\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n```\n\n我们不能这样创建一个trait对象，因为我们并不知道关联的类型。相反，我们可以这样写：\n\n```rust\n# trait Graph {\n#     type N;\n#     type E;\n#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n# }\n# struct Node;\n# struct Edge;\n# struct MyGraph;\n# impl Graph for MyGraph {\n#     type N = Node;\n#     type E = Edge;\n#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n#         true\n#     }\n#     fn edges(&self, n: &Node) -> Vec<Edge> {\n#         Vec::new()\n#     }\n# }\nlet graph = MyGraph;\nlet obj = Box::new(graph) as Box<Graph<N=Node, E=Edge>>;\n```\n\n`N=Node`语法允许我们提供一个具体类型，`Node`，作为`N`类型参数。`E=Edge`也是一样。如果我们不提供这个限制，我们不能确定应该`impl`那个来匹配trait对象。\n\n# 类型别名\n\n## \\`type\\`别名\n\n\n`type`关键字让你定义另一个类型的别名：\n\n```rust\ntype Name = String;\n```\n\n你可以像一个真正类型那样使用这个类型：\n\n```rust\ntype Name = String;\n\nlet x: Name = \"Hello\".to_string();\n```\n\n然而要注意的是，这一个*别名*，完全不是一个新的类型。换句话说，因为Rust是强类型的，你可以预期两个不同类型的比较会失败：\n\n```rust\nlet x: i32 = 5;\nlet y: i64 = 5;\n\nif x == y {\n   // ...\n}\n```\n\n这给出\n\n```text\nerror: mismatched types:\n expected `i32`,\n    found `i64`\n(expected i32,\n    found i64) [E0308]\n     if x == y {\n             ^\n```\n\n不过，如果我们有一个别名：\n\n```rust\ntype Num = i32;\n\nlet x: i32 = 5;\nlet y: Num = 5;\n\nif x == y {\n   // ...\n}\n```\n\n这会无错误的编译。从任何角度来说，`Num`类型的值与`i32`类型的值都是一样的。\n\n你也可以在泛型中使用类型别名：\n\n```rust\nuse std::result;\n\nenum ConcreteError {\n    Foo,\n    Bar,\n}\n\ntype Result<T> = result::Result<T, ConcreteError>;\n```\n\n这创建了一个特定版本的`Result`类型，它总是有一个`ConcreteError`作为`Result<T, E>`的`E`那部分。这通常用于标准库中创建每个子部分的自定义错误。例如，[`io::Result`](http://doc.rust-lang.org/nightly/std/io/type.Result.html)。\n","source":"_posts/Rust数据类型详解.md","raw":"---\ntitle: Rust数据类型详解\ndate: 2015-08-15 18:40\ntags:\n - Rust\n---\n\n# 一：原生类型\n- 布尔类型（bool）：有两个值true和false。\n- 字符类型 (char)：表示单个Unicode值，存储为4个字节。Rust支持(u8)单字节字符b'H',仅限制于ASCII字符。\n- 数值类型 (int/float)：有符号整数 (i8,i16,i32,i64,isize)、无符号整数 (u8,u16,u32,u64,usize) 浮点数(f32,f64).整形默认为i32，浮点型默认为f64.\n- 字符串类型(str)：Unicode string slices.分为字符串切片&str和堆分配字符串String，字符串切片是静态分配，有固定大小，且不可变，堆分配字符串是可变的。Rust还支持单字节字符串b\"Hello\"和原始字节字符串使用br#\"hello\"#，仅限于ASCII字符,不需要对特殊字符进行转义。\n- 指针 ( pointer )：最底层的是裸指针\\*const T和\\*mut T，但解引用它们是不安全的，必须放到unsafe块里。\n- 函数 ( fn )：具有函数类型的变量实质上是一个函数指针。\n- 元类型：即()，其唯一的值也是()。\n\n# 二：复合类型\n- 数组  ( array )：具有固定大小，并且元素都是同种类型，表示[T; N]，标准库动态的数组即向量 Vec。不多于32个元素的数组在值传递时是自动复制的.数组切片(&[T])：一个数组引用部分数据并且不需要拷贝，可表示为&[T]。\n- 元组  ( tuple )：固定大小的有序列表，每个元素都有自己的类型，通过解构或者索引来获得元素的值。可使用==和!=运算符来判断是否相同，不多于12个元素的元组在值传递时是自动复制的。\n\n# 三：自定义类型\n- 结构体(struct) : \n- 枚举(enum) : \n\n# 四：标准库数据类型\n- String : A UTF-8 encoded, growable string.\n- Box : \n- Sequences: Vec, VecDeque, LinkedList\n- Maps: HashMap, BTreeMap\n- Sets: HashSet, BTreeSet\n- Misc: BinaryHeap\n\n## 字符串\n\n一个*字符串*是一串UTF-8字节编码的Unicode量级值的序列。所有的字符串都确保是有效编码的UTF-8序列。另外，字符串并不以null结尾并且可以包含null字节。Rust有两种主要的字符串类型：`&str`和`String`。让我们先看看`&str`。这叫做*字符串片段*（*string slices*）。字符串常量是`&'static str`类型的：\n\n```rust\nlet greeting = \"Hello there.\"; // greeting: &'static str\n```\n\n`\"Hello there.\"`是一个字符串常量而它的类型是`&'static str`。字符串常量是静态分配的字符串切片，也就是说它储存在我们编译好的程序中，并且整个程序的运行过程中一直存在。这个`greeting`绑定了一个静态分配的字符串的引用。任何接受一个字符串切片的函数也接受一个字符串常量。\n\n字符串常量可以跨多行。有两种形式。第一种会包含新行符和之前的空格：\n\n```rust\nlet s = \"foo\n    bar\";\n\nassert_eq!(\"foo\\n        bar\", s);\n```\n\n第二种，带有`\\`，会去掉空格和新行符：\n\n```rust\nlet s = \"foo\\\n    bar\";\n\nassert_eq!(\"foobar\", s);\n```\n\nRust 当然不仅仅只有`&str`。一个`String`，是一个在堆上分配的字符串。这个字符串可以增长，并且也保证是UTF-8编码的。`String`通常通过一个字符串片段调用`to_string`方法转换而来。\n\n```rust\nlet mut s = \"Hello\".to_string(); // mut s: String\nprintln!(\"{}\", s);\n\ns.push_str(\", world.\");\nprintln!(\"{}\", s);\n```\n\n`String`可以通过一个`&`强制转换为`&str`：\n\n```rust\nfn takes_slice(slice: &str) {\n    println!(\"Got: {}\", slice);\n}\n\nfn main() {\n    let s = \"Hello\".to_string();\n    takes_slice(&s);\n}\n```\n\n这种强制转换并不发生在接受`&str`的trait而不是`&str`本身作为参数的函数上。例如，[TcpStream::connect](http://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.connect)，有一个`ToSocketAddrs`类型的参数。`&str`可以不用转换不过`String`必须使用`&*`显式转换。\n\n```rust\nuse std::net::TcpStream;\n\nTcpStream::connect(\"192.168.0.1:3000\"); // &str parameter\n\nlet addr_string = \"192.168.0.1:3000\".to_string();\nTcpStream::connect(&*addr_string); // convert addr_string to &str\n```\n\n把`String`转换为`&str`的代价很小，不过从`&str`转换到`String`涉及到分配内存。除非必要，没有理由这样做！\n\n## 索引（Indexing）\n\n因为字符串是有效UTF-8编码的，它不支持索引：\n\n```rust\nlet s = \"hello\";\n\nprintln!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n```\n\n通常，用`[]`访问一个数组是非常快的。不过，字符串中每个UTF-8编码的字符可以是多个字节，你必须遍历字符串来找到字符串的第N个字符。这个操作的代价相当高，而且我们不想误导读者。更进一步来讲，Unicode实际上并没有定义什么“字符”。我们可以选择把字符串看作一个串独立的字节，或者代码点（codepoints）：\n\n```rust\nlet hachiko = \"忠犬ハチ公\";\n\nfor b in hachiko.as_bytes() {\n    print!(\"{}, \", b);\n}\n\nprintln!(\"\");\n\nfor c in hachiko.chars() {\n    print!(\"{}, \", c);\n}\n\nprintln!(\"\");\n```\n\n这会打印出：\n\n```text\n229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,\n忠, 犬, ハ, チ, 公,\n```\n\n如你所见，这有比`char`更多的字节。\n\n你可以这样来获取跟索引相似的东西：\n\n```rust\n# let hachiko = \"忠犬ハチ公\";\nlet dog = hachiko.chars().nth(1); // kinda like hachiko[1]\n```\n\n这强调了我们不得不遍历整个`char`的列表。\n\n你可以使用切片语法来获取一个字符串的切片：\n\n```rust\nlet dog = \"hachiko\";\nlet hachi = &dog[0..5];\n```\n\n注意这里是*字节*偏移，而不是*字符*偏移。所以如下代码在运行时会失败：\n\n```rust\nlet dog = \"忠犬ハチ公\";\nlet hachi = &dog[0..2];\n```\n\n给出如下错误：\n\n```text\nthread '<main>' panicked at 'index 0 and/or 2 in `忠犬ハチ公` do not lie on\ncharacter boundary'\n```\n\n### 拼接字符串：(结果是String)\n1. &str不能直接拼接，\n2. 拼接的首个字符串必须是String，之后的String需要一个 & 转换成 &str，这个功能叫做 Deref  转换。\n3. 满足1，2条件的String与&str可以多个交叉拼接。\n\n这是因为`&String`可以自动转换为一个`&str`。这个功能叫做** `Deref`转换**。\n\n```rust\nlet    hello      =  \"Hello\".to_string();        // String\nlet    hello_str  =  \"Hello!\";                 // &'static str\nlet    world      =  \"World!\".to_string();      \nlet    world_str  =  \"World!\";             \nlet    tom        =  \"tom!\".to_string();  \nlet    tom_str    =  \"tom!\";\nlet    lucy       =  \"lucy!\".to_string();  \nlet    lucy_str   =  \"lucy!\";\nlet    lilei      =  \"lilei!\".to_string();  \nlet    lilei_str  =  \"lilei!\";\n\nlet    hello_world  =  hello + world_str;\nlet    hello_world  =  hello + &world;\nlet    hello_world  =  hello + world_str + tom_str + lucy_str;\nlet    hello_world  =  hello + &world + &tom + &lucy;\nlet    hello_world  =  hello + hello_str + &world + world_str + tom_str + &tom + &lucy + &lilei + lucy_str + lilei_str;\n```\n\n\n## 元组（Tuples）\n元组（tuples）是固定大小的有序列表。如下：\n\n```rust\nlet x = (1, \"hello\");\nlet x: (i32, &str) = (1, \"hello\");\n\nlet mut x = (1, 2); // x: (i32, i32)\nlet y = (2, 3); // y: (i32, i32)\nlet\te\t=\tx.1;\nx = y;\n```\n\n你可以通过一个*解构let*（*destructuring let*）访问元组中的字段。下面是一个例子：\n\n```rust\nlet (x, y, z) = (1, 2, 3);\n\nprintln!(\"x is {}\", x);\n```\n\n可以在`let`左侧写一个模式，如果它能匹配右侧的话，我们可以一次写多个绑定。这种情况下，`let`“解构”或“拆开”了元组，并分成了三个绑定。\n\n你可以一个逗号来消除一个单元素元组和一个括号中的值的歧义：\n\n```rust\n(0,); // single-element tuple\n(0); // zero \n```\n\n### 元组索引（Tuple Indexing）\n你也可以用索引语法访问一个元组的字段,它使用`.`\n\n```rust\nlet tuple = (1, 2, 3);\n\nlet x = tuple.0;\nprintln!(\"x is {}\", x);\n```\n\n### 数组(array)与Vec\n\n**定义数组**：\n```rust\nlet mut array: [i32; 3] = [0; 3];   // 方式一\nlet arr = [8,\t9,\t10];            // 方式二\narray[1] = 1;\narray[2] = 2;\n\nassert_eq!([1, 2], &array[1..]);\n\n// This loop prints: 0 1 2\nfor x in &array {\n    print!(\"{} \", x);\n}\n```\n\n Vec : pronounced 'Vector'是一个动态或“可增长”的数组，被实现为标准库类型[`Vec<T>`](http://doc.rust-lang.org/std/Vec/)（其中`<T>`是一个[泛型](Generics 泛型.md)语句）。Vec总是在堆上分配数据。Vec与数组切片就像`String`与`&str`一样。你可以使用`vec!`宏来创建它：\n\n```rust\nlet v1: Vec<i32> = Vec::new();    // 方式一\nlet v = vec![1, 2, 3, 4, 5];    // v: Vec<i32>   方式二\nlet\tv2 = vec![0;10];\t        //\t声明一个初始长度为10的值全为0的动态数组\n```\n\n（与我们之前使用`println!`宏时不一样，我们在`vec!`中使用中括号`[]`。为了方便，Rust 允许你使用上述各种情况。）\n\n对于重复初始值有另一种形式的`vec!`：\n\n```rust\nlet v = vec![0; 10]; // ten zeroes\n```\n\n#### 访问元素\n为了Vec特定索引的值，我们使用`[]`,索引从`0`开始，所以第3个元素是`v[2]`.\n\n```rust\nlet v = vec![1, 2, 3, 4, 5];\nlet r0 = v[1];\nlet r1 = &v[2];             //当引用一个不存在的元素时，会造成panic!.\nlet r2 = v.get(3);           //当引用一个不存在的元素时，返回None.\nprintln!(\"The third element of v is{}, {},{}\", r0, r1,r2);\n```\n\n另外值得注意的是你必须用`usize`类型的值来索引：\n\n```rust\nlet v = vec![1, 2, 3, 4, 5];\n\nlet i: usize = 0;\nlet j: i32 = 0;\n\n// works\nv[i];\n\n// doesn’t\nv[j];\n```\n\n用非`usize`类型索引的话会给出类似如下的错误：\n\n```text\nerror: the trait `core::ops::Index<i32>` is not implemented for the type\n`collections::Vec::Vec<_>` [E0277]\nv[j];\n^~~~\nnote: the type `collections::Vec::Vec<_>` cannot be indexed by `i32`\nerror: aborting due to previous error\n```\n\n信息中有很多标点符号，不过核心意思是：你不能用`i32`来索引。\n\n#### 越界访问（Out-of-bounds Access）\n\n如果你尝试访问并不存在的索引：\n\n```rust\nlet v = vec![1, 2, 3];\nprintln!(\"Item 7 is {}\", v[7]);\n```\n\n那么当前的线程会**panic**并输出如下信息：\n\n```text\nthread '<main>' panicked at 'index out of bounds: the len is 3 but the index is 7'\n```\n\n如果你想处理越界错误而不是 panic，你可以使用像[`get`](http://doc.rust-lang.org/std/Vec/struct.Vec.html#method.get)或[`get_mut`](http://doc.rust-lang.org/std/Vec/struct.Vec.html#method.get)这样的方法，他们当给出一个无效的索引时返回`None`：\n\n```rust\nlet v = vec![1, 2, 3];\nmatch v.get(7) {\n    Some(x) => println!(\"Item 7 is {}\", x),\n    None => println!(\"Sorry, this Vector is too short.\")\n}\n```\n\n使用枚举来储存多种类型\n```rust\n\nenum SpreadsheetCell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\n\nlet row = vec![\n    SpreadsheetCell::Int(3),\n    SpreadsheetCell::Text(String::from(\"blue\")),\n    SpreadsheetCell::Float(10.12),\n];\n```\n\n#### 迭代\n当你有了一个Vector，我可以用`for`来迭代它的元素。有3个版本：\n\n```rust\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the Vector and its element {}\", i);\n}\n```\n\nVector还有很多有用的方法，你可以看看[Vector的API文档](http://doc.rust-lang.org/nightly/std/Vec/)了解它们。\n\n## 数组切片（Slices）\n一个*切片*（*slice*）是一个数组的引用（或者“视图”）。它有利于安全，有效的访问数组的一部分而不用进行拷贝。比如，你可能只想要引用读入到内存的文件中的一行。原理上，片段并不是直接创建的，而是引用一个已经存在的变量。片段有预定义的长度，可以是可变也可以是不可变的。\n\n### 切片语法\n\n你可以用一个`&`和`[]`的组合从多种数据类型创建一个切片。`&`表明切片类似于**引用**，带有一个范围的`[]`，允许你定义切片的长度：\n\n```rust\nlet a = [0, 1, 2, 3, 4];\nlet complete = &a[..]; // A slice containing all of the elements in a\nlet middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3\n```\n\n片段拥有`&[T]`类型。当我们涉及到**泛型**时会讨论这个`T`。\n\n你可以在[标准库文档](http://doc.rust-lang.org/stable/std/primitive.slice.html)中找到更多关于`slices`的文档。\n\n\n## 函数\n函数也有一个类型！它们看起来像这样：\n\n```rust\nfn foo(x: i32) -> i32 { x }\n\nlet x: fn(i32) -> i32 = foo;\n```\n\n在这个例子中，`x`是一个“函数指针”，指向一个获取一个`i32`参数并返回一个`i32`值的函数。\n\n## 表达式 VS 语句\nRust 主要是一个基于表达式的语言。只有两种语句，其它的一切都是表达式。\n\n表达式返回一个值，而语句不是。这就是为什么这里我们以“不是所有控制路径都返回一个值”结束：`x + 1;`语句不返回一个值。Rust 中有两种类型的语句：“声明语句”和“表达式语句”。其余的一切是表达式。让我们先讨论下声明语句。\n\n在 Rust 中，使用`let`引入一个绑定并*不是*一个表达式。下面的代码会产生一个编译时错误：\n\n```rust\nlet x = (let y = 5); // expected identifier, found keyword `let`\n```\n\n编译器告诉我们这里它期望看到表达式的开头，而`let`只能开始一个语句，不是一个表达式。\n\n注意赋值一个已经绑定过的变量（例如，`y = 5`）仍是一个表达式，即使它的（返回）值并不是特别有用。不像其它语言中赋值语句返回它赋的值（例如，前面例子中的`5`），在 Rust 中赋值的值是一个空的元组`()`：\n\n```rust\nlet mut y = 5;\n\nlet x = (y = 6);  // x has the value `()`, not `6`\n```\n\nRust中第二种语句是*表达式语句*。它的目的是把任何表达式变为语句。在实践环境中，Rust 语法期望语句后跟其它语句。这意味着你用分号来分隔各个表达式。这意味着Rust看起来很像大部分其它使用分号做为语句结尾的语言，并且你会看到分号出现在几乎每一行你看到的 Rust 代码。\n\n那么我们说“几乎”的例外是神马呢？你已经见过它了，在这些代码中：\n\n```rust\nfn add_one(x: i32) -> i32 {\n    x + 1\n}\n```\n\n我们的函数声称它返回一个`i32`，不过带有一个分号，它会返回一个`()`。Rust意识到这可能不是我们想要的，并在我们之前看到的错误中建议我们去掉分号。\n\n## 提早返回（Early returns）\n不过提早返回,Rust确实有这么一个关键字，`return`,使用`return`作为函数的最后一行是可行的，不过被认为是一个糟糕的风格：\n\n```rust\nfn foo(x: i32) -> i32 {\n    return x;\n\n    // we never run this code!\n    x + 1\n}\n```\n\n## 发散函数（Diverging functions）\nRust有些特殊的语法叫“发散函数”，这些函数并不返回：\n\n```rust\nfn diverges() -> ! {\n    panic!(\"This function never returns!\");\n}\n```\n\n`panic!`是一个宏，类似我们已经见过的`println!()`。与`println!()`不同的是，`panic!()`导致当前的执行线程崩溃并返回指定的信息。因为这个函数会崩溃，所以它不会返回，所以它拥有一个类型`!`，它代表“发散”。\n\n如果你添加一个叫做`diverges()`的函数并运行，你将会得到一些像这样的输出：\n\n```text\nthread ‘<main>’ panicked at ‘This function never returns!’, hello.rs:2\n```\n\n如果你想要更多信息，你可以设定`RUST_BACKTRACE`环境变量来获取 backtrace ：\n\n```bash\n$ RUST_BACKTRACE=1 ./diverges\nthread '<main>' panicked at 'This function never returns!', hello.rs:2\nstack backtrace:\n   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r\n   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w\n   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw\n   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650\n   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa\n   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa\n   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231\n   8:     0x7f402773d1d8 - __rust_try\n   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w\n  10:     0x7f4027738a19 - main\n  11:     0x7f402694ab44 - __libc_start_main\n  12:     0x7f40277386c8 - <unknown>\n  13:                0x0 - <unknown>\n```\n\n`RUST_BACKTRACE`也可以用于 Cargo 的`run`命令：\n\n```bash\n$ RUST_BACKTRACE=1 cargo run\n     Running `target/debug/diverges`\nthread '<main>' panicked at 'This function never returns!', hello.rs:2\nstack backtrace:\n   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r\n   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w\n   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw\n   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650\n   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa\n   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa\n   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231\n   8:     0x7f402773d1d8 - __rust_try\n   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w\n  10:     0x7f4027738a19 - main\n  11:     0x7f402694ab44 - __libc_start_main\n  12:     0x7f40277386c8 - <unknown>\n  13:                0x0 - <unknown>\n```\n\n发散函数可以被用作任何类型：\n\n```rust\nfn diverges() -> ! {\n   panic!(\"This function never returns!\");\n}\nlet x: i32 = diverges();\nlet x: String = diverges();\n```\n\n## 函数指针\n\n我们也可以创建指向函数的变量绑定：\n\n```rust\nlet f: fn(i32) -> i32;\n```\n\n`f`是一个指向一个获取`i32`作为参数并返回`i32`的函数的变量绑定。例如：\n\n```rust\nfn plus_one(i: i32) -> i32 {\n    i + 1\n}\n\n// without type inference\nlet f: fn(i32) -> i32 = plus_one;\n\n// with type inference\nlet f = plus_one;\n```\n\n你可以用`f`来调用这个函数：\n\n```rust\n# fn plus_one(i: i32) -> i32 { i + 1 }\n# let f = plus_one;\nlet six = f(5);\n```\n## 高阶函数\n  高阶函数与普通函数的不同在于，它可以使用一个或多个函数作为参数，可以将函数作为返回值。rust的函数是first class type，所以支持高阶函数。而，由于rust是一个强类型的语言，如果要将函数作为参数或返回值，首先需要搞明白函数的类型。下面先说函数的类型，再说函数作为参数和返回值。\n\n#### 函数类型\n  前面说过，关键字`fn`可以用来定义函数。除此以外，它还用来构造函数类型。与函数定义主要的不同是，构造函数类型不需要函数名、参数名和函数体。在Rust Reference中的描述如下：\n  > The function type constructor fn forms new function types. A function type consists of a possibly-empty set of function-type modifiers (such as unsafe or extern), a sequence of input types and an output type.\n\n  来看一个简单例子：\n  ```rust\nfn inc(n: i32) -> i32 {//函数定义\n  n + 1\n}\n\ntype IncType = fn(i32) -> i32;//函数类型\n\nfn main() {\n  let func: IncType = inc;\n  println!(\"3 + 1 = {}\", func(3));\n}\n  ```\n  上例首先使用`fn`定义了`inc`函数，它有一个`i32`类型参数，返回`i32`类型的值。然后再用`fn`定义了一个函数类型，这个函数类型有i32类型的参数和i32类型的返回值，并用`type`关键字定义了它的别名`IncType`。在`main`函数中定义了一个变量`func`，其类型就为`IncType`，并赋值为`inc`，然后在`pirntln`宏中调用：`func(3)`。可以看到，`inc`函数的类型其实就是`IncType`。  \n  这里有一个问题，我们将`inc`赋值给了`func`，而不是`&inc`，这样是将`inc`函数的拥有权转给了`func`吗，赋值后还可以以`inc()`形式调用`inc`函数吗？先来看一个例子：\n  ```rust\nfn main() {\n  let func: IncType = inc;\n  println!(\"3 + 1 = {}\", func(3));\n  println!(\"3 + 1 = {}\", inc(3));\n}\n\ntype IncType = fn(i32) -> i32;\n\nfn inc(n: i32) -> i32 {\n  n + 1\n}\n  ```\n  我们将上例保存在rs源文件中，再用rustc编译，发现并没有报错，并且运行也得到我们想要的结果：\n  ```\n3 + 1 = 4\n3 + 1 = 4\n  ```\n  这说明，赋值时，`inc`函数的所有权并没有被转移到`func`变量上，而是更像不可变引用。在rust中，函数的所有权是不能转移的，我们给函数类型的变量赋值时，赋给的一般是函数的指针，所以rust中的函数类型，就像是C/C++中的函数指针，当然，rust的函数类型更安全。可见，rust的函数类型，其实应该是属于指针类型（Pointer Type）。rust的Pointer Type有两种，一种为引用（Reference`&`），另一种为原始指针（Raw pointer `*`），详细内容请看[Rust Reference 8.18 Pointer Types](http://doc.rust-lang.org/reference.html#pointer-types)。而rust的函数类型应是引用类型，因为它是安全的，而原始指针则是不安全的，要使用原始指针，必须使用`unsafe`关键字声明。\n\n#### 函数作为参数\n  函数作为参数，其声明与普通参数一样。看下例：\n  ```rust\nfn main() {\n  println!(\"3 + 1 = {}\", process(3, inc));\n  println!(\"3 - 1 = {}\", process(3, dec));\n}\n\nfn inc(n: i32) -> i32 {\n  n + 1\n}\n\nfn dec(n: i32) -> i32 {\n  n - 1\n}\n\nfn process(n: i32, func: fn(i32) -> i32) -> i32 {\n  func(n)\n}\n  ```\n  例子中，`process`就是一个高阶函数，它有两个参数，一个类型为`i32`的`n`，另一个类型为`fn(i32)->i32`的函数`func`，返回一个`i32`类型的参数；它在函数体内以`n`作为参数调用`func`函数，返回`func`函数的返回值。运行可以得到以下结果：\n  ```\n3 + 1 = 4\n3 - 1 = 2\n  ```\n  不过，这不是函数作为参数的唯一声明方法，使用泛型函数配合特质（`trait`）也是可以的，因为rust的函数都会实现一个`trait`:`FnOnce`、`Fn`或`FnMut`。将上例中的`process`函数定义换成以下形式是等价的：\n  ```rust\nfn process<F>(n: i32, func: F) -> i32\n    where F: Fn(i32) -> i32 {\n    func(n)\n}\n  ```\n\n#### 函数作为返回值\n  函数作为返回值，其生命与普通函数的返回值类型声明一样。看例子：\n  ```rust\nfn main() {\n   let a = [1,2,3,4,5,6,7];\n   let mut b = Vec::<i32>::new();\n   for i in &a {\n       b.push(get_func(*i)(*i));\n   }\n   println!(\"{:?}\", b);\n}\n\nfn get_func(n: i32) -> fn(i32) -> i32 {\n    fn inc(n: i32) -> i32 {\n        n + 1\n    }\n    fn dec(n: i32) -> i32 {\n        n - 1\n    }\n    if n % 2 == 0 {\n        inc\n    } else {\n        dec\n    }\n}\n  ```\n  例子中的高阶函数为`get_func`，它接收一个i32类型的函数，返回一个类型为`fn(i32) -> i32`的函数，若传入的参数为偶数，返回`inc`，否则返回`dec`。这里需要注意的是，`inc`函数和`dec`函数都定义在`get_func`内。在函数内定义函数在很多其他语言中是不支持的，不过rust支持，这也是rust灵活和强大的一个体现。不过，在函数中定义的函数，不能包含函数中（环境中）的变量，若要包含，应该闭包。\n\n#### 返回多个值\n\nrust的函数不支持多返回值,但是我们可以利用元组来返回多个值,配合rust的模式匹配,使用起来十分灵活。先看例子:\n```rust\nfn main() {\n    let (p2,p3) = pow_2_3(789);\n    println!(\"pow 2 of 789 is {}.\", p2);\n\tprintln!(\"pow 3 of 789 is {}.\", p3);\n}\nfn pow_2_3(n: i32) -> (i32, i32) {\n\t(n*n, n*n*n)\n}\n```\n可以看到,上例中, pow_2_3函数接收一个i32类型的值,返回其二次方和三次方的值,这两个值包装在一个元组中返回。在 main函数中, let语句就可以使用模式匹配将函数返回的元组进行解构,将这两个返回值分别赋给 p2和p3,从而可以得到 789二次方的值和三次方的值。\n\n# 二：复合类型\n\n## 1. 结构体\n\n结构体是一个创建更复杂数据类型的方法,大写字母开头并且驼峰命名法.结构体中的值默认是不可变的.\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let origin = Point { x: 0, y: 0 }; // origin: Point\n    let mut do = Point { x: 1, y: 2 };\n    do.x = 5;\n\n    println!(\"The origin is at ({}, {})\", origin.x, origin.y);\n    println!(\"The origin is at ({}, {})\", do.x, do.y);\n}\n```\n\nRust 在语言级别不支持字段可变性，可变性是绑定的一个属性，不是结构体自身的。如果你习惯于字段级别的可变性，这开始可能看起来有点奇怪，不过这样明显地简化了问题。它甚至可以让你使变量只可变一段临时时间：\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let mut point = Point { x: 0, y: 0 };\n\n    point.x = 5;\n\n    let point = point; // now immutable\n\n    point.y = 6; // this causes an error\n}\n```\n\n你的结构体仍然可以包含`&mut`指针，它会给你一些类型的可变性：\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nstruct PointRef<'a> {\n    x: &'a mut i32,\n    y: &'a mut i32,\n}\n\nfn main() {\n    let mut point = Point { x: 0, y: 0 };\n\n    {\n        let r = PointRef { x: &mut point.x, y: &mut point.y };\n\n        *r.x = 5;\n        *r.y = 6;\n    }\n\n    assert_eq!(5, point.x);\n    assert_eq!(6, point.y);\n}\n```\n\n## 更新语法（Update syntax）\n一个包含`..`的`struct`表明你想要使用一些其它结构体的拷贝的一些值。例如：\n\n```rust\nstruct Point3d {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nlet mut point = Point3d { x: 0, y: 0, z: 0 };\npoint = Point3d { y: 1, .. point };\n```\n\n这给了`point`一个新的`y`，不过保留了`x`和`z`的值。这也并不必要是同样的`struct`，你可以在创建新结构体时使用这个语法，并会拷贝你未指定的值：\n\n```rust\n# struct Point3d {\n#     x: i32,\n#     y: i32,\n#     z: i32,\n# }\nlet origin = Point3d { x: 0, y: 0, z: 0 };\nlet point = Point3d { z: 1, x: 2, .. origin };\n```\n\n## 元组结构体\nRust有像另一个[元组](Primitive Types 原生类型.md#tuples)和结构体的混合体的数据类型。元组结构体有一个名字，不过它的字段没有。他们用`struct`关键字声明，并元组前面带有一个名字：\n\n```rust\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\n//这里`black`和`origin`并不相等，即使它们有一模一样的值：\nlet black = Color(0, 0, 0);\nlet origin = Point(0, 0, 0);\n```\n\n使用结构体几乎总是好于使用元组结构体。不过有种情况元组结构体非常有用，就是当元组结构体只有一个元素时。我们管它叫*新类型*（*newtype*），因为你创建了一个与元素相似的类型：\n\n```rust\nstruct Inches(i32);\n\nlet length = Inches(10);\n\nlet Inches(integer_length) = length;\nprintln!(\"length is {} inches\", integer_length);\n```\n\n如你所见，你可以通过一个解构`let`来提取内部的整型，就像我们在讲元组时说的那样，`let Inches(integer_length)`给`integer_length`赋值为`10`。\n\n## 类单元结构体（Unit-like structs）\n你可以定义一个没有任何成员的结构体：\n\n```rust\nstruct Electron {} // Use empty braces...\nstruct Proton;     // ...or just a semicolon.\n\n// Use the same notation when creating an instance.\nlet x = Electron {};\nlet y = Proton;\n```\n\n这样的结构体叫做“类单元”因为它与一个空元组类似，`()`，这有时叫做“单元”。就像一个元组结构体，它定义了一个新类型。\n\n就它本身来看没什么用（虽然有时它可以作为一个标记类型），不过在与其它功能的结合中，它可以变得有用。例如，一个库可能请求你创建一个实现了一个特定特性的结构来处理事件。如果你并不需要在结构中存储任何数据，你可以仅仅创建一个类单元结构体。\n\n## 2. 枚举\n\nRust 中的一个`enum`是一个代表数个可能变量的数据的类型。每个变量都可选是否关联数据：\n\n```rust\nenum Message {\n    Quit,\n    ChangeColor(i32, i32, i32),\n    Move { x: i32, y: i32 },\n    Write(String),\n}\n```\n\n定义变量的语法与用来定义结构体的语法类似：你可以有不带数据的变量（像类单元结构体），带有命名数据的变量，和带有未命名数据的变量（像元组结构体）。然而，不像单独的结构体定义，一个`enum`是一个单独的类型。一个枚举的值可以匹配任何一个变量。因为这个原因，枚举有时被叫做“集合类型”：枚举可能值的集合是每一个变量可能值的集合的总和。\n\n我们使用`::`语法来使用每个变量的名字：它们包含在`enum`名字自身中。这样的话，以下的情况都是可行的：\n\n```rust\nenum Message {\n     Move { x: i32, y: i32 },\n}\nlet x: Message = Message::Move { x: 3, y: 4 };\n\nenum BoardGameTurn {\n    Move { squares: i32 },\n    Pass,\n}\n\nlet y: BoardGameTurn = BoardGameTurn::Move { squares: 1 };\n```\n\n这两个变量都叫做`Move`，不过他们包含在枚举名字中，他们可以无冲突的使用。\n\n枚举类型的一个值包含它是哪个变量的信息，以及任何与变量相关的数据。这有时被作为一个“标记的联合”被提及。因为数据包括一个“标签”表明它的类型是什么。编译器使用这个信息来确保安全的访问枚举中的数据。例如，我们不能简单的尝试解构一个枚举值，就像它是其中一个可能的变体那样：\n\n```rust\nfn process_color_change(msg: Message) {\n    let Message::ChangeColor(r, g, b) = msg; // compile-time error\n}\n```\n\n不支持这些操作（比较操作）可能看起来更像限制。不过这是一个我们可以克服的限制。有两种方法：我们自己实现相等（比较），或通过[`match` ](Match 匹配.md)表达式模式匹配变量，你会在下一部分学到它。我们还不够了解Rust如何实现相等，不过我们会在[特性](Traits.md)找到它们。\n\n## 构造器作为函数（Constructors as functions）\n一个枚举的构造器总是可以像函数一样使用。例如：\n\n```rust\nenum Message {\nWrite(String),\n}\nlet m = Message::Write(\"Hello, world\".to_string());\n```\n\n与下面是一样的：\n\n```rust\nenum Message {\nWrite(String),\n}\nfn foo(x: String) -> Message {\n    Message::Write(x)\n}\n\nlet x = foo(\"Hello, world\".to_string());\n```\n\n这对我们没有什么直接的帮助，直到我们要用到[闭包](Closures 闭包.md)时，这时我们要考虑将函数作为参数传递给其他函数。例如，使用[迭代器](Iterators 迭代器.md)，我们可以这样把一个`String`的Vector转换为一个`Message::Write`的Vector：\n\n```rust\nenum Message {\nWrite(String),\n}\n\nlet v = vec![\"Hello\".to_string(), \"World\".to_string()];\n\nlet v1: Vec<Message> = v.into_iter().map(Message::Write).collect();\n```\n\n# 三：不定长类型\n\n大部分类型有一个特定的大小，以字节为单位，它们在编译时是已知的。例如，一个`i32`是32位大，或者4个字节。然而，有些类型有益于表达，却没有一个定义的大小。它们叫做“不定长”或者“动态大小”类型。一个例子是`[T]`。这个类型代表一个特定数量`t`的序列。不过我们并不知道有多少，所以大小是未知的。\n\nRust知道几个这样的类型，不过它们有一些限制。这有三个：\n\n1. 我们只能通过指针操作一个不定长类型的实例。`&[T]`刚好能正常工作，不过`[T]`不行。一个` &[T]`能正常工作，不过一个`[T]`不行。\n2. 变量和参数不能拥有动态大小类型。\n3. 只有一个`struct`的最后一个字段可能拥有一个动态大小类型；其它字段则不可以拥有动态大小类型。枚举变量不可以用动态大小类型作为数据。\n\n所以为什么这很重要？好吧，因为`[T]`只能用在一个指针之后，如果我们没有对不定长类型的语言支持，它将不可能这么写：\n\n```rust\nimpl Foo for str {\n```\n\n或者\n\n```rust\nimpl<T> Foo for [T] {\n```\n\n相反，你将不得不这么写：\n\n```rust\nimpl Foo for &str {\n```\n\n意味深长的是，这个实现将只能用于[引用](References and Borrowing 引用和借用.md)，并且不能用于其它类型的指针。通过`impl for str`，所有指针，包括（在一些地方，这里会有bug需要修复）用户自定义的智能指针，可以使用这个`impl`。\n\n## `?Sized`\n如果你想要写一个接受动态大小类型的函数，你可以使用这个特殊的限制，`?Sized`：\n\n```rust\nstruct Foo<T: ?Sized> {\n    f: T,\n}\n```\n这个`?`，读作“`T`可能是`Sized`的”，意味着这个限制是特殊的：它让我们的匹配更宽松，而不是相反。这几乎像每个`T`都隐式拥有` T: Sized`一样，`?`放松了这个默认（限制）。\n\n# 四：关联类型\n\n关联类型是Rust类型系统中非常强大的一部分。它涉及到‘类型族’的概念，换句话说，就是把多种类型归于一类。这个描述可能比较抽象，所以让我们深入研究一个例子。如果你想编写一个`Graph`trait，你需要泛型化两个类型：点类型和边类型。所以你可能会像这样写一个trait，`Graph<N, E>`：\n\n```rust\ntrait Graph<N, E> {\n    fn has_edge(&self, &N, &N) -> bool;\n    fn edges(&self, &N) -> Vec<E>;\n    // etc\n}\n```\n\n虽然这可以工作，不过显得很尴尬，例如，任何需要一个`Graph`作为参数的函数都需要泛型化的`N`ode和`E`dge类型：\n\n```rust\nfn distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> u32 { ... }\n```\n\n我们的距离计算并不需要`Edge`类型，所以函数签名中`E`只是写着玩的。\n\n我们需要的是对于每一种`Graph`类型，都使用一个特定的的`N`ode和`E`dge类型。我们可以用关联类型来做到这一点：\n\n```rust\ntrait Graph {\n    type N;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n    // etc\n}\n```\n\n现在，我们使用一个抽象的`Graph`了：\n\n```rust\nfn distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> uint { ... }\n```\n\n这里不再需要处理`E`dge类型了。\n\n让我们更详细的回顾一下。\n\n## 定义关联类型\n让我们构建一个`Graph`trait。这里是定义：\n\n```rust\ntrait Graph {\n    type N;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n}\n```\n\n十分简单。关联类型使用`type`关键字，并出现在trait体和函数中。\n\n这些`type`声明跟函数定义一样。例如，如果我们想`N`类型实现`Display`，这样我们就可以打印出点类型，我们可以这样写：\n\n```rust\nuse std::fmt;\n\ntrait Graph {\n    type N: fmt::Display;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n}\n```\n\n## 实现关联类型\n\n就像任何 trait，使用关联类型的 trait 用`impl`关键字来提供实现。下面是一个`Graph`的简单实现：\n\n```rust\n# trait Graph {\n#     type N;\n#     type E;\n#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n# }\nstruct Node;\n\nstruct Edge;\n\nstruct MyGraph;\n\nimpl Graph for MyGraph {\n    type N = Node;\n    type E = Edge;\n\n    fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n        true\n    }\n\n    fn edges(&self, n: &Node) -> Vec<Edge> {\n        Vec::new()\n    }\n}\n```\n\n这个可笑的实现总是返回`true`和一个空的`Vec<Edge>`，不过它提供了如何实现这类 trait 的思路。首先我们需要3个`struct`，一个代表图，一个代表点，还有一个代表边。如果使用别的类型更合理，也可以那样做，我们只是准备使用`struct`来代表这 3 个类型。\n\n接下来是`impl`行，它就像其它任何 trait 的实现。\n\n在这里，我们使用`=`来定义我们的关联类型。trait 使用的名字出现在`=`的左边，而我们`impl`的具体类型出现在右边。最后，我们在函数声明中使用具体类型。\n\n## trait 对象和关联类型\n\n这里还有另外一个我们需要讨论的语法：trait对象。如果你创建一个关联类型的trait对象，像这样：\n\n```rust\n# trait Graph {\n#     type N;\n#     type E;\n#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n# }\n# struct Node;\n# struct Edge;\n# struct MyGraph;\n# impl Graph for MyGraph {\n#     type N = Node;\n#     type E = Edge;\n#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n#         true\n#     }\n#     fn edges(&self, n: &Node) -> Vec<Edge> {\n#         Vec::new()\n#     }\n# }\nlet graph = MyGraph;\nlet obj = Box::new(graph) as Box<Graph>;\n```\n\n你会得到两个错误：\n\n```text\nerror: the value of the associated type `E` (from the trait `main::Graph`) must\nbe specified [E0191]\nlet obj = Box::new(graph) as Box<Graph>;\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n24:44 error: the value of the associated type `N` (from the trait\n`main::Graph`) must be specified [E0191]\nlet obj = Box::new(graph) as Box<Graph>;\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n```\n\n我们不能这样创建一个trait对象，因为我们并不知道关联的类型。相反，我们可以这样写：\n\n```rust\n# trait Graph {\n#     type N;\n#     type E;\n#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n# }\n# struct Node;\n# struct Edge;\n# struct MyGraph;\n# impl Graph for MyGraph {\n#     type N = Node;\n#     type E = Edge;\n#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n#         true\n#     }\n#     fn edges(&self, n: &Node) -> Vec<Edge> {\n#         Vec::new()\n#     }\n# }\nlet graph = MyGraph;\nlet obj = Box::new(graph) as Box<Graph<N=Node, E=Edge>>;\n```\n\n`N=Node`语法允许我们提供一个具体类型，`Node`，作为`N`类型参数。`E=Edge`也是一样。如果我们不提供这个限制，我们不能确定应该`impl`那个来匹配trait对象。\n\n\n\n关联类型是Rust类型系统中非常强大的一部分。它涉及到‘类型族’的概念，换句话说，就是把多种类型归于一类。这个描述可能比较抽象，所以让我们深入研究一个例子。如果你想编写一个`Graph`trait，你需要泛型化两个类型：点类型和边类型。所以你可能会像这样写一个trait，`Graph<N, E>`：\n\n```rust\ntrait Graph<N, E> {\n    fn has_edge(&self, &N, &N) -> bool;\n    fn edges(&self, &N) -> Vec<E>;\n    // etc\n}\n```\n\n虽然这可以工作，不过显得很尴尬，例如，任何需要一个`Graph`作为参数的函数都需要泛型化的`N`ode和`E`dge类型：\n\n```rust\nfn distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> u32 { ... }\n```\n\n我们的距离计算并不需要`Edge`类型，所以函数签名中`E`只是写着玩的。\n\n我们需要的是对于每一种`Graph`类型，都使用一个特定的的`N`ode和`E`dge类型。我们可以用关联类型来做到这一点：\n\n```rust\ntrait Graph {\n    type N;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n    // etc\n}\n```\n\n现在，我们使用一个抽象的`Graph`了：\n\n```rust\nfn distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> uint { ... }\n```\n\n这里不再需要处理`E`dge类型了。\n\n让我们更详细的回顾一下。\n\n## 定义关联类型\n让我们构建一个`Graph`trait。这里是定义：\n\n```rust\ntrait Graph {\n    type N;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n}\n```\n\n十分简单。关联类型使用`type`关键字，并出现在trait体和函数中。\n\n这些`type`声明跟函数定义一样。例如，如果我们想`N`类型实现`Display`，这样我们就可以打印出点类型，我们可以这样写：\n\n```rust\nuse std::fmt;\n\ntrait Graph {\n    type N: fmt::Display;\n    type E;\n\n    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n    fn edges(&self, &Self::N) -> Vec<Self::E>;\n}\n```\n\n## 实现关联类型\n\n就像任何 trait，使用关联类型的 trait 用`impl`关键字来提供实现。下面是一个`Graph`的简单实现：\n\n```rust\n# trait Graph {\n#     type N;\n#     type E;\n#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n# }\nstruct Node;\n\nstruct Edge;\n\nstruct MyGraph;\n\nimpl Graph for MyGraph {\n    type N = Node;\n    type E = Edge;\n\n    fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n        true\n    }\n\n    fn edges(&self, n: &Node) -> Vec<Edge> {\n        Vec::new()\n    }\n}\n```\n\n这个可笑的实现总是返回`true`和一个空的`Vec<Edge>`，不过它提供了如何实现这类 trait 的思路。首先我们需要3个`struct`，一个代表图，一个代表点，还有一个代表边。如果使用别的类型更合理，也可以那样做，我们只是准备使用`struct`来代表这 3 个类型。\n\n接下来是`impl`行，它就像其它任何 trait 的实现。\n\n在这里，我们使用`=`来定义我们的关联类型。trait 使用的名字出现在`=`的左边，而我们`impl`的具体类型出现在右边。最后，我们在函数声明中使用具体类型。\n\n## trait 对象和关联类型\n\n这里还有另外一个我们需要讨论的语法：trait对象。如果你创建一个关联类型的trait对象，像这样：\n\n```rust\n# trait Graph {\n#     type N;\n#     type E;\n#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n# }\n# struct Node;\n# struct Edge;\n# struct MyGraph;\n# impl Graph for MyGraph {\n#     type N = Node;\n#     type E = Edge;\n#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n#         true\n#     }\n#     fn edges(&self, n: &Node) -> Vec<Edge> {\n#         Vec::new()\n#     }\n# }\nlet graph = MyGraph;\nlet obj = Box::new(graph) as Box<Graph>;\n```\n\n你会得到两个错误：\n\n```text\nerror: the value of the associated type `E` (from the trait `main::Graph`) must\nbe specified [E0191]\nlet obj = Box::new(graph) as Box<Graph>;\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n24:44 error: the value of the associated type `N` (from the trait\n`main::Graph`) must be specified [E0191]\nlet obj = Box::new(graph) as Box<Graph>;\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n```\n\n我们不能这样创建一个trait对象，因为我们并不知道关联的类型。相反，我们可以这样写：\n\n```rust\n# trait Graph {\n#     type N;\n#     type E;\n#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n# }\n# struct Node;\n# struct Edge;\n# struct MyGraph;\n# impl Graph for MyGraph {\n#     type N = Node;\n#     type E = Edge;\n#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n#         true\n#     }\n#     fn edges(&self, n: &Node) -> Vec<Edge> {\n#         Vec::new()\n#     }\n# }\nlet graph = MyGraph;\nlet obj = Box::new(graph) as Box<Graph<N=Node, E=Edge>>;\n```\n\n`N=Node`语法允许我们提供一个具体类型，`Node`，作为`N`类型参数。`E=Edge`也是一样。如果我们不提供这个限制，我们不能确定应该`impl`那个来匹配trait对象。\n\n# 类型别名\n\n## \\`type\\`别名\n\n\n`type`关键字让你定义另一个类型的别名：\n\n```rust\ntype Name = String;\n```\n\n你可以像一个真正类型那样使用这个类型：\n\n```rust\ntype Name = String;\n\nlet x: Name = \"Hello\".to_string();\n```\n\n然而要注意的是，这一个*别名*，完全不是一个新的类型。换句话说，因为Rust是强类型的，你可以预期两个不同类型的比较会失败：\n\n```rust\nlet x: i32 = 5;\nlet y: i64 = 5;\n\nif x == y {\n   // ...\n}\n```\n\n这给出\n\n```text\nerror: mismatched types:\n expected `i32`,\n    found `i64`\n(expected i32,\n    found i64) [E0308]\n     if x == y {\n             ^\n```\n\n不过，如果我们有一个别名：\n\n```rust\ntype Num = i32;\n\nlet x: i32 = 5;\nlet y: Num = 5;\n\nif x == y {\n   // ...\n}\n```\n\n这会无错误的编译。从任何角度来说，`Num`类型的值与`i32`类型的值都是一样的。\n\n你也可以在泛型中使用类型别名：\n\n```rust\nuse std::result;\n\nenum ConcreteError {\n    Foo,\n    Bar,\n}\n\ntype Result<T> = result::Result<T, ConcreteError>;\n```\n\n这创建了一个特定版本的`Result`类型，它总是有一个`ConcreteError`作为`Result<T, E>`的`E`那部分。这通常用于标准库中创建每个子部分的自定义错误。例如，[`io::Result`](http://doc.rust-lang.org/nightly/std/io/type.Result.html)。\n","slug":"Rust数据类型详解","published":1,"updated":"2017-07-09T09:50:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8dw0nfr0008qnjxcpswc6k7","content":"<h1 id=\"一：原生类型\"><a href=\"#一：原生类型\" class=\"headerlink\" title=\"一：原生类型\"></a>一：原生类型</h1><ul>\n<li>布尔类型（bool）：有两个值true和false。</li>\n<li>字符类型 (char)：表示单个Unicode值，存储为4个字节。Rust支持(u8)单字节字符b’H’,仅限制于ASCII字符。</li>\n<li>数值类型 (int/float)：有符号整数 (i8,i16,i32,i64,isize)、无符号整数 (u8,u16,u32,u64,usize) 浮点数(f32,f64).整形默认为i32，浮点型默认为f64.</li>\n<li>字符串类型(str)：Unicode string slices.分为字符串切片&amp;str和堆分配字符串String，字符串切片是静态分配，有固定大小，且不可变，堆分配字符串是可变的。Rust还支持单字节字符串b”Hello”和原始字节字符串使用br#”hello”#，仅限于ASCII字符,不需要对特殊字符进行转义。</li>\n<li>指针 ( pointer )：最底层的是裸指针*const T和*mut T，但解引用它们是不安全的，必须放到unsafe块里。</li>\n<li>函数 ( fn )：具有函数类型的变量实质上是一个函数指针。</li>\n<li>元类型：即()，其唯一的值也是()。</li>\n</ul>\n<h1 id=\"二：复合类型\"><a href=\"#二：复合类型\" class=\"headerlink\" title=\"二：复合类型\"></a>二：复合类型</h1><ul>\n<li>数组  ( array )：具有固定大小，并且元素都是同种类型，表示[T; N]，标准库动态的数组即向量 Vec。不多于32个元素的数组在值传递时是自动复制的.数组切片(&amp;[T])：一个数组引用部分数据并且不需要拷贝，可表示为&amp;[T]。</li>\n<li>元组  ( tuple )：固定大小的有序列表，每个元素都有自己的类型，通过解构或者索引来获得元素的值。可使用==和!=运算符来判断是否相同，不多于12个元素的元组在值传递时是自动复制的。</li>\n</ul>\n<h1 id=\"三：自定义类型\"><a href=\"#三：自定义类型\" class=\"headerlink\" title=\"三：自定义类型\"></a>三：自定义类型</h1><ul>\n<li>结构体(struct) : </li>\n<li>枚举(enum) : </li>\n</ul>\n<h1 id=\"四：标准库数据类型\"><a href=\"#四：标准库数据类型\" class=\"headerlink\" title=\"四：标准库数据类型\"></a>四：标准库数据类型</h1><ul>\n<li>String : A UTF-8 encoded, growable string.</li>\n<li>Box : </li>\n<li>Sequences: Vec, VecDeque, LinkedList</li>\n<li>Maps: HashMap, BTreeMap</li>\n<li>Sets: HashSet, BTreeSet</li>\n<li>Misc: BinaryHeap</li>\n</ul>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>一个<em>字符串</em>是一串UTF-8字节编码的Unicode量级值的序列。所有的字符串都确保是有效编码的UTF-8序列。另外，字符串并不以null结尾并且可以包含null字节。Rust有两种主要的字符串类型：<code>&amp;str</code>和<code>String</code>。让我们先看看<code>&amp;str</code>。这叫做<em>字符串片段</em>（<em>string slices</em>）。字符串常量是<code>&amp;&#39;static str</code>类型的：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> greeting = <span class=\"string\">\"Hello there.\"</span>; <span class=\"comment\">// greeting: &amp;'static str</span></div></pre></td></tr></table></figure>\n<p><code>&quot;Hello there.&quot;</code>是一个字符串常量而它的类型是<code>&amp;&#39;static str</code>。字符串常量是静态分配的字符串切片，也就是说它储存在我们编译好的程序中，并且整个程序的运行过程中一直存在。这个<code>greeting</code>绑定了一个静态分配的字符串的引用。任何接受一个字符串切片的函数也接受一个字符串常量。</p>\n<p>字符串常量可以跨多行。有两种形式。第一种会包含新行符和之前的空格：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let s = \"foo</div><div class=\"line\">    bar\";</div><div class=\"line\"></div><div class=\"line\">assert_eq!(\"foo\\n        bar\", s);</div></pre></td></tr></table></figure>\n<p>第二种，带有<code>\\</code>，会去掉空格和新行符：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">\"foo\\</span></div><div class=\"line\">    bar\";</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">assert_eq!</span>(<span class=\"string\">\"foobar\"</span>, s);</div></pre></td></tr></table></figure>\n<p>Rust 当然不仅仅只有<code>&amp;str</code>。一个<code>String</code>，是一个在堆上分配的字符串。这个字符串可以增长，并且也保证是UTF-8编码的。<code>String</code>通常通过一个字符串片段调用<code>to_string</code>方法转换而来。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> s = <span class=\"string\">\"Hello\"</span>.to_string(); <span class=\"comment\">// mut s: String</span></div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"&#123;&#125;\"</span>, s);</div><div class=\"line\"></div><div class=\"line\">s.push_str(<span class=\"string\">\", world.\"</span>);</div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"&#123;&#125;\"</span>, s);</div></pre></td></tr></table></figure>\n<p><code>String</code>可以通过一个<code>&amp;</code>强制转换为<code>&amp;str</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">takes_slice</span></span>(slice: &amp;<span class=\"built_in\">str</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"Got: &#123;&#125;\"</span>, slice);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">\"Hello\"</span>.to_string();</div><div class=\"line\">    takes_slice(&amp;s);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种强制转换并不发生在接受<code>&amp;str</code>的trait而不是<code>&amp;str</code>本身作为参数的函数上。例如，<a href=\"http://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.connect\" target=\"_blank\" rel=\"external\">TcpStream::connect</a>，有一个<code>ToSocketAddrs</code>类型的参数。<code>&amp;str</code>可以不用转换不过<code>String</code>必须使用<code>&amp;*</code>显式转换。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">use</span> std::net::TcpStream;</div><div class=\"line\"></div><div class=\"line\">TcpStream::connect(<span class=\"string\">\"192.168.0.1:3000\"</span>); <span class=\"comment\">// &amp;str parameter</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> addr_string = <span class=\"string\">\"192.168.0.1:3000\"</span>.to_string();</div><div class=\"line\">TcpStream::connect(&amp;*addr_string); <span class=\"comment\">// convert addr_string to &amp;str</span></div></pre></td></tr></table></figure>\n<p>把<code>String</code>转换为<code>&amp;str</code>的代价很小，不过从<code>&amp;str</code>转换到<code>String</code>涉及到分配内存。除非必要，没有理由这样做！</p>\n<h2 id=\"索引（Indexing）\"><a href=\"#索引（Indexing）\" class=\"headerlink\" title=\"索引（Indexing）\"></a>索引（Indexing）</h2><p>因为字符串是有效UTF-8编码的，它不支持索引：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">\"hello\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"The first letter of s is &#123;&#125;\"</span>, s[<span class=\"number\">0</span>]); <span class=\"comment\">// ERROR!!!</span></div></pre></td></tr></table></figure>\n<p>通常，用<code>[]</code>访问一个数组是非常快的。不过，字符串中每个UTF-8编码的字符可以是多个字节，你必须遍历字符串来找到字符串的第N个字符。这个操作的代价相当高，而且我们不想误导读者。更进一步来讲，Unicode实际上并没有定义什么“字符”。我们可以选择把字符串看作一个串独立的字节，或者代码点（codepoints）：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> hachiko = <span class=\"string\">\"忠犬ハチ公\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> hachiko.as_bytes() &#123;</div><div class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">\"&#123;&#125;, \"</span>, b);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> hachiko.chars() &#123;</div><div class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">\"&#123;&#125;, \"</span>, c);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"\"</span>);</div></pre></td></tr></table></figure>\n<p>这会打印出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,</div><div class=\"line\">忠, 犬, ハ, チ, 公,</div></pre></td></tr></table></figure>\n<p>如你所见，这有比<code>char</code>更多的字节。</p>\n<p>你可以这样来获取跟索引相似的东西：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"keyword\">let</span> hachiko = <span class=\"string\">\"忠犬ハチ公\"</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> dog = hachiko.chars().nth(<span class=\"number\">1</span>); <span class=\"comment\">// kinda like hachiko[1]</span></div></pre></td></tr></table></figure>\n<p>这强调了我们不得不遍历整个<code>char</code>的列表。</p>\n<p>你可以使用切片语法来获取一个字符串的切片：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"string\">\"hachiko\"</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> hachi = &amp;dog[<span class=\"number\">0</span>..<span class=\"number\">5</span>];</div></pre></td></tr></table></figure>\n<p>注意这里是<em>字节</em>偏移，而不是<em>字符</em>偏移。所以如下代码在运行时会失败：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"string\">\"忠犬ハチ公\"</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> hachi = &amp;dog[<span class=\"number\">0</span>..<span class=\"number\">2</span>];</div></pre></td></tr></table></figure>\n<p>给出如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">thread &apos;&lt;main&gt;&apos; panicked at &apos;index 0 and/or 2 in `忠犬ハチ公` do not lie on</div><div class=\"line\">character boundary&apos;</div></pre></td></tr></table></figure>\n<h3 id=\"拼接字符串：-结果是String\"><a href=\"#拼接字符串：-结果是String\" class=\"headerlink\" title=\"拼接字符串：(结果是String)\"></a>拼接字符串：(结果是String)</h3><ol>\n<li>&amp;str不能直接拼接，</li>\n<li>拼接的首个字符串必须是String，之后的String需要一个 &amp; 转换成 &amp;str，这个功能叫做 Deref  转换。</li>\n<li>满足1，2条件的String与&amp;str可以多个交叉拼接。</li>\n</ol>\n<p>这是因为<code>&amp;String</code>可以自动转换为一个<code>&amp;str</code>。这个功能叫做<strong> <code>Deref</code>转换</strong>。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span>    hello      =  <span class=\"string\">\"Hello\"</span>.to_string();        <span class=\"comment\">// String</span></div><div class=\"line\"><span class=\"keyword\">let</span>    hello_str  =  <span class=\"string\">\"Hello!\"</span>;                 <span class=\"comment\">// &amp;'static str</span></div><div class=\"line\"><span class=\"keyword\">let</span>    world      =  <span class=\"string\">\"World!\"</span>.to_string();      </div><div class=\"line\"><span class=\"keyword\">let</span>    world_str  =  <span class=\"string\">\"World!\"</span>;             </div><div class=\"line\"><span class=\"keyword\">let</span>    tom        =  <span class=\"string\">\"tom!\"</span>.to_string();  </div><div class=\"line\"><span class=\"keyword\">let</span>    tom_str    =  <span class=\"string\">\"tom!\"</span>;</div><div class=\"line\"><span class=\"keyword\">let</span>    lucy       =  <span class=\"string\">\"lucy!\"</span>.to_string();  </div><div class=\"line\"><span class=\"keyword\">let</span>    lucy_str   =  <span class=\"string\">\"lucy!\"</span>;</div><div class=\"line\"><span class=\"keyword\">let</span>    lilei      =  <span class=\"string\">\"lilei!\"</span>.to_string();  </div><div class=\"line\"><span class=\"keyword\">let</span>    lilei_str  =  <span class=\"string\">\"lilei!\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span>    hello_world  =  hello + world_str;</div><div class=\"line\"><span class=\"keyword\">let</span>    hello_world  =  hello + &amp;world;</div><div class=\"line\"><span class=\"keyword\">let</span>    hello_world  =  hello + world_str + tom_str + lucy_str;</div><div class=\"line\"><span class=\"keyword\">let</span>    hello_world  =  hello + &amp;world + &amp;tom + &amp;lucy;</div><div class=\"line\"><span class=\"keyword\">let</span>    hello_world  =  hello + hello_str + &amp;world + world_str + tom_str + &amp;tom + &amp;lucy + &amp;lilei + lucy_str + lilei_str;</div></pre></td></tr></table></figure>\n<h2 id=\"元组（Tuples）\"><a href=\"#元组（Tuples）\" class=\"headerlink\" title=\"元组（Tuples）\"></a>元组（Tuples）</h2><p>元组（tuples）是固定大小的有序列表。如下：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> x = (<span class=\"number\">1</span>, <span class=\"string\">\"hello\"</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> x: (<span class=\"built_in\">i32</span>, &amp;<span class=\"built_in\">str</span>) = (<span class=\"number\">1</span>, <span class=\"string\">\"hello\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> x = (<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// x: (i32, i32)</span></div><div class=\"line\"><span class=\"keyword\">let</span> y = (<span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// y: (i32, i32)</span></div><div class=\"line\"><span class=\"keyword\">let</span>\te\t=\tx.<span class=\"number\">1</span>;</div><div class=\"line\">x = y;</div></pre></td></tr></table></figure>\n<p>你可以通过一个<em>解构let</em>（<em>destructuring let</em>）访问元组中的字段。下面是一个例子：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> (x, y, z) = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"x is &#123;&#125;\"</span>, x);</div></pre></td></tr></table></figure>\n<p>可以在<code>let</code>左侧写一个模式，如果它能匹配右侧的话，我们可以一次写多个绑定。这种情况下，<code>let</code>“解构”或“拆开”了元组，并分成了三个绑定。</p>\n<p>你可以一个逗号来消除一个单元素元组和一个括号中的值的歧义：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"number\">0</span>,); <span class=\"comment\">// single-element tuple</span></div><div class=\"line\">(<span class=\"number\">0</span>); <span class=\"comment\">// zero</span></div></pre></td></tr></table></figure>\n<h3 id=\"元组索引（Tuple-Indexing）\"><a href=\"#元组索引（Tuple-Indexing）\" class=\"headerlink\" title=\"元组索引（Tuple Indexing）\"></a>元组索引（Tuple Indexing）</h3><p>你也可以用索引语法访问一个元组的字段,它使用<code>.</code></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> tuple = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> x = tuple.<span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"x is &#123;&#125;\"</span>, x);</div></pre></td></tr></table></figure>\n<h3 id=\"数组-array-与Vec\"><a href=\"#数组-array-与Vec\" class=\"headerlink\" title=\"数组(array)与Vec\"></a>数组(array)与Vec</h3><p><strong>定义数组</strong>：<br><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> array: [<span class=\"built_in\">i32</span>; <span class=\"number\">3</span>] = [<span class=\"number\">0</span>; <span class=\"number\">3</span>];   <span class=\"comment\">// 方式一</span></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">8</span>,\t<span class=\"number\">9</span>,\t<span class=\"number\">10</span>];            <span class=\"comment\">// 方式二</span></div><div class=\"line\">array[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">array[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">assert_eq!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>], &amp;array[<span class=\"number\">1</span>..]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// This loop prints: 0 1 2</span></div><div class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> &amp;array &#123;</div><div class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">\"&#123;&#125; \"</span>, x);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> Vec : pronounced ‘Vector’是一个动态或“可增长”的数组，被实现为标准库类型<a href=\"http://doc.rust-lang.org/std/Vec/\" target=\"_blank\" rel=\"external\"><code>Vec&lt;T&gt;</code></a>（其中<code>&lt;T&gt;</code>是一个<a href=\"Generics 泛型.md\">泛型</a>语句）。Vec总是在堆上分配数据。Vec与数组切片就像<code>String</code>与<code>&amp;str</code>一样。你可以使用<code>vec!</code>宏来创建它：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> v1: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; = <span class=\"built_in\">Vec</span>::new();    <span class=\"comment\">// 方式一</span></div><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];    <span class=\"comment\">// v: Vec&lt;i32&gt;   方式二</span></div><div class=\"line\"><span class=\"keyword\">let</span>\tv2 = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>;<span class=\"number\">10</span>];\t        <span class=\"comment\">//\t声明一个初始长度为10的值全为0的动态数组</span></div></pre></td></tr></table></figure>\n<p>（与我们之前使用<code>println!</code>宏时不一样，我们在<code>vec!</code>中使用中括号<code>[]</code>。为了方便，Rust 允许你使用上述各种情况。）</p>\n<p>对于重复初始值有另一种形式的<code>vec!</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">10</span>]; <span class=\"comment\">// ten zeroes</span></div></pre></td></tr></table></figure>\n<h4 id=\"访问元素\"><a href=\"#访问元素\" class=\"headerlink\" title=\"访问元素\"></a>访问元素</h4><p>为了Vec特定索引的值，我们使用<code>[]</code>,索引从<code>0</code>开始，所以第3个元素是<code>v[2]</code>.</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> r0 = v[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> r1 = &amp;v[<span class=\"number\">2</span>];             <span class=\"comment\">//当引用一个不存在的元素时，会造成panic!.</span></div><div class=\"line\"><span class=\"keyword\">let</span> r2 = v.get(<span class=\"number\">3</span>);           <span class=\"comment\">//当引用一个不存在的元素时，返回None.</span></div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"The third element of v is&#123;&#125;, &#123;&#125;,&#123;&#125;\"</span>, r0, r1,r2);</div></pre></td></tr></table></figure>\n<p>另外值得注意的是你必须用<code>usize</code>类型的值来索引：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> i: <span class=\"built_in\">usize</span> = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> j: <span class=\"built_in\">i32</span> = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// works</span></div><div class=\"line\">v[i];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// doesn’t</span></div><div class=\"line\">v[j];</div></pre></td></tr></table></figure>\n<p>用非<code>usize</code>类型索引的话会给出类似如下的错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">error: the trait `core::ops::Index&lt;i32&gt;` is not implemented for the type</div><div class=\"line\">`collections::Vec::Vec&lt;_&gt;` [E0277]</div><div class=\"line\">v[j];</div><div class=\"line\">^~~~</div><div class=\"line\">note: the type `collections::Vec::Vec&lt;_&gt;` cannot be indexed by `i32`</div><div class=\"line\">error: aborting due to previous error</div></pre></td></tr></table></figure>\n<p>信息中有很多标点符号，不过核心意思是：你不能用<code>i32</code>来索引。</p>\n<h4 id=\"越界访问（Out-of-bounds-Access）\"><a href=\"#越界访问（Out-of-bounds-Access）\" class=\"headerlink\" title=\"越界访问（Out-of-bounds Access）\"></a>越界访问（Out-of-bounds Access）</h4><p>如果你尝试访问并不存在的索引：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"Item 7 is &#123;&#125;\"</span>, v[<span class=\"number\">7</span>]);</div></pre></td></tr></table></figure>\n<p>那么当前的线程会<strong>panic</strong>并输出如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">thread &apos;&lt;main&gt;&apos; panicked at &apos;index out of bounds: the len is 3 but the index is 7&apos;</div></pre></td></tr></table></figure>\n<p>如果你想处理越界错误而不是 panic，你可以使用像<a href=\"http://doc.rust-lang.org/std/Vec/struct.Vec.html#method.get\" target=\"_blank\" rel=\"external\"><code>get</code></a>或<a href=\"http://doc.rust-lang.org/std/Vec/struct.Vec.html#method.get\" target=\"_blank\" rel=\"external\"><code>get_mut</code></a>这样的方法，他们当给出一个无效的索引时返回<code>None</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"keyword\">match</span> v.get(<span class=\"number\">7</span>) &#123;</div><div class=\"line\">    <span class=\"literal\">Some</span>(x) =&gt; <span class=\"built_in\">println!</span>(<span class=\"string\">\"Item 7 is &#123;&#125;\"</span>, x),</div><div class=\"line\">    <span class=\"literal\">None</span> =&gt; <span class=\"built_in\">println!</span>(<span class=\"string\">\"Sorry, this Vector is too short.\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用枚举来储存多种类型<br><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SpreadsheetCell</span></span> &#123;</div><div class=\"line\">    Int(<span class=\"built_in\">i32</span>),</div><div class=\"line\">    Float(<span class=\"built_in\">f64</span>),</div><div class=\"line\">    Text(<span class=\"built_in\">String</span>),</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> row = <span class=\"built_in\">vec!</span>[</div><div class=\"line\">    SpreadsheetCell::Int(<span class=\"number\">3</span>),</div><div class=\"line\">    SpreadsheetCell::Text(<span class=\"built_in\">String</span>::from(<span class=\"string\">\"blue\"</span>)),</div><div class=\"line\">    SpreadsheetCell::Float(<span class=\"number\">10.12</span>),</div><div class=\"line\">];</div></pre></td></tr></table></figure></p>\n<h4 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h4><p>当你有了一个Vector，我可以用<code>for</code>来迭代它的元素。有3个版本：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &amp;v &#123;</div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"A reference to &#123;&#125;\"</span>, i);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &amp;<span class=\"keyword\">mut</span> v &#123;</div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"A mutable reference to &#123;&#125;\"</span>, i);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> v &#123;</div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"Take ownership of the Vector and its element &#123;&#125;\"</span>, i);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Vector还有很多有用的方法，你可以看看<a href=\"http://doc.rust-lang.org/nightly/std/Vec/\" target=\"_blank\" rel=\"external\">Vector的API文档</a>了解它们。</p>\n<h2 id=\"数组切片（Slices）\"><a href=\"#数组切片（Slices）\" class=\"headerlink\" title=\"数组切片（Slices）\"></a>数组切片（Slices）</h2><p>一个<em>切片</em>（<em>slice</em>）是一个数组的引用（或者“视图”）。它有利于安全，有效的访问数组的一部分而不用进行拷贝。比如，你可能只想要引用读入到内存的文件中的一行。原理上，片段并不是直接创建的，而是引用一个已经存在的变量。片段有预定义的长度，可以是可变也可以是不可变的。</p>\n<h3 id=\"切片语法\"><a href=\"#切片语法\" class=\"headerlink\" title=\"切片语法\"></a>切片语法</h3><p>你可以用一个<code>&amp;</code>和<code>[]</code>的组合从多种数据类型创建一个切片。<code>&amp;</code>表明切片类似于<strong>引用</strong>，带有一个范围的<code>[]</code>，允许你定义切片的长度：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> complete = &amp;a[..]; <span class=\"comment\">// A slice containing all of the elements in a</span></div><div class=\"line\"><span class=\"keyword\">let</span> middle = &amp;a[<span class=\"number\">1</span>..<span class=\"number\">4</span>]; <span class=\"comment\">// A slice of a: just the elements 1, 2, and 3</span></div></pre></td></tr></table></figure>\n<p>片段拥有<code>&amp;[T]</code>类型。当我们涉及到<strong>泛型</strong>时会讨论这个<code>T</code>。</p>\n<p>你可以在<a href=\"http://doc.rust-lang.org/stable/std/primitive.slice.html\" target=\"_blank\" rel=\"external\">标准库文档</a>中找到更多关于<code>slices</code>的文档。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>函数也有一个类型！它们看起来像这样：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">foo</span></span>(x: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123; x &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> x: <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> = foo;</div></pre></td></tr></table></figure>\n<p>在这个例子中，<code>x</code>是一个“函数指针”，指向一个获取一个<code>i32</code>参数并返回一个<code>i32</code>值的函数。</p>\n<h2 id=\"表达式-VS-语句\"><a href=\"#表达式-VS-语句\" class=\"headerlink\" title=\"表达式 VS 语句\"></a>表达式 VS 语句</h2><p>Rust 主要是一个基于表达式的语言。只有两种语句，其它的一切都是表达式。</p>\n<p>表达式返回一个值，而语句不是。这就是为什么这里我们以“不是所有控制路径都返回一个值”结束：<code>x + 1;</code>语句不返回一个值。Rust 中有两种类型的语句：“声明语句”和“表达式语句”。其余的一切是表达式。让我们先讨论下声明语句。</p>\n<p>在 Rust 中，使用<code>let</code>引入一个绑定并<em>不是</em>一个表达式。下面的代码会产生一个编译时错误：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> x = (<span class=\"keyword\">let</span> y = <span class=\"number\">5</span>); <span class=\"comment\">// expected identifier, found keyword `let`</span></div></pre></td></tr></table></figure>\n<p>编译器告诉我们这里它期望看到表达式的开头，而<code>let</code>只能开始一个语句，不是一个表达式。</p>\n<p>注意赋值一个已经绑定过的变量（例如，<code>y = 5</code>）仍是一个表达式，即使它的（返回）值并不是特别有用。不像其它语言中赋值语句返回它赋的值（例如，前面例子中的<code>5</code>），在 Rust 中赋值的值是一个空的元组<code>()</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> y = <span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> x = (y = <span class=\"number\">6</span>);  <span class=\"comment\">// x has the value `()`, not `6`</span></div></pre></td></tr></table></figure>\n<p>Rust中第二种语句是<em>表达式语句</em>。它的目的是把任何表达式变为语句。在实践环境中，Rust 语法期望语句后跟其它语句。这意味着你用分号来分隔各个表达式。这意味着Rust看起来很像大部分其它使用分号做为语句结尾的语言，并且你会看到分号出现在几乎每一行你看到的 Rust 代码。</p>\n<p>那么我们说“几乎”的例外是神马呢？你已经见过它了，在这些代码中：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add_one</span></span>(x: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">    x + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们的函数声称它返回一个<code>i32</code>，不过带有一个分号，它会返回一个<code>()</code>。Rust意识到这可能不是我们想要的，并在我们之前看到的错误中建议我们去掉分号。</p>\n<h2 id=\"提早返回（Early-returns）\"><a href=\"#提早返回（Early-returns）\" class=\"headerlink\" title=\"提早返回（Early returns）\"></a>提早返回（Early returns）</h2><p>不过提早返回,Rust确实有这么一个关键字，<code>return</code>,使用<code>return</code>作为函数的最后一行是可行的，不过被认为是一个糟糕的风格：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">foo</span></span>(x: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// we never run this code!</span></div><div class=\"line\">    x + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"发散函数（Diverging-functions）\"><a href=\"#发散函数（Diverging-functions）\" class=\"headerlink\" title=\"发散函数（Diverging functions）\"></a>发散函数（Diverging functions）</h2><p>Rust有些特殊的语法叫“发散函数”，这些函数并不返回：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">diverges</span></span>() -&gt; ! &#123;</div><div class=\"line\">    <span class=\"built_in\">panic!</span>(<span class=\"string\">\"This function never returns!\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>panic!</code>是一个宏，类似我们已经见过的<code>println!()</code>。与<code>println!()</code>不同的是，<code>panic!()</code>导致当前的执行线程崩溃并返回指定的信息。因为这个函数会崩溃，所以它不会返回，所以它拥有一个类型<code>!</code>，它代表“发散”。</p>\n<p>如果你添加一个叫做<code>diverges()</code>的函数并运行，你将会得到一些像这样的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">thread ‘&lt;main&gt;’ panicked at ‘This function never returns!’, hello.rs:2</div></pre></td></tr></table></figure>\n<p>如果你想要更多信息，你可以设定<code>RUST_BACKTRACE</code>环境变量来获取 backtrace ：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ RUST_BACKTRACE=1 ./diverges</div><div class=\"line\">thread <span class=\"string\">'&lt;main&gt;'</span> panicked at <span class=\"string\">'This function never returns!'</span>, hello.rs:2</div><div class=\"line\">stack backtrace:</div><div class=\"line\">   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r</div><div class=\"line\">   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w</div><div class=\"line\">   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw</div><div class=\"line\">   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650</div><div class=\"line\">   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa</div><div class=\"line\">   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa</div><div class=\"line\">   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231</div><div class=\"line\">   8:     0x7f402773d1d8 - __rust_try</div><div class=\"line\">   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w</div><div class=\"line\">  10:     0x7f4027738a19 - main</div><div class=\"line\">  11:     0x7f402694ab44 - __libc_start_main</div><div class=\"line\">  12:     0x7f40277386c8 - &lt;unknown&gt;</div><div class=\"line\">  13:                0x0 - &lt;unknown&gt;</div></pre></td></tr></table></figure>\n<p><code>RUST_BACKTRACE</code>也可以用于 Cargo 的<code>run</code>命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ RUST_BACKTRACE=1 cargo run</div><div class=\"line\">     Running `target/debug/diverges`</div><div class=\"line\">thread <span class=\"string\">'&lt;main&gt;'</span> panicked at <span class=\"string\">'This function never returns!'</span>, hello.rs:2</div><div class=\"line\">stack backtrace:</div><div class=\"line\">   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r</div><div class=\"line\">   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w</div><div class=\"line\">   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw</div><div class=\"line\">   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650</div><div class=\"line\">   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa</div><div class=\"line\">   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa</div><div class=\"line\">   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231</div><div class=\"line\">   8:     0x7f402773d1d8 - __rust_try</div><div class=\"line\">   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w</div><div class=\"line\">  10:     0x7f4027738a19 - main</div><div class=\"line\">  11:     0x7f402694ab44 - __libc_start_main</div><div class=\"line\">  12:     0x7f40277386c8 - &lt;unknown&gt;</div><div class=\"line\">  13:                0x0 - &lt;unknown&gt;</div></pre></td></tr></table></figure>\n<p>发散函数可以被用作任何类型：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">diverges</span></span>() -&gt; ! &#123;</div><div class=\"line\">   <span class=\"built_in\">panic!</span>(<span class=\"string\">\"This function never returns!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> x: <span class=\"built_in\">i32</span> = diverges();</div><div class=\"line\"><span class=\"keyword\">let</span> x: <span class=\"built_in\">String</span> = diverges();</div></pre></td></tr></table></figure>\n<h2 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h2><p>我们也可以创建指向函数的变量绑定：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> f: <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span>;</div></pre></td></tr></table></figure>\n<p><code>f</code>是一个指向一个获取<code>i32</code>作为参数并返回<code>i32</code>的函数的变量绑定。例如：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">plus_one</span></span>(i: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">    i + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// without type inference</span></div><div class=\"line\"><span class=\"keyword\">let</span> f: <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> = plus_one;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// with type inference</span></div><div class=\"line\"><span class=\"keyword\">let</span> f = plus_one;</div></pre></td></tr></table></figure>\n<p>你可以用<code>f</code>来调用这个函数：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">plus_one</span></span>(i: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123; i + <span class=\"number\">1</span> &#125;</div><div class=\"line\"># <span class=\"keyword\">let</span> f = plus_one;</div><div class=\"line\"><span class=\"keyword\">let</span> six = f(<span class=\"number\">5</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>  高阶函数与普通函数的不同在于，它可以使用一个或多个函数作为参数，可以将函数作为返回值。rust的函数是first class type，所以支持高阶函数。而，由于rust是一个强类型的语言，如果要将函数作为参数或返回值，首先需要搞明白函数的类型。下面先说函数的类型，再说函数作为参数和返回值。</p>\n<h4 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h4><p>  前面说过，关键字<code>fn</code>可以用来定义函数。除此以外，它还用来构造函数类型。与函数定义主要的不同是，构造函数类型不需要函数名、参数名和函数体。在Rust Reference中的描述如下：</p>\n<blockquote>\n<p>The function type constructor fn forms new function types. A function type consists of a possibly-empty set of function-type modifiers (such as unsafe or extern), a sequence of input types and an output type.</p>\n</blockquote>\n<p>  来看一个简单例子：<br>  <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">inc</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;<span class=\"comment\">//函数定义</span></div><div class=\"line\">  n + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">IncType</span></span> = <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span>;<span class=\"comment\">//函数类型</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> func: IncType = inc;</div><div class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">\"3 + 1 = &#123;&#125;\"</span>, func(<span class=\"number\">3</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>  上例首先使用<code>fn</code>定义了<code>inc</code>函数，它有一个<code>i32</code>类型参数，返回<code>i32</code>类型的值。然后再用<code>fn</code>定义了一个函数类型，这个函数类型有i32类型的参数和i32类型的返回值，并用<code>type</code>关键字定义了它的别名<code>IncType</code>。在<code>main</code>函数中定义了一个变量<code>func</code>，其类型就为<code>IncType</code>，并赋值为<code>inc</code>，然后在<code>pirntln</code>宏中调用：<code>func(3)</code>。可以看到，<code>inc</code>函数的类型其实就是<code>IncType</code>。<br>  这里有一个问题，我们将<code>inc</code>赋值给了<code>func</code>，而不是<code>&amp;inc</code>，这样是将<code>inc</code>函数的拥有权转给了<code>func</code>吗，赋值后还可以以<code>inc()</code>形式调用<code>inc</code>函数吗？先来看一个例子：<br>  <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> func: IncType = inc;</div><div class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">\"3 + 1 = &#123;&#125;\"</span>, func(<span class=\"number\">3</span>));</div><div class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">\"3 + 1 = &#123;&#125;\"</span>, inc(<span class=\"number\">3</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">IncType</span></span> = <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">inc</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">  n + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>  我们将上例保存在rs源文件中，再用rustc编译，发现并没有报错，并且运行也得到我们想要的结果：<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">3 + 1 = 4</div><div class=\"line\">3 + 1 = 4</div></pre></td></tr></table></figure></p>\n<p>  这说明，赋值时，<code>inc</code>函数的所有权并没有被转移到<code>func</code>变量上，而是更像不可变引用。在rust中，函数的所有权是不能转移的，我们给函数类型的变量赋值时，赋给的一般是函数的指针，所以rust中的函数类型，就像是C/C++中的函数指针，当然，rust的函数类型更安全。可见，rust的函数类型，其实应该是属于指针类型（Pointer Type）。rust的Pointer Type有两种，一种为引用（Reference<code>&amp;</code>），另一种为原始指针（Raw pointer <code>*</code>），详细内容请看<a href=\"http://doc.rust-lang.org/reference.html#pointer-types\" target=\"_blank\" rel=\"external\">Rust Reference 8.18 Pointer Types</a>。而rust的函数类型应是引用类型，因为它是安全的，而原始指针则是不安全的，要使用原始指针，必须使用<code>unsafe</code>关键字声明。</p>\n<h4 id=\"函数作为参数\"><a href=\"#函数作为参数\" class=\"headerlink\" title=\"函数作为参数\"></a>函数作为参数</h4><p>  函数作为参数，其声明与普通参数一样。看下例：<br>  <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">\"3 + 1 = &#123;&#125;\"</span>, process(<span class=\"number\">3</span>, inc));</div><div class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">\"3 - 1 = &#123;&#125;\"</span>, process(<span class=\"number\">3</span>, dec));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">inc</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">  n + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dec</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">  n - <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">process</span></span>(n: <span class=\"built_in\">i32</span>, func: <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">  func(n)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>  例子中，<code>process</code>就是一个高阶函数，它有两个参数，一个类型为<code>i32</code>的<code>n</code>，另一个类型为<code>fn(i32)-&gt;i32</code>的函数<code>func</code>，返回一个<code>i32</code>类型的参数；它在函数体内以<code>n</code>作为参数调用<code>func</code>函数，返回<code>func</code>函数的返回值。运行可以得到以下结果：<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">3 + 1 = 4</div><div class=\"line\">3 - 1 = 2</div></pre></td></tr></table></figure></p>\n<p>  不过，这不是函数作为参数的唯一声明方法，使用泛型函数配合特质（<code>trait</code>）也是可以的，因为rust的函数都会实现一个<code>trait</code>:<code>FnOnce</code>、<code>Fn</code>或<code>FnMut</code>。将上例中的<code>process</code>函数定义换成以下形式是等价的：<br>  <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">process</span></span>&lt;F&gt;(n: <span class=\"built_in\">i32</span>, func: F) -&gt; <span class=\"built_in\">i32</span></div><div class=\"line\">    <span class=\"keyword\">where</span> F: <span class=\"built_in\">Fn</span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">    func(n)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"函数作为返回值\"><a href=\"#函数作为返回值\" class=\"headerlink\" title=\"函数作为返回值\"></a>函数作为返回值</h4><p>  函数作为返回值，其生命与普通函数的返回值类型声明一样。看例子：<br>  <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">   <span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>];</div><div class=\"line\">   <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> b = <span class=\"built_in\">Vec</span>::&lt;<span class=\"built_in\">i32</span>&gt;::new();</div><div class=\"line\">   <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &amp;a &#123;</div><div class=\"line\">       b.push(get_func(*i)(*i));</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"built_in\">println!</span>(<span class=\"string\">\"&#123;:?&#125;\"</span>, b);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_func</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">inc</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">        n + <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dec</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">        n - <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</div><div class=\"line\">        inc</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        dec</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>  例子中的高阶函数为<code>get_func</code>，它接收一个i32类型的函数，返回一个类型为<code>fn(i32) -&gt; i32</code>的函数，若传入的参数为偶数，返回<code>inc</code>，否则返回<code>dec</code>。这里需要注意的是，<code>inc</code>函数和<code>dec</code>函数都定义在<code>get_func</code>内。在函数内定义函数在很多其他语言中是不支持的，不过rust支持，这也是rust灵活和强大的一个体现。不过，在函数中定义的函数，不能包含函数中（环境中）的变量，若要包含，应该闭包。</p>\n<h4 id=\"返回多个值\"><a href=\"#返回多个值\" class=\"headerlink\" title=\"返回多个值\"></a>返回多个值</h4><p>rust的函数不支持多返回值,但是我们可以利用元组来返回多个值,配合rust的模式匹配,使用起来十分灵活。先看例子:<br><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> (p2,p3) = pow_2_3(<span class=\"number\">789</span>);</div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"pow 2 of 789 is &#123;&#125;.\"</span>, p2);</div><div class=\"line\">\t<span class=\"built_in\">println!</span>(<span class=\"string\">\"pow 3 of 789 is &#123;&#125;.\"</span>, p3);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">pow_2_3</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; (<span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>) &#123;</div><div class=\"line\">\t(n*n, n*n*n)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到,上例中, pow_2_3函数接收一个i32类型的值,返回其二次方和三次方的值,这两个值包装在一个元组中返回。在 main函数中, let语句就可以使用模式匹配将函数返回的元组进行解构,将这两个返回值分别赋给 p2和p3,从而可以得到 789二次方的值和三次方的值。</p>\n<h1 id=\"二：复合类型-1\"><a href=\"#二：复合类型-1\" class=\"headerlink\" title=\"二：复合类型\"></a>二：复合类型</h1><h2 id=\"1-结构体\"><a href=\"#1-结构体\" class=\"headerlink\" title=\"1. 结构体\"></a>1. 结构体</h2><p>结构体是一个创建更复杂数据类型的方法,大写字母开头并且驼峰命名法.结构体中的值默认是不可变的.</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span></span> &#123;</div><div class=\"line\">    x: <span class=\"built_in\">i32</span>,</div><div class=\"line\">    y: <span class=\"built_in\">i32</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> origin = Point &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span> &#125;; <span class=\"comment\">// origin: Point</span></div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"keyword\">do</span> = Point &#123; x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span> &#125;;</div><div class=\"line\">    <span class=\"keyword\">do</span>.x = <span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"The origin is at (&#123;&#125;, &#123;&#125;)\"</span>, origin.x, origin.y);</div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"The origin is at (&#123;&#125;, &#123;&#125;)\"</span>, <span class=\"keyword\">do</span>.x, <span class=\"keyword\">do</span>.y);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Rust 在语言级别不支持字段可变性，可变性是绑定的一个属性，不是结构体自身的。如果你习惯于字段级别的可变性，这开始可能看起来有点奇怪，不过这样明显地简化了问题。它甚至可以让你使变量只可变一段临时时间：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span></span> &#123;</div><div class=\"line\">    x: <span class=\"built_in\">i32</span>,</div><div class=\"line\">    y: <span class=\"built_in\">i32</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> point = Point &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span> &#125;;</div><div class=\"line\"></div><div class=\"line\">    point.x = <span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> point = point; <span class=\"comment\">// now immutable</span></div><div class=\"line\"></div><div class=\"line\">    point.y = <span class=\"number\">6</span>; <span class=\"comment\">// this causes an error</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你的结构体仍然可以包含<code>&amp;mut</code>指针，它会给你一些类型的可变性：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span></span> &#123;</div><div class=\"line\">    x: <span class=\"built_in\">i32</span>,</div><div class=\"line\">    y: <span class=\"built_in\">i32</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PointRef</span></span>&lt;<span class=\"symbol\">'a</span>&gt; &#123;</div><div class=\"line\">    x: &amp;<span class=\"symbol\">'a</span> <span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>,</div><div class=\"line\">    y: &amp;<span class=\"symbol\">'a</span> <span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> point = Point &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span> &#125;;</div><div class=\"line\"></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> r = PointRef &#123; x: &amp;<span class=\"keyword\">mut</span> point.x, y: &amp;<span class=\"keyword\">mut</span> point.y &#125;;</div><div class=\"line\"></div><div class=\"line\">        *r.x = <span class=\"number\">5</span>;</div><div class=\"line\">        *r.y = <span class=\"number\">6</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">assert_eq!</span>(<span class=\"number\">5</span>, point.x);</div><div class=\"line\">    <span class=\"built_in\">assert_eq!</span>(<span class=\"number\">6</span>, point.y);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"更新语法（Update-syntax）\"><a href=\"#更新语法（Update-syntax）\" class=\"headerlink\" title=\"更新语法（Update syntax）\"></a>更新语法（Update syntax）</h2><p>一个包含<code>..</code>的<code>struct</code>表明你想要使用一些其它结构体的拷贝的一些值。例如：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point3d</span></span> &#123;</div><div class=\"line\">    x: <span class=\"built_in\">i32</span>,</div><div class=\"line\">    y: <span class=\"built_in\">i32</span>,</div><div class=\"line\">    z: <span class=\"built_in\">i32</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> point = Point3d &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, z: <span class=\"number\">0</span> &#125;;</div><div class=\"line\">point = Point3d &#123; y: <span class=\"number\">1</span>, .. point &#125;;</div></pre></td></tr></table></figure>\n<p>这给了<code>point</code>一个新的<code>y</code>，不过保留了<code>x</code>和<code>z</code>的值。这也并不必要是同样的<code>struct</code>，你可以在创建新结构体时使用这个语法，并会拷贝你未指定的值：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point3d</span></span> &#123;</div><div class=\"line\">#     x: <span class=\"built_in\">i32</span>,</div><div class=\"line\">#     y: <span class=\"built_in\">i32</span>,</div><div class=\"line\">#     z: <span class=\"built_in\">i32</span>,</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> origin = Point3d &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, z: <span class=\"number\">0</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> point = Point3d &#123; z: <span class=\"number\">1</span>, x: <span class=\"number\">2</span>, .. origin &#125;;</div></pre></td></tr></table></figure>\n<h2 id=\"元组结构体\"><a href=\"#元组结构体\" class=\"headerlink\" title=\"元组结构体\"></a>元组结构体</h2><p>Rust有像另一个<a href=\"Primitive Types 原生类型.md#tuples\">元组</a>和结构体的混合体的数据类型。元组结构体有一个名字，不过它的字段没有。他们用<code>struct</code>关键字声明，并元组前面带有一个名字：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Color</span></span>(<span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>);</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span></span>(<span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//这里`black`和`origin`并不相等，即使它们有一模一样的值：</span></div><div class=\"line\"><span class=\"keyword\">let</span> black = Color(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> origin = Point(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<p>使用结构体几乎总是好于使用元组结构体。不过有种情况元组结构体非常有用，就是当元组结构体只有一个元素时。我们管它叫<em>新类型</em>（<em>newtype</em>），因为你创建了一个与元素相似的类型：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Inches</span></span>(<span class=\"built_in\">i32</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> length = Inches(<span class=\"number\">10</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> Inches(integer_length) = length;</div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"length is &#123;&#125; inches\"</span>, integer_length);</div></pre></td></tr></table></figure>\n<p>如你所见，你可以通过一个解构<code>let</code>来提取内部的整型，就像我们在讲元组时说的那样，<code>let Inches(integer_length)</code>给<code>integer_length</code>赋值为<code>10</code>。</p>\n<h2 id=\"类单元结构体（Unit-like-structs）\"><a href=\"#类单元结构体（Unit-like-structs）\" class=\"headerlink\" title=\"类单元结构体（Unit-like structs）\"></a>类单元结构体（Unit-like structs）</h2><p>你可以定义一个没有任何成员的结构体：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Electron</span></span> &#123;&#125; <span class=\"comment\">// Use empty braces...</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Proton</span></span>;     <span class=\"comment\">// ...or just a semicolon.</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Use the same notation when creating an instance.</span></div><div class=\"line\"><span class=\"keyword\">let</span> x = Electron &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> y = Proton;</div></pre></td></tr></table></figure>\n<p>这样的结构体叫做“类单元”因为它与一个空元组类似，<code>()</code>，这有时叫做“单元”。就像一个元组结构体，它定义了一个新类型。</p>\n<p>就它本身来看没什么用（虽然有时它可以作为一个标记类型），不过在与其它功能的结合中，它可以变得有用。例如，一个库可能请求你创建一个实现了一个特定特性的结构来处理事件。如果你并不需要在结构中存储任何数据，你可以仅仅创建一个类单元结构体。</p>\n<h2 id=\"2-枚举\"><a href=\"#2-枚举\" class=\"headerlink\" title=\"2. 枚举\"></a>2. 枚举</h2><p>Rust 中的一个<code>enum</code>是一个代表数个可能变量的数据的类型。每个变量都可选是否关联数据：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Message</span></span> &#123;</div><div class=\"line\">    Quit,</div><div class=\"line\">    ChangeColor(<span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>),</div><div class=\"line\">    Move &#123; x: <span class=\"built_in\">i32</span>, y: <span class=\"built_in\">i32</span> &#125;,</div><div class=\"line\">    Write(<span class=\"built_in\">String</span>),</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>定义变量的语法与用来定义结构体的语法类似：你可以有不带数据的变量（像类单元结构体），带有命名数据的变量，和带有未命名数据的变量（像元组结构体）。然而，不像单独的结构体定义，一个<code>enum</code>是一个单独的类型。一个枚举的值可以匹配任何一个变量。因为这个原因，枚举有时被叫做“集合类型”：枚举可能值的集合是每一个变量可能值的集合的总和。</p>\n<p>我们使用<code>::</code>语法来使用每个变量的名字：它们包含在<code>enum</code>名字自身中。这样的话，以下的情况都是可行的：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Message</span></span> &#123;</div><div class=\"line\">     Move &#123; x: <span class=\"built_in\">i32</span>, y: <span class=\"built_in\">i32</span> &#125;,</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> x: Message = Message::Move &#123; x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">BoardGameTurn</span></span> &#123;</div><div class=\"line\">    Move &#123; squares: <span class=\"built_in\">i32</span> &#125;,</div><div class=\"line\">    Pass,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> y: BoardGameTurn = BoardGameTurn::Move &#123; squares: <span class=\"number\">1</span> &#125;;</div></pre></td></tr></table></figure>\n<p>这两个变量都叫做<code>Move</code>，不过他们包含在枚举名字中，他们可以无冲突的使用。</p>\n<p>枚举类型的一个值包含它是哪个变量的信息，以及任何与变量相关的数据。这有时被作为一个“标记的联合”被提及。因为数据包括一个“标签”表明它的类型是什么。编译器使用这个信息来确保安全的访问枚举中的数据。例如，我们不能简单的尝试解构一个枚举值，就像它是其中一个可能的变体那样：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">process_color_change</span></span>(msg: Message) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> Message::ChangeColor(r, g, b) = msg; <span class=\"comment\">// compile-time error</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不支持这些操作（比较操作）可能看起来更像限制。不过这是一个我们可以克服的限制。有两种方法：我们自己实现相等（比较），或通过<a href=\"Match 匹配.md\"><code>match</code> </a>表达式模式匹配变量，你会在下一部分学到它。我们还不够了解Rust如何实现相等，不过我们会在<a href=\"Traits.md\">特性</a>找到它们。</p>\n<h2 id=\"构造器作为函数（Constructors-as-functions）\"><a href=\"#构造器作为函数（Constructors-as-functions）\" class=\"headerlink\" title=\"构造器作为函数（Constructors as functions）\"></a>构造器作为函数（Constructors as functions）</h2><p>一个枚举的构造器总是可以像函数一样使用。例如：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Message</span></span> &#123;</div><div class=\"line\">Write(<span class=\"built_in\">String</span>),</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> m = Message::Write(<span class=\"string\">\"Hello, world\"</span>.to_string());</div></pre></td></tr></table></figure>\n<p>与下面是一样的：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Message</span></span> &#123;</div><div class=\"line\">Write(<span class=\"built_in\">String</span>),</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">foo</span></span>(x: <span class=\"built_in\">String</span>) -&gt; Message &#123;</div><div class=\"line\">    Message::Write(x)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> x = foo(<span class=\"string\">\"Hello, world\"</span>.to_string());</div></pre></td></tr></table></figure>\n<p>这对我们没有什么直接的帮助，直到我们要用到<a href=\"Closures 闭包.md\">闭包</a>时，这时我们要考虑将函数作为参数传递给其他函数。例如，使用<a href=\"Iterators 迭代器.md\">迭代器</a>，我们可以这样把一个<code>String</code>的Vector转换为一个<code>Message::Write</code>的Vector：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Message</span></span> &#123;</div><div class=\"line\">Write(<span class=\"built_in\">String</span>),</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"string\">\"Hello\"</span>.to_string(), <span class=\"string\">\"World\"</span>.to_string()];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> v1: <span class=\"built_in\">Vec</span>&lt;Message&gt; = v.into_iter().map(Message::Write).collect();</div></pre></td></tr></table></figure>\n<h1 id=\"三：不定长类型\"><a href=\"#三：不定长类型\" class=\"headerlink\" title=\"三：不定长类型\"></a>三：不定长类型</h1><p>大部分类型有一个特定的大小，以字节为单位，它们在编译时是已知的。例如，一个<code>i32</code>是32位大，或者4个字节。然而，有些类型有益于表达，却没有一个定义的大小。它们叫做“不定长”或者“动态大小”类型。一个例子是<code>[T]</code>。这个类型代表一个特定数量<code>t</code>的序列。不过我们并不知道有多少，所以大小是未知的。</p>\n<p>Rust知道几个这样的类型，不过它们有一些限制。这有三个：</p>\n<ol>\n<li>我们只能通过指针操作一个不定长类型的实例。<code>&amp;[T]</code>刚好能正常工作，不过<code>[T]</code>不行。一个<code>&amp;[T]</code>能正常工作，不过一个<code>[T]</code>不行。</li>\n<li>变量和参数不能拥有动态大小类型。</li>\n<li>只有一个<code>struct</code>的最后一个字段可能拥有一个动态大小类型；其它字段则不可以拥有动态大小类型。枚举变量不可以用动态大小类型作为数据。</li>\n</ol>\n<p>所以为什么这很重要？好吧，因为<code>[T]</code>只能用在一个指针之后，如果我们没有对不定长类型的语言支持，它将不可能这么写：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">impl</span> Foo <span class=\"keyword\">for</span> <span class=\"built_in\">str</span> &#123;</div></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">impl</span>&lt;T&gt; Foo <span class=\"keyword\">for</span> [T] &#123;</div></pre></td></tr></table></figure>\n<p>相反，你将不得不这么写：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">impl</span> Foo <span class=\"keyword\">for</span> &amp;<span class=\"built_in\">str</span> &#123;</div></pre></td></tr></table></figure>\n<p>意味深长的是，这个实现将只能用于<a href=\"References and Borrowing 引用和借用.md\">引用</a>，并且不能用于其它类型的指针。通过<code>impl for str</code>，所有指针，包括（在一些地方，这里会有bug需要修复）用户自定义的智能指针，可以使用这个<code>impl</code>。</p>\n<h2 id=\"Sized\"><a href=\"#Sized\" class=\"headerlink\" title=\"?Sized\"></a><code>?Sized</code></h2><p>如果你想要写一个接受动态大小类型的函数，你可以使用这个特殊的限制，<code>?Sized</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span></span>&lt;T: ?<span class=\"built_in\">Sized</span>&gt; &#123;</div><div class=\"line\">    f: T,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个<code>?</code>，读作“<code>T</code>可能是<code>Sized</code>的”，意味着这个限制是特殊的：它让我们的匹配更宽松，而不是相反。这几乎像每个<code>T</code>都隐式拥有<code>T: Sized</code>一样，<code>?</code>放松了这个默认（限制）。</p>\n<h1 id=\"四：关联类型\"><a href=\"#四：关联类型\" class=\"headerlink\" title=\"四：关联类型\"></a>四：关联类型</h1><p>关联类型是Rust类型系统中非常强大的一部分。它涉及到‘类型族’的概念，换句话说，就是把多种类型归于一类。这个描述可能比较抽象，所以让我们深入研究一个例子。如果你想编写一个<code>Graph</code>trait，你需要泛型化两个类型：点类型和边类型。所以你可能会像这样写一个trait，<code>Graph&lt;N, E&gt;</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span>&lt;N, E&gt; &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;N, &amp;N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;N) -&gt; <span class=\"built_in\">Vec</span>&lt;E&gt;;</div><div class=\"line\">    <span class=\"comment\">// etc</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然这可以工作，不过显得很尴尬，例如，任何需要一个<code>Graph</code>作为参数的函数都需要泛型化的<code>N</code>ode和<code>E</code>dge类型：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">distance</span></span>&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; <span class=\"built_in\">u32</span> &#123; ... &#125;</div></pre></td></tr></table></figure>\n<p>我们的距离计算并不需要<code>Edge</code>类型，所以函数签名中<code>E</code>只是写着玩的。</p>\n<p>我们需要的是对于每一种<code>Graph</code>类型，都使用一个特定的的<code>N</code>ode和<code>E</code>dge类型。我们可以用关联类型来做到这一点：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\">    <span class=\"comment\">// etc</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在，我们使用一个抽象的<code>Graph</code>了：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">distance</span></span>&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; uint &#123; ... &#125;</div></pre></td></tr></table></figure>\n<p>这里不再需要处理<code>E</code>dge类型了。</p>\n<p>让我们更详细的回顾一下。</p>\n<h2 id=\"定义关联类型\"><a href=\"#定义关联类型\" class=\"headerlink\" title=\"定义关联类型\"></a>定义关联类型</h2><p>让我们构建一个<code>Graph</code>trait。这里是定义：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>十分简单。关联类型使用<code>type</code>关键字，并出现在trait体和函数中。</p>\n<p>这些<code>type</code>声明跟函数定义一样。例如，如果我们想<code>N</code>类型实现<code>Display</code>，这样我们就可以打印出点类型，我们可以这样写：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">use</span> std::fmt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>: fmt::Display;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"实现关联类型\"><a href=\"#实现关联类型\" class=\"headerlink\" title=\"实现关联类型\"></a>实现关联类型</h2><p>就像任何 trait，使用关联类型的 trait 用<code>impl</code>关键字来提供实现。下面是一个<code>Graph</code>的简单实现：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyGraph</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">impl</span> Graph <span class=\"keyword\">for</span> MyGraph &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span> = Node;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span> = Edge;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class=\"built_in\">bool</span> &#123;</div><div class=\"line\">        <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, n: &amp;Node) -&gt; <span class=\"built_in\">Vec</span>&lt;Edge&gt; &#123;</div><div class=\"line\">        <span class=\"built_in\">Vec</span>::new()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个可笑的实现总是返回<code>true</code>和一个空的<code>Vec&lt;Edge&gt;</code>，不过它提供了如何实现这类 trait 的思路。首先我们需要3个<code>struct</code>，一个代表图，一个代表点，还有一个代表边。如果使用别的类型更合理，也可以那样做，我们只是准备使用<code>struct</code>来代表这 3 个类型。</p>\n<p>接下来是<code>impl</code>行，它就像其它任何 trait 的实现。</p>\n<p>在这里，我们使用<code>=</code>来定义我们的关联类型。trait 使用的名字出现在<code>=</code>的左边，而我们<code>impl</code>的具体类型出现在右边。最后，我们在函数声明中使用具体类型。</p>\n<h2 id=\"trait-对象和关联类型\"><a href=\"#trait-对象和关联类型\" class=\"headerlink\" title=\"trait 对象和关联类型\"></a>trait 对象和关联类型</h2><p>这里还有另外一个我们需要讨论的语法：trait对象。如果你创建一个关联类型的trait对象，像这样：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\"># &#125;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyGraph</span></span>;</div><div class=\"line\"># <span class=\"keyword\">impl</span> Graph <span class=\"keyword\">for</span> MyGraph &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span> = Node;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span> = Edge;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class=\"built_in\">bool</span> &#123;</div><div class=\"line\">#         <span class=\"literal\">true</span></div><div class=\"line\">#     &#125;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, n: &amp;Node) -&gt; <span class=\"built_in\">Vec</span>&lt;Edge&gt; &#123;</div><div class=\"line\">#         <span class=\"built_in\">Vec</span>::new()</div><div class=\"line\">#     &#125;</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> graph = MyGraph;</div><div class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"built_in\">Box</span>::new(graph) <span class=\"keyword\">as</span> <span class=\"built_in\">Box</span>&lt;Graph&gt;;</div></pre></td></tr></table></figure>\n<p>你会得到两个错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">error: the value of the associated type `E` (from the trait `main::Graph`) must</div><div class=\"line\">be specified [E0191]</div><div class=\"line\">let obj = Box::new(graph) as Box&lt;Graph&gt;;</div><div class=\"line\">          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class=\"line\">24:44 error: the value of the associated type `N` (from the trait</div><div class=\"line\">`main::Graph`) must be specified [E0191]</div><div class=\"line\">let obj = Box::new(graph) as Box&lt;Graph&gt;;</div><div class=\"line\">          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div></pre></td></tr></table></figure>\n<p>我们不能这样创建一个trait对象，因为我们并不知道关联的类型。相反，我们可以这样写：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\"># &#125;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyGraph</span></span>;</div><div class=\"line\"># <span class=\"keyword\">impl</span> Graph <span class=\"keyword\">for</span> MyGraph &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span> = Node;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span> = Edge;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class=\"built_in\">bool</span> &#123;</div><div class=\"line\">#         <span class=\"literal\">true</span></div><div class=\"line\">#     &#125;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, n: &amp;Node) -&gt; <span class=\"built_in\">Vec</span>&lt;Edge&gt; &#123;</div><div class=\"line\">#         <span class=\"built_in\">Vec</span>::new()</div><div class=\"line\">#     &#125;</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> graph = MyGraph;</div><div class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"built_in\">Box</span>::new(graph) <span class=\"keyword\">as</span> <span class=\"built_in\">Box</span>&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;</div></pre></td></tr></table></figure>\n<p><code>N=Node</code>语法允许我们提供一个具体类型，<code>Node</code>，作为<code>N</code>类型参数。<code>E=Edge</code>也是一样。如果我们不提供这个限制，我们不能确定应该<code>impl</code>那个来匹配trait对象。</p>\n<p>关联类型是Rust类型系统中非常强大的一部分。它涉及到‘类型族’的概念，换句话说，就是把多种类型归于一类。这个描述可能比较抽象，所以让我们深入研究一个例子。如果你想编写一个<code>Graph</code>trait，你需要泛型化两个类型：点类型和边类型。所以你可能会像这样写一个trait，<code>Graph&lt;N, E&gt;</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span>&lt;N, E&gt; &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;N, &amp;N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;N) -&gt; <span class=\"built_in\">Vec</span>&lt;E&gt;;</div><div class=\"line\">    <span class=\"comment\">// etc</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然这可以工作，不过显得很尴尬，例如，任何需要一个<code>Graph</code>作为参数的函数都需要泛型化的<code>N</code>ode和<code>E</code>dge类型：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">distance</span></span>&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; <span class=\"built_in\">u32</span> &#123; ... &#125;</div></pre></td></tr></table></figure>\n<p>我们的距离计算并不需要<code>Edge</code>类型，所以函数签名中<code>E</code>只是写着玩的。</p>\n<p>我们需要的是对于每一种<code>Graph</code>类型，都使用一个特定的的<code>N</code>ode和<code>E</code>dge类型。我们可以用关联类型来做到这一点：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\">    <span class=\"comment\">// etc</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在，我们使用一个抽象的<code>Graph</code>了：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">distance</span></span>&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; uint &#123; ... &#125;</div></pre></td></tr></table></figure>\n<p>这里不再需要处理<code>E</code>dge类型了。</p>\n<p>让我们更详细的回顾一下。</p>\n<h2 id=\"定义关联类型-1\"><a href=\"#定义关联类型-1\" class=\"headerlink\" title=\"定义关联类型\"></a>定义关联类型</h2><p>让我们构建一个<code>Graph</code>trait。这里是定义：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>十分简单。关联类型使用<code>type</code>关键字，并出现在trait体和函数中。</p>\n<p>这些<code>type</code>声明跟函数定义一样。例如，如果我们想<code>N</code>类型实现<code>Display</code>，这样我们就可以打印出点类型，我们可以这样写：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">use</span> std::fmt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>: fmt::Display;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"实现关联类型-1\"><a href=\"#实现关联类型-1\" class=\"headerlink\" title=\"实现关联类型\"></a>实现关联类型</h2><p>就像任何 trait，使用关联类型的 trait 用<code>impl</code>关键字来提供实现。下面是一个<code>Graph</code>的简单实现：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyGraph</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">impl</span> Graph <span class=\"keyword\">for</span> MyGraph &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span> = Node;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span> = Edge;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class=\"built_in\">bool</span> &#123;</div><div class=\"line\">        <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, n: &amp;Node) -&gt; <span class=\"built_in\">Vec</span>&lt;Edge&gt; &#123;</div><div class=\"line\">        <span class=\"built_in\">Vec</span>::new()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个可笑的实现总是返回<code>true</code>和一个空的<code>Vec&lt;Edge&gt;</code>，不过它提供了如何实现这类 trait 的思路。首先我们需要3个<code>struct</code>，一个代表图，一个代表点，还有一个代表边。如果使用别的类型更合理，也可以那样做，我们只是准备使用<code>struct</code>来代表这 3 个类型。</p>\n<p>接下来是<code>impl</code>行，它就像其它任何 trait 的实现。</p>\n<p>在这里，我们使用<code>=</code>来定义我们的关联类型。trait 使用的名字出现在<code>=</code>的左边，而我们<code>impl</code>的具体类型出现在右边。最后，我们在函数声明中使用具体类型。</p>\n<h2 id=\"trait-对象和关联类型-1\"><a href=\"#trait-对象和关联类型-1\" class=\"headerlink\" title=\"trait 对象和关联类型\"></a>trait 对象和关联类型</h2><p>这里还有另外一个我们需要讨论的语法：trait对象。如果你创建一个关联类型的trait对象，像这样：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\"># &#125;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyGraph</span></span>;</div><div class=\"line\"># <span class=\"keyword\">impl</span> Graph <span class=\"keyword\">for</span> MyGraph &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span> = Node;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span> = Edge;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class=\"built_in\">bool</span> &#123;</div><div class=\"line\">#         <span class=\"literal\">true</span></div><div class=\"line\">#     &#125;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, n: &amp;Node) -&gt; <span class=\"built_in\">Vec</span>&lt;Edge&gt; &#123;</div><div class=\"line\">#         <span class=\"built_in\">Vec</span>::new()</div><div class=\"line\">#     &#125;</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> graph = MyGraph;</div><div class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"built_in\">Box</span>::new(graph) <span class=\"keyword\">as</span> <span class=\"built_in\">Box</span>&lt;Graph&gt;;</div></pre></td></tr></table></figure>\n<p>你会得到两个错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">error: the value of the associated type `E` (from the trait `main::Graph`) must</div><div class=\"line\">be specified [E0191]</div><div class=\"line\">let obj = Box::new(graph) as Box&lt;Graph&gt;;</div><div class=\"line\">          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class=\"line\">24:44 error: the value of the associated type `N` (from the trait</div><div class=\"line\">`main::Graph`) must be specified [E0191]</div><div class=\"line\">let obj = Box::new(graph) as Box&lt;Graph&gt;;</div><div class=\"line\">          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div></pre></td></tr></table></figure>\n<p>我们不能这样创建一个trait对象，因为我们并不知道关联的类型。相反，我们可以这样写：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\"># &#125;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyGraph</span></span>;</div><div class=\"line\"># <span class=\"keyword\">impl</span> Graph <span class=\"keyword\">for</span> MyGraph &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span> = Node;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span> = Edge;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class=\"built_in\">bool</span> &#123;</div><div class=\"line\">#         <span class=\"literal\">true</span></div><div class=\"line\">#     &#125;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, n: &amp;Node) -&gt; <span class=\"built_in\">Vec</span>&lt;Edge&gt; &#123;</div><div class=\"line\">#         <span class=\"built_in\">Vec</span>::new()</div><div class=\"line\">#     &#125;</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> graph = MyGraph;</div><div class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"built_in\">Box</span>::new(graph) <span class=\"keyword\">as</span> <span class=\"built_in\">Box</span>&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;</div></pre></td></tr></table></figure>\n<p><code>N=Node</code>语法允许我们提供一个具体类型，<code>Node</code>，作为<code>N</code>类型参数。<code>E=Edge</code>也是一样。如果我们不提供这个限制，我们不能确定应该<code>impl</code>那个来匹配trait对象。</p>\n<h1 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h1><h2 id=\"type-别名\"><a href=\"#type-别名\" class=\"headerlink\" title=\"`type`别名\"></a>`type`别名</h2><p><code>type</code>关键字让你定义另一个类型的别名：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Name</span></span> = <span class=\"built_in\">String</span>;</div></pre></td></tr></table></figure>\n<p>你可以像一个真正类型那样使用这个类型：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Name</span></span> = <span class=\"built_in\">String</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> x: Name = <span class=\"string\">\"Hello\"</span>.to_string();</div></pre></td></tr></table></figure>\n<p>然而要注意的是，这一个<em>别名</em>，完全不是一个新的类型。换句话说，因为Rust是强类型的，你可以预期两个不同类型的比较会失败：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> x: <span class=\"built_in\">i32</span> = <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> y: <span class=\"built_in\">i64</span> = <span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> x == y &#123;</div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这给出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">error: mismatched types:</div><div class=\"line\"> expected `i32`,</div><div class=\"line\">    found `i64`</div><div class=\"line\">(expected i32,</div><div class=\"line\">    found i64) [E0308]</div><div class=\"line\">     if x == y &#123;</div><div class=\"line\">             ^</div></pre></td></tr></table></figure>\n<p>不过，如果我们有一个别名：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Num</span></span> = <span class=\"built_in\">i32</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> x: <span class=\"built_in\">i32</span> = <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> y: Num = <span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> x == y &#123;</div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这会无错误的编译。从任何角度来说，<code>Num</code>类型的值与<code>i32</code>类型的值都是一样的。</p>\n<p>你也可以在泛型中使用类型别名：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">use</span> std::result;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ConcreteError</span></span> &#123;</div><div class=\"line\">    Foo,</div><div class=\"line\">    Bar,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Result</span></span>&lt;T&gt; = result::<span class=\"built_in\">Result</span>&lt;T, ConcreteError&gt;;</div></pre></td></tr></table></figure>\n<p>这创建了一个特定版本的<code>Result</code>类型，它总是有一个<code>ConcreteError</code>作为<code>Result&lt;T, E&gt;</code>的<code>E</code>那部分。这通常用于标准库中创建每个子部分的自定义错误。例如，<a href=\"http://doc.rust-lang.org/nightly/std/io/type.Result.html\" target=\"_blank\" rel=\"external\"><code>io::Result</code></a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一：原生类型\"><a href=\"#一：原生类型\" class=\"headerlink\" title=\"一：原生类型\"></a>一：原生类型</h1><ul>\n<li>布尔类型（bool）：有两个值true和false。</li>\n<li>字符类型 (char)：表示单个Unicode值，存储为4个字节。Rust支持(u8)单字节字符b’H’,仅限制于ASCII字符。</li>\n<li>数值类型 (int/float)：有符号整数 (i8,i16,i32,i64,isize)、无符号整数 (u8,u16,u32,u64,usize) 浮点数(f32,f64).整形默认为i32，浮点型默认为f64.</li>\n<li>字符串类型(str)：Unicode string slices.分为字符串切片&amp;str和堆分配字符串String，字符串切片是静态分配，有固定大小，且不可变，堆分配字符串是可变的。Rust还支持单字节字符串b”Hello”和原始字节字符串使用br#”hello”#，仅限于ASCII字符,不需要对特殊字符进行转义。</li>\n<li>指针 ( pointer )：最底层的是裸指针*const T和*mut T，但解引用它们是不安全的，必须放到unsafe块里。</li>\n<li>函数 ( fn )：具有函数类型的变量实质上是一个函数指针。</li>\n<li>元类型：即()，其唯一的值也是()。</li>\n</ul>\n<h1 id=\"二：复合类型\"><a href=\"#二：复合类型\" class=\"headerlink\" title=\"二：复合类型\"></a>二：复合类型</h1><ul>\n<li>数组  ( array )：具有固定大小，并且元素都是同种类型，表示[T; N]，标准库动态的数组即向量 Vec。不多于32个元素的数组在值传递时是自动复制的.数组切片(&amp;[T])：一个数组引用部分数据并且不需要拷贝，可表示为&amp;[T]。</li>\n<li>元组  ( tuple )：固定大小的有序列表，每个元素都有自己的类型，通过解构或者索引来获得元素的值。可使用==和!=运算符来判断是否相同，不多于12个元素的元组在值传递时是自动复制的。</li>\n</ul>\n<h1 id=\"三：自定义类型\"><a href=\"#三：自定义类型\" class=\"headerlink\" title=\"三：自定义类型\"></a>三：自定义类型</h1><ul>\n<li>结构体(struct) : </li>\n<li>枚举(enum) : </li>\n</ul>\n<h1 id=\"四：标准库数据类型\"><a href=\"#四：标准库数据类型\" class=\"headerlink\" title=\"四：标准库数据类型\"></a>四：标准库数据类型</h1><ul>\n<li>String : A UTF-8 encoded, growable string.</li>\n<li>Box : </li>\n<li>Sequences: Vec, VecDeque, LinkedList</li>\n<li>Maps: HashMap, BTreeMap</li>\n<li>Sets: HashSet, BTreeSet</li>\n<li>Misc: BinaryHeap</li>\n</ul>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>一个<em>字符串</em>是一串UTF-8字节编码的Unicode量级值的序列。所有的字符串都确保是有效编码的UTF-8序列。另外，字符串并不以null结尾并且可以包含null字节。Rust有两种主要的字符串类型：<code>&amp;str</code>和<code>String</code>。让我们先看看<code>&amp;str</code>。这叫做<em>字符串片段</em>（<em>string slices</em>）。字符串常量是<code>&amp;&#39;static str</code>类型的：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> greeting = <span class=\"string\">\"Hello there.\"</span>; <span class=\"comment\">// greeting: &amp;'static str</span></div></pre></td></tr></table></figure>\n<p><code>&quot;Hello there.&quot;</code>是一个字符串常量而它的类型是<code>&amp;&#39;static str</code>。字符串常量是静态分配的字符串切片，也就是说它储存在我们编译好的程序中，并且整个程序的运行过程中一直存在。这个<code>greeting</code>绑定了一个静态分配的字符串的引用。任何接受一个字符串切片的函数也接受一个字符串常量。</p>\n<p>字符串常量可以跨多行。有两种形式。第一种会包含新行符和之前的空格：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let s = \"foo</div><div class=\"line\">    bar\";</div><div class=\"line\"></div><div class=\"line\">assert_eq!(\"foo\\n        bar\", s);</div></pre></td></tr></table></figure>\n<p>第二种，带有<code>\\</code>，会去掉空格和新行符：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">\"foo\\</span></div><div class=\"line\">    bar\";</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">assert_eq!</span>(<span class=\"string\">\"foobar\"</span>, s);</div></pre></td></tr></table></figure>\n<p>Rust 当然不仅仅只有<code>&amp;str</code>。一个<code>String</code>，是一个在堆上分配的字符串。这个字符串可以增长，并且也保证是UTF-8编码的。<code>String</code>通常通过一个字符串片段调用<code>to_string</code>方法转换而来。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> s = <span class=\"string\">\"Hello\"</span>.to_string(); <span class=\"comment\">// mut s: String</span></div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"&#123;&#125;\"</span>, s);</div><div class=\"line\"></div><div class=\"line\">s.push_str(<span class=\"string\">\", world.\"</span>);</div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"&#123;&#125;\"</span>, s);</div></pre></td></tr></table></figure>\n<p><code>String</code>可以通过一个<code>&amp;</code>强制转换为<code>&amp;str</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">takes_slice</span></span>(slice: &amp;<span class=\"built_in\">str</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"Got: &#123;&#125;\"</span>, slice);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> s = <span class=\"string\">\"Hello\"</span>.to_string();</div><div class=\"line\">    takes_slice(&amp;s);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这种强制转换并不发生在接受<code>&amp;str</code>的trait而不是<code>&amp;str</code>本身作为参数的函数上。例如，<a href=\"http://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.connect\" target=\"_blank\" rel=\"external\">TcpStream::connect</a>，有一个<code>ToSocketAddrs</code>类型的参数。<code>&amp;str</code>可以不用转换不过<code>String</code>必须使用<code>&amp;*</code>显式转换。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">use</span> std::net::TcpStream;</div><div class=\"line\"></div><div class=\"line\">TcpStream::connect(<span class=\"string\">\"192.168.0.1:3000\"</span>); <span class=\"comment\">// &amp;str parameter</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> addr_string = <span class=\"string\">\"192.168.0.1:3000\"</span>.to_string();</div><div class=\"line\">TcpStream::connect(&amp;*addr_string); <span class=\"comment\">// convert addr_string to &amp;str</span></div></pre></td></tr></table></figure>\n<p>把<code>String</code>转换为<code>&amp;str</code>的代价很小，不过从<code>&amp;str</code>转换到<code>String</code>涉及到分配内存。除非必要，没有理由这样做！</p>\n<h2 id=\"索引（Indexing）\"><a href=\"#索引（Indexing）\" class=\"headerlink\" title=\"索引（Indexing）\"></a>索引（Indexing）</h2><p>因为字符串是有效UTF-8编码的，它不支持索引：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> s = <span class=\"string\">\"hello\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"The first letter of s is &#123;&#125;\"</span>, s[<span class=\"number\">0</span>]); <span class=\"comment\">// ERROR!!!</span></div></pre></td></tr></table></figure>\n<p>通常，用<code>[]</code>访问一个数组是非常快的。不过，字符串中每个UTF-8编码的字符可以是多个字节，你必须遍历字符串来找到字符串的第N个字符。这个操作的代价相当高，而且我们不想误导读者。更进一步来讲，Unicode实际上并没有定义什么“字符”。我们可以选择把字符串看作一个串独立的字节，或者代码点（codepoints）：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> hachiko = <span class=\"string\">\"忠犬ハチ公\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> hachiko.as_bytes() &#123;</div><div class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">\"&#123;&#125;, \"</span>, b);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> hachiko.chars() &#123;</div><div class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">\"&#123;&#125;, \"</span>, c);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"\"</span>);</div></pre></td></tr></table></figure>\n<p>这会打印出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,</div><div class=\"line\">忠, 犬, ハ, チ, 公,</div></pre></td></tr></table></figure>\n<p>如你所见，这有比<code>char</code>更多的字节。</p>\n<p>你可以这样来获取跟索引相似的东西：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"keyword\">let</span> hachiko = <span class=\"string\">\"忠犬ハチ公\"</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> dog = hachiko.chars().nth(<span class=\"number\">1</span>); <span class=\"comment\">// kinda like hachiko[1]</span></div></pre></td></tr></table></figure>\n<p>这强调了我们不得不遍历整个<code>char</code>的列表。</p>\n<p>你可以使用切片语法来获取一个字符串的切片：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"string\">\"hachiko\"</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> hachi = &amp;dog[<span class=\"number\">0</span>..<span class=\"number\">5</span>];</div></pre></td></tr></table></figure>\n<p>注意这里是<em>字节</em>偏移，而不是<em>字符</em>偏移。所以如下代码在运行时会失败：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> dog = <span class=\"string\">\"忠犬ハチ公\"</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> hachi = &amp;dog[<span class=\"number\">0</span>..<span class=\"number\">2</span>];</div></pre></td></tr></table></figure>\n<p>给出如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">thread &apos;&lt;main&gt;&apos; panicked at &apos;index 0 and/or 2 in `忠犬ハチ公` do not lie on</div><div class=\"line\">character boundary&apos;</div></pre></td></tr></table></figure>\n<h3 id=\"拼接字符串：-结果是String\"><a href=\"#拼接字符串：-结果是String\" class=\"headerlink\" title=\"拼接字符串：(结果是String)\"></a>拼接字符串：(结果是String)</h3><ol>\n<li>&amp;str不能直接拼接，</li>\n<li>拼接的首个字符串必须是String，之后的String需要一个 &amp; 转换成 &amp;str，这个功能叫做 Deref  转换。</li>\n<li>满足1，2条件的String与&amp;str可以多个交叉拼接。</li>\n</ol>\n<p>这是因为<code>&amp;String</code>可以自动转换为一个<code>&amp;str</code>。这个功能叫做<strong> <code>Deref</code>转换</strong>。</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span>    hello      =  <span class=\"string\">\"Hello\"</span>.to_string();        <span class=\"comment\">// String</span></div><div class=\"line\"><span class=\"keyword\">let</span>    hello_str  =  <span class=\"string\">\"Hello!\"</span>;                 <span class=\"comment\">// &amp;'static str</span></div><div class=\"line\"><span class=\"keyword\">let</span>    world      =  <span class=\"string\">\"World!\"</span>.to_string();      </div><div class=\"line\"><span class=\"keyword\">let</span>    world_str  =  <span class=\"string\">\"World!\"</span>;             </div><div class=\"line\"><span class=\"keyword\">let</span>    tom        =  <span class=\"string\">\"tom!\"</span>.to_string();  </div><div class=\"line\"><span class=\"keyword\">let</span>    tom_str    =  <span class=\"string\">\"tom!\"</span>;</div><div class=\"line\"><span class=\"keyword\">let</span>    lucy       =  <span class=\"string\">\"lucy!\"</span>.to_string();  </div><div class=\"line\"><span class=\"keyword\">let</span>    lucy_str   =  <span class=\"string\">\"lucy!\"</span>;</div><div class=\"line\"><span class=\"keyword\">let</span>    lilei      =  <span class=\"string\">\"lilei!\"</span>.to_string();  </div><div class=\"line\"><span class=\"keyword\">let</span>    lilei_str  =  <span class=\"string\">\"lilei!\"</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span>    hello_world  =  hello + world_str;</div><div class=\"line\"><span class=\"keyword\">let</span>    hello_world  =  hello + &amp;world;</div><div class=\"line\"><span class=\"keyword\">let</span>    hello_world  =  hello + world_str + tom_str + lucy_str;</div><div class=\"line\"><span class=\"keyword\">let</span>    hello_world  =  hello + &amp;world + &amp;tom + &amp;lucy;</div><div class=\"line\"><span class=\"keyword\">let</span>    hello_world  =  hello + hello_str + &amp;world + world_str + tom_str + &amp;tom + &amp;lucy + &amp;lilei + lucy_str + lilei_str;</div></pre></td></tr></table></figure>\n<h2 id=\"元组（Tuples）\"><a href=\"#元组（Tuples）\" class=\"headerlink\" title=\"元组（Tuples）\"></a>元组（Tuples）</h2><p>元组（tuples）是固定大小的有序列表。如下：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> x = (<span class=\"number\">1</span>, <span class=\"string\">\"hello\"</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> x: (<span class=\"built_in\">i32</span>, &amp;<span class=\"built_in\">str</span>) = (<span class=\"number\">1</span>, <span class=\"string\">\"hello\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> x = (<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// x: (i32, i32)</span></div><div class=\"line\"><span class=\"keyword\">let</span> y = (<span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// y: (i32, i32)</span></div><div class=\"line\"><span class=\"keyword\">let</span>\te\t=\tx.<span class=\"number\">1</span>;</div><div class=\"line\">x = y;</div></pre></td></tr></table></figure>\n<p>你可以通过一个<em>解构let</em>（<em>destructuring let</em>）访问元组中的字段。下面是一个例子：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> (x, y, z) = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"x is &#123;&#125;\"</span>, x);</div></pre></td></tr></table></figure>\n<p>可以在<code>let</code>左侧写一个模式，如果它能匹配右侧的话，我们可以一次写多个绑定。这种情况下，<code>let</code>“解构”或“拆开”了元组，并分成了三个绑定。</p>\n<p>你可以一个逗号来消除一个单元素元组和一个括号中的值的歧义：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"number\">0</span>,); <span class=\"comment\">// single-element tuple</span></div><div class=\"line\">(<span class=\"number\">0</span>); <span class=\"comment\">// zero</span></div></pre></td></tr></table></figure>\n<h3 id=\"元组索引（Tuple-Indexing）\"><a href=\"#元组索引（Tuple-Indexing）\" class=\"headerlink\" title=\"元组索引（Tuple Indexing）\"></a>元组索引（Tuple Indexing）</h3><p>你也可以用索引语法访问一个元组的字段,它使用<code>.</code></p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> tuple = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> x = tuple.<span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"x is &#123;&#125;\"</span>, x);</div></pre></td></tr></table></figure>\n<h3 id=\"数组-array-与Vec\"><a href=\"#数组-array-与Vec\" class=\"headerlink\" title=\"数组(array)与Vec\"></a>数组(array)与Vec</h3><p><strong>定义数组</strong>：<br><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> array: [<span class=\"built_in\">i32</span>; <span class=\"number\">3</span>] = [<span class=\"number\">0</span>; <span class=\"number\">3</span>];   <span class=\"comment\">// 方式一</span></div><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">8</span>,\t<span class=\"number\">9</span>,\t<span class=\"number\">10</span>];            <span class=\"comment\">// 方式二</span></div><div class=\"line\">array[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</div><div class=\"line\">array[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">assert_eq!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>], &amp;array[<span class=\"number\">1</span>..]);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// This loop prints: 0 1 2</span></div><div class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> &amp;array &#123;</div><div class=\"line\">    <span class=\"built_in\">print!</span>(<span class=\"string\">\"&#123;&#125; \"</span>, x);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> Vec : pronounced ‘Vector’是一个动态或“可增长”的数组，被实现为标准库类型<a href=\"http://doc.rust-lang.org/std/Vec/\" target=\"_blank\" rel=\"external\"><code>Vec&lt;T&gt;</code></a>（其中<code>&lt;T&gt;</code>是一个<a href=\"Generics 泛型.md\">泛型</a>语句）。Vec总是在堆上分配数据。Vec与数组切片就像<code>String</code>与<code>&amp;str</code>一样。你可以使用<code>vec!</code>宏来创建它：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> v1: <span class=\"built_in\">Vec</span>&lt;<span class=\"built_in\">i32</span>&gt; = <span class=\"built_in\">Vec</span>::new();    <span class=\"comment\">// 方式一</span></div><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];    <span class=\"comment\">// v: Vec&lt;i32&gt;   方式二</span></div><div class=\"line\"><span class=\"keyword\">let</span>\tv2 = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>;<span class=\"number\">10</span>];\t        <span class=\"comment\">//\t声明一个初始长度为10的值全为0的动态数组</span></div></pre></td></tr></table></figure>\n<p>（与我们之前使用<code>println!</code>宏时不一样，我们在<code>vec!</code>中使用中括号<code>[]</code>。为了方便，Rust 允许你使用上述各种情况。）</p>\n<p>对于重复初始值有另一种形式的<code>vec!</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">10</span>]; <span class=\"comment\">// ten zeroes</span></div></pre></td></tr></table></figure>\n<h4 id=\"访问元素\"><a href=\"#访问元素\" class=\"headerlink\" title=\"访问元素\"></a>访问元素</h4><p>为了Vec特定索引的值，我们使用<code>[]</code>,索引从<code>0</code>开始，所以第3个元素是<code>v[2]</code>.</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> r0 = v[<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> r1 = &amp;v[<span class=\"number\">2</span>];             <span class=\"comment\">//当引用一个不存在的元素时，会造成panic!.</span></div><div class=\"line\"><span class=\"keyword\">let</span> r2 = v.get(<span class=\"number\">3</span>);           <span class=\"comment\">//当引用一个不存在的元素时，返回None.</span></div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"The third element of v is&#123;&#125;, &#123;&#125;,&#123;&#125;\"</span>, r0, r1,r2);</div></pre></td></tr></table></figure>\n<p>另外值得注意的是你必须用<code>usize</code>类型的值来索引：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> i: <span class=\"built_in\">usize</span> = <span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> j: <span class=\"built_in\">i32</span> = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// works</span></div><div class=\"line\">v[i];</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// doesn’t</span></div><div class=\"line\">v[j];</div></pre></td></tr></table></figure>\n<p>用非<code>usize</code>类型索引的话会给出类似如下的错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">error: the trait `core::ops::Index&lt;i32&gt;` is not implemented for the type</div><div class=\"line\">`collections::Vec::Vec&lt;_&gt;` [E0277]</div><div class=\"line\">v[j];</div><div class=\"line\">^~~~</div><div class=\"line\">note: the type `collections::Vec::Vec&lt;_&gt;` cannot be indexed by `i32`</div><div class=\"line\">error: aborting due to previous error</div></pre></td></tr></table></figure>\n<p>信息中有很多标点符号，不过核心意思是：你不能用<code>i32</code>来索引。</p>\n<h4 id=\"越界访问（Out-of-bounds-Access）\"><a href=\"#越界访问（Out-of-bounds-Access）\" class=\"headerlink\" title=\"越界访问（Out-of-bounds Access）\"></a>越界访问（Out-of-bounds Access）</h4><p>如果你尝试访问并不存在的索引：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"Item 7 is &#123;&#125;\"</span>, v[<span class=\"number\">7</span>]);</div></pre></td></tr></table></figure>\n<p>那么当前的线程会<strong>panic</strong>并输出如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">thread &apos;&lt;main&gt;&apos; panicked at &apos;index out of bounds: the len is 3 but the index is 7&apos;</div></pre></td></tr></table></figure>\n<p>如果你想处理越界错误而不是 panic，你可以使用像<a href=\"http://doc.rust-lang.org/std/Vec/struct.Vec.html#method.get\" target=\"_blank\" rel=\"external\"><code>get</code></a>或<a href=\"http://doc.rust-lang.org/std/Vec/struct.Vec.html#method.get\" target=\"_blank\" rel=\"external\"><code>get_mut</code></a>这样的方法，他们当给出一个无效的索引时返回<code>None</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"keyword\">match</span> v.get(<span class=\"number\">7</span>) &#123;</div><div class=\"line\">    <span class=\"literal\">Some</span>(x) =&gt; <span class=\"built_in\">println!</span>(<span class=\"string\">\"Item 7 is &#123;&#125;\"</span>, x),</div><div class=\"line\">    <span class=\"literal\">None</span> =&gt; <span class=\"built_in\">println!</span>(<span class=\"string\">\"Sorry, this Vector is too short.\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用枚举来储存多种类型<br><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SpreadsheetCell</span></span> &#123;</div><div class=\"line\">    Int(<span class=\"built_in\">i32</span>),</div><div class=\"line\">    Float(<span class=\"built_in\">f64</span>),</div><div class=\"line\">    Text(<span class=\"built_in\">String</span>),</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> row = <span class=\"built_in\">vec!</span>[</div><div class=\"line\">    SpreadsheetCell::Int(<span class=\"number\">3</span>),</div><div class=\"line\">    SpreadsheetCell::Text(<span class=\"built_in\">String</span>::from(<span class=\"string\">\"blue\"</span>)),</div><div class=\"line\">    SpreadsheetCell::Float(<span class=\"number\">10.12</span>),</div><div class=\"line\">];</div></pre></td></tr></table></figure></p>\n<h4 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h4><p>当你有了一个Vector，我可以用<code>for</code>来迭代它的元素。有3个版本：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> v = <span class=\"built_in\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &amp;v &#123;</div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"A reference to &#123;&#125;\"</span>, i);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &amp;<span class=\"keyword\">mut</span> v &#123;</div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"A mutable reference to &#123;&#125;\"</span>, i);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> v &#123;</div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"Take ownership of the Vector and its element &#123;&#125;\"</span>, i);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Vector还有很多有用的方法，你可以看看<a href=\"http://doc.rust-lang.org/nightly/std/Vec/\" target=\"_blank\" rel=\"external\">Vector的API文档</a>了解它们。</p>\n<h2 id=\"数组切片（Slices）\"><a href=\"#数组切片（Slices）\" class=\"headerlink\" title=\"数组切片（Slices）\"></a>数组切片（Slices）</h2><p>一个<em>切片</em>（<em>slice</em>）是一个数组的引用（或者“视图”）。它有利于安全，有效的访问数组的一部分而不用进行拷贝。比如，你可能只想要引用读入到内存的文件中的一行。原理上，片段并不是直接创建的，而是引用一个已经存在的变量。片段有预定义的长度，可以是可变也可以是不可变的。</p>\n<h3 id=\"切片语法\"><a href=\"#切片语法\" class=\"headerlink\" title=\"切片语法\"></a>切片语法</h3><p>你可以用一个<code>&amp;</code>和<code>[]</code>的组合从多种数据类型创建一个切片。<code>&amp;</code>表明切片类似于<strong>引用</strong>，带有一个范围的<code>[]</code>，允许你定义切片的长度：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> complete = &amp;a[..]; <span class=\"comment\">// A slice containing all of the elements in a</span></div><div class=\"line\"><span class=\"keyword\">let</span> middle = &amp;a[<span class=\"number\">1</span>..<span class=\"number\">4</span>]; <span class=\"comment\">// A slice of a: just the elements 1, 2, and 3</span></div></pre></td></tr></table></figure>\n<p>片段拥有<code>&amp;[T]</code>类型。当我们涉及到<strong>泛型</strong>时会讨论这个<code>T</code>。</p>\n<p>你可以在<a href=\"http://doc.rust-lang.org/stable/std/primitive.slice.html\" target=\"_blank\" rel=\"external\">标准库文档</a>中找到更多关于<code>slices</code>的文档。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>函数也有一个类型！它们看起来像这样：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">foo</span></span>(x: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123; x &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> x: <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> = foo;</div></pre></td></tr></table></figure>\n<p>在这个例子中，<code>x</code>是一个“函数指针”，指向一个获取一个<code>i32</code>参数并返回一个<code>i32</code>值的函数。</p>\n<h2 id=\"表达式-VS-语句\"><a href=\"#表达式-VS-语句\" class=\"headerlink\" title=\"表达式 VS 语句\"></a>表达式 VS 语句</h2><p>Rust 主要是一个基于表达式的语言。只有两种语句，其它的一切都是表达式。</p>\n<p>表达式返回一个值，而语句不是。这就是为什么这里我们以“不是所有控制路径都返回一个值”结束：<code>x + 1;</code>语句不返回一个值。Rust 中有两种类型的语句：“声明语句”和“表达式语句”。其余的一切是表达式。让我们先讨论下声明语句。</p>\n<p>在 Rust 中，使用<code>let</code>引入一个绑定并<em>不是</em>一个表达式。下面的代码会产生一个编译时错误：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> x = (<span class=\"keyword\">let</span> y = <span class=\"number\">5</span>); <span class=\"comment\">// expected identifier, found keyword `let`</span></div></pre></td></tr></table></figure>\n<p>编译器告诉我们这里它期望看到表达式的开头，而<code>let</code>只能开始一个语句，不是一个表达式。</p>\n<p>注意赋值一个已经绑定过的变量（例如，<code>y = 5</code>）仍是一个表达式，即使它的（返回）值并不是特别有用。不像其它语言中赋值语句返回它赋的值（例如，前面例子中的<code>5</code>），在 Rust 中赋值的值是一个空的元组<code>()</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> y = <span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> x = (y = <span class=\"number\">6</span>);  <span class=\"comment\">// x has the value `()`, not `6`</span></div></pre></td></tr></table></figure>\n<p>Rust中第二种语句是<em>表达式语句</em>。它的目的是把任何表达式变为语句。在实践环境中，Rust 语法期望语句后跟其它语句。这意味着你用分号来分隔各个表达式。这意味着Rust看起来很像大部分其它使用分号做为语句结尾的语言，并且你会看到分号出现在几乎每一行你看到的 Rust 代码。</p>\n<p>那么我们说“几乎”的例外是神马呢？你已经见过它了，在这些代码中：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">add_one</span></span>(x: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">    x + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们的函数声称它返回一个<code>i32</code>，不过带有一个分号，它会返回一个<code>()</code>。Rust意识到这可能不是我们想要的，并在我们之前看到的错误中建议我们去掉分号。</p>\n<h2 id=\"提早返回（Early-returns）\"><a href=\"#提早返回（Early-returns）\" class=\"headerlink\" title=\"提早返回（Early returns）\"></a>提早返回（Early returns）</h2><p>不过提早返回,Rust确实有这么一个关键字，<code>return</code>,使用<code>return</code>作为函数的最后一行是可行的，不过被认为是一个糟糕的风格：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">foo</span></span>(x: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// we never run this code!</span></div><div class=\"line\">    x + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"发散函数（Diverging-functions）\"><a href=\"#发散函数（Diverging-functions）\" class=\"headerlink\" title=\"发散函数（Diverging functions）\"></a>发散函数（Diverging functions）</h2><p>Rust有些特殊的语法叫“发散函数”，这些函数并不返回：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">diverges</span></span>() -&gt; ! &#123;</div><div class=\"line\">    <span class=\"built_in\">panic!</span>(<span class=\"string\">\"This function never returns!\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>panic!</code>是一个宏，类似我们已经见过的<code>println!()</code>。与<code>println!()</code>不同的是，<code>panic!()</code>导致当前的执行线程崩溃并返回指定的信息。因为这个函数会崩溃，所以它不会返回，所以它拥有一个类型<code>!</code>，它代表“发散”。</p>\n<p>如果你添加一个叫做<code>diverges()</code>的函数并运行，你将会得到一些像这样的输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">thread ‘&lt;main&gt;’ panicked at ‘This function never returns!’, hello.rs:2</div></pre></td></tr></table></figure>\n<p>如果你想要更多信息，你可以设定<code>RUST_BACKTRACE</code>环境变量来获取 backtrace ：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ RUST_BACKTRACE=1 ./diverges</div><div class=\"line\">thread <span class=\"string\">'&lt;main&gt;'</span> panicked at <span class=\"string\">'This function never returns!'</span>, hello.rs:2</div><div class=\"line\">stack backtrace:</div><div class=\"line\">   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r</div><div class=\"line\">   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w</div><div class=\"line\">   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw</div><div class=\"line\">   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650</div><div class=\"line\">   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa</div><div class=\"line\">   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa</div><div class=\"line\">   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231</div><div class=\"line\">   8:     0x7f402773d1d8 - __rust_try</div><div class=\"line\">   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w</div><div class=\"line\">  10:     0x7f4027738a19 - main</div><div class=\"line\">  11:     0x7f402694ab44 - __libc_start_main</div><div class=\"line\">  12:     0x7f40277386c8 - &lt;unknown&gt;</div><div class=\"line\">  13:                0x0 - &lt;unknown&gt;</div></pre></td></tr></table></figure>\n<p><code>RUST_BACKTRACE</code>也可以用于 Cargo 的<code>run</code>命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ RUST_BACKTRACE=1 cargo run</div><div class=\"line\">     Running `target/debug/diverges`</div><div class=\"line\">thread <span class=\"string\">'&lt;main&gt;'</span> panicked at <span class=\"string\">'This function never returns!'</span>, hello.rs:2</div><div class=\"line\">stack backtrace:</div><div class=\"line\">   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r</div><div class=\"line\">   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w</div><div class=\"line\">   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw</div><div class=\"line\">   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650</div><div class=\"line\">   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa</div><div class=\"line\">   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa</div><div class=\"line\">   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231</div><div class=\"line\">   8:     0x7f402773d1d8 - __rust_try</div><div class=\"line\">   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w</div><div class=\"line\">  10:     0x7f4027738a19 - main</div><div class=\"line\">  11:     0x7f402694ab44 - __libc_start_main</div><div class=\"line\">  12:     0x7f40277386c8 - &lt;unknown&gt;</div><div class=\"line\">  13:                0x0 - &lt;unknown&gt;</div></pre></td></tr></table></figure>\n<p>发散函数可以被用作任何类型：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">diverges</span></span>() -&gt; ! &#123;</div><div class=\"line\">   <span class=\"built_in\">panic!</span>(<span class=\"string\">\"This function never returns!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> x: <span class=\"built_in\">i32</span> = diverges();</div><div class=\"line\"><span class=\"keyword\">let</span> x: <span class=\"built_in\">String</span> = diverges();</div></pre></td></tr></table></figure>\n<h2 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h2><p>我们也可以创建指向函数的变量绑定：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> f: <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span>;</div></pre></td></tr></table></figure>\n<p><code>f</code>是一个指向一个获取<code>i32</code>作为参数并返回<code>i32</code>的函数的变量绑定。例如：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">plus_one</span></span>(i: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">    i + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// without type inference</span></div><div class=\"line\"><span class=\"keyword\">let</span> f: <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> = plus_one;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// with type inference</span></div><div class=\"line\"><span class=\"keyword\">let</span> f = plus_one;</div></pre></td></tr></table></figure>\n<p>你可以用<code>f</code>来调用这个函数：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">plus_one</span></span>(i: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123; i + <span class=\"number\">1</span> &#125;</div><div class=\"line\"># <span class=\"keyword\">let</span> f = plus_one;</div><div class=\"line\"><span class=\"keyword\">let</span> six = f(<span class=\"number\">5</span>);</div></pre></td></tr></table></figure>\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>  高阶函数与普通函数的不同在于，它可以使用一个或多个函数作为参数，可以将函数作为返回值。rust的函数是first class type，所以支持高阶函数。而，由于rust是一个强类型的语言，如果要将函数作为参数或返回值，首先需要搞明白函数的类型。下面先说函数的类型，再说函数作为参数和返回值。</p>\n<h4 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h4><p>  前面说过，关键字<code>fn</code>可以用来定义函数。除此以外，它还用来构造函数类型。与函数定义主要的不同是，构造函数类型不需要函数名、参数名和函数体。在Rust Reference中的描述如下：</p>\n<blockquote>\n<p>The function type constructor fn forms new function types. A function type consists of a possibly-empty set of function-type modifiers (such as unsafe or extern), a sequence of input types and an output type.</p>\n</blockquote>\n<p>  来看一个简单例子：<br>  <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">inc</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;<span class=\"comment\">//函数定义</span></div><div class=\"line\">  n + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">IncType</span></span> = <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span>;<span class=\"comment\">//函数类型</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> func: IncType = inc;</div><div class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">\"3 + 1 = &#123;&#125;\"</span>, func(<span class=\"number\">3</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>  上例首先使用<code>fn</code>定义了<code>inc</code>函数，它有一个<code>i32</code>类型参数，返回<code>i32</code>类型的值。然后再用<code>fn</code>定义了一个函数类型，这个函数类型有i32类型的参数和i32类型的返回值，并用<code>type</code>关键字定义了它的别名<code>IncType</code>。在<code>main</code>函数中定义了一个变量<code>func</code>，其类型就为<code>IncType</code>，并赋值为<code>inc</code>，然后在<code>pirntln</code>宏中调用：<code>func(3)</code>。可以看到，<code>inc</code>函数的类型其实就是<code>IncType</code>。<br>  这里有一个问题，我们将<code>inc</code>赋值给了<code>func</code>，而不是<code>&amp;inc</code>，这样是将<code>inc</code>函数的拥有权转给了<code>func</code>吗，赋值后还可以以<code>inc()</code>形式调用<code>inc</code>函数吗？先来看一个例子：<br>  <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> func: IncType = inc;</div><div class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">\"3 + 1 = &#123;&#125;\"</span>, func(<span class=\"number\">3</span>));</div><div class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">\"3 + 1 = &#123;&#125;\"</span>, inc(<span class=\"number\">3</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">IncType</span></span> = <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">inc</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">  n + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>  我们将上例保存在rs源文件中，再用rustc编译，发现并没有报错，并且运行也得到我们想要的结果：<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">3 + 1 = 4</div><div class=\"line\">3 + 1 = 4</div></pre></td></tr></table></figure></p>\n<p>  这说明，赋值时，<code>inc</code>函数的所有权并没有被转移到<code>func</code>变量上，而是更像不可变引用。在rust中，函数的所有权是不能转移的，我们给函数类型的变量赋值时，赋给的一般是函数的指针，所以rust中的函数类型，就像是C/C++中的函数指针，当然，rust的函数类型更安全。可见，rust的函数类型，其实应该是属于指针类型（Pointer Type）。rust的Pointer Type有两种，一种为引用（Reference<code>&amp;</code>），另一种为原始指针（Raw pointer <code>*</code>），详细内容请看<a href=\"http://doc.rust-lang.org/reference.html#pointer-types\" target=\"_blank\" rel=\"external\">Rust Reference 8.18 Pointer Types</a>。而rust的函数类型应是引用类型，因为它是安全的，而原始指针则是不安全的，要使用原始指针，必须使用<code>unsafe</code>关键字声明。</p>\n<h4 id=\"函数作为参数\"><a href=\"#函数作为参数\" class=\"headerlink\" title=\"函数作为参数\"></a>函数作为参数</h4><p>  函数作为参数，其声明与普通参数一样。看下例：<br>  <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">\"3 + 1 = &#123;&#125;\"</span>, process(<span class=\"number\">3</span>, inc));</div><div class=\"line\">  <span class=\"built_in\">println!</span>(<span class=\"string\">\"3 - 1 = &#123;&#125;\"</span>, process(<span class=\"number\">3</span>, dec));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">inc</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">  n + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dec</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">  n - <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">process</span></span>(n: <span class=\"built_in\">i32</span>, func: <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">  func(n)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>  例子中，<code>process</code>就是一个高阶函数，它有两个参数，一个类型为<code>i32</code>的<code>n</code>，另一个类型为<code>fn(i32)-&gt;i32</code>的函数<code>func</code>，返回一个<code>i32</code>类型的参数；它在函数体内以<code>n</code>作为参数调用<code>func</code>函数，返回<code>func</code>函数的返回值。运行可以得到以下结果：<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">3 + 1 = 4</div><div class=\"line\">3 - 1 = 2</div></pre></td></tr></table></figure></p>\n<p>  不过，这不是函数作为参数的唯一声明方法，使用泛型函数配合特质（<code>trait</code>）也是可以的，因为rust的函数都会实现一个<code>trait</code>:<code>FnOnce</code>、<code>Fn</code>或<code>FnMut</code>。将上例中的<code>process</code>函数定义换成以下形式是等价的：<br>  <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">process</span></span>&lt;F&gt;(n: <span class=\"built_in\">i32</span>, func: F) -&gt; <span class=\"built_in\">i32</span></div><div class=\"line\">    <span class=\"keyword\">where</span> F: <span class=\"built_in\">Fn</span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">    func(n)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"函数作为返回值\"><a href=\"#函数作为返回值\" class=\"headerlink\" title=\"函数作为返回值\"></a>函数作为返回值</h4><p>  函数作为返回值，其生命与普通函数的返回值类型声明一样。看例子：<br>  <figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">   <span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>];</div><div class=\"line\">   <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> b = <span class=\"built_in\">Vec</span>::&lt;<span class=\"built_in\">i32</span>&gt;::new();</div><div class=\"line\">   <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &amp;a &#123;</div><div class=\"line\">       b.push(get_func(*i)(*i));</div><div class=\"line\">   &#125;</div><div class=\"line\">   <span class=\"built_in\">println!</span>(<span class=\"string\">\"&#123;:?&#125;\"</span>, b);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get_func</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"function\"><span class=\"keyword\">fn</span></span>(<span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">inc</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">        n + <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">dec</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; <span class=\"built_in\">i32</span> &#123;</div><div class=\"line\">        n - <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span> &#123;</div><div class=\"line\">        inc</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        dec</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>  例子中的高阶函数为<code>get_func</code>，它接收一个i32类型的函数，返回一个类型为<code>fn(i32) -&gt; i32</code>的函数，若传入的参数为偶数，返回<code>inc</code>，否则返回<code>dec</code>。这里需要注意的是，<code>inc</code>函数和<code>dec</code>函数都定义在<code>get_func</code>内。在函数内定义函数在很多其他语言中是不支持的，不过rust支持，这也是rust灵活和强大的一个体现。不过，在函数中定义的函数，不能包含函数中（环境中）的变量，若要包含，应该闭包。</p>\n<h4 id=\"返回多个值\"><a href=\"#返回多个值\" class=\"headerlink\" title=\"返回多个值\"></a>返回多个值</h4><p>rust的函数不支持多返回值,但是我们可以利用元组来返回多个值,配合rust的模式匹配,使用起来十分灵活。先看例子:<br><figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> (p2,p3) = pow_2_3(<span class=\"number\">789</span>);</div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"pow 2 of 789 is &#123;&#125;.\"</span>, p2);</div><div class=\"line\">\t<span class=\"built_in\">println!</span>(<span class=\"string\">\"pow 3 of 789 is &#123;&#125;.\"</span>, p3);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">pow_2_3</span></span>(n: <span class=\"built_in\">i32</span>) -&gt; (<span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>) &#123;</div><div class=\"line\">\t(n*n, n*n*n)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到,上例中, pow_2_3函数接收一个i32类型的值,返回其二次方和三次方的值,这两个值包装在一个元组中返回。在 main函数中, let语句就可以使用模式匹配将函数返回的元组进行解构,将这两个返回值分别赋给 p2和p3,从而可以得到 789二次方的值和三次方的值。</p>\n<h1 id=\"二：复合类型-1\"><a href=\"#二：复合类型-1\" class=\"headerlink\" title=\"二：复合类型\"></a>二：复合类型</h1><h2 id=\"1-结构体\"><a href=\"#1-结构体\" class=\"headerlink\" title=\"1. 结构体\"></a>1. 结构体</h2><p>结构体是一个创建更复杂数据类型的方法,大写字母开头并且驼峰命名法.结构体中的值默认是不可变的.</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span></span> &#123;</div><div class=\"line\">    x: <span class=\"built_in\">i32</span>,</div><div class=\"line\">    y: <span class=\"built_in\">i32</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> origin = Point &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span> &#125;; <span class=\"comment\">// origin: Point</span></div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"keyword\">do</span> = Point &#123; x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span> &#125;;</div><div class=\"line\">    <span class=\"keyword\">do</span>.x = <span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"The origin is at (&#123;&#125;, &#123;&#125;)\"</span>, origin.x, origin.y);</div><div class=\"line\">    <span class=\"built_in\">println!</span>(<span class=\"string\">\"The origin is at (&#123;&#125;, &#123;&#125;)\"</span>, <span class=\"keyword\">do</span>.x, <span class=\"keyword\">do</span>.y);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Rust 在语言级别不支持字段可变性，可变性是绑定的一个属性，不是结构体自身的。如果你习惯于字段级别的可变性，这开始可能看起来有点奇怪，不过这样明显地简化了问题。它甚至可以让你使变量只可变一段临时时间：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span></span> &#123;</div><div class=\"line\">    x: <span class=\"built_in\">i32</span>,</div><div class=\"line\">    y: <span class=\"built_in\">i32</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> point = Point &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span> &#125;;</div><div class=\"line\"></div><div class=\"line\">    point.x = <span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> point = point; <span class=\"comment\">// now immutable</span></div><div class=\"line\"></div><div class=\"line\">    point.y = <span class=\"number\">6</span>; <span class=\"comment\">// this causes an error</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你的结构体仍然可以包含<code>&amp;mut</code>指针，它会给你一些类型的可变性：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span></span> &#123;</div><div class=\"line\">    x: <span class=\"built_in\">i32</span>,</div><div class=\"line\">    y: <span class=\"built_in\">i32</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PointRef</span></span>&lt;<span class=\"symbol\">'a</span>&gt; &#123;</div><div class=\"line\">    x: &amp;<span class=\"symbol\">'a</span> <span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>,</div><div class=\"line\">    y: &amp;<span class=\"symbol\">'a</span> <span class=\"keyword\">mut</span> <span class=\"built_in\">i32</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">main</span></span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> point = Point &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span> &#125;;</div><div class=\"line\"></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> r = PointRef &#123; x: &amp;<span class=\"keyword\">mut</span> point.x, y: &amp;<span class=\"keyword\">mut</span> point.y &#125;;</div><div class=\"line\"></div><div class=\"line\">        *r.x = <span class=\"number\">5</span>;</div><div class=\"line\">        *r.y = <span class=\"number\">6</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">assert_eq!</span>(<span class=\"number\">5</span>, point.x);</div><div class=\"line\">    <span class=\"built_in\">assert_eq!</span>(<span class=\"number\">6</span>, point.y);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"更新语法（Update-syntax）\"><a href=\"#更新语法（Update-syntax）\" class=\"headerlink\" title=\"更新语法（Update syntax）\"></a>更新语法（Update syntax）</h2><p>一个包含<code>..</code>的<code>struct</code>表明你想要使用一些其它结构体的拷贝的一些值。例如：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point3d</span></span> &#123;</div><div class=\"line\">    x: <span class=\"built_in\">i32</span>,</div><div class=\"line\">    y: <span class=\"built_in\">i32</span>,</div><div class=\"line\">    z: <span class=\"built_in\">i32</span>,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> point = Point3d &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, z: <span class=\"number\">0</span> &#125;;</div><div class=\"line\">point = Point3d &#123; y: <span class=\"number\">1</span>, .. point &#125;;</div></pre></td></tr></table></figure>\n<p>这给了<code>point</code>一个新的<code>y</code>，不过保留了<code>x</code>和<code>z</code>的值。这也并不必要是同样的<code>struct</code>，你可以在创建新结构体时使用这个语法，并会拷贝你未指定的值：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point3d</span></span> &#123;</div><div class=\"line\">#     x: <span class=\"built_in\">i32</span>,</div><div class=\"line\">#     y: <span class=\"built_in\">i32</span>,</div><div class=\"line\">#     z: <span class=\"built_in\">i32</span>,</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> origin = Point3d &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, z: <span class=\"number\">0</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> point = Point3d &#123; z: <span class=\"number\">1</span>, x: <span class=\"number\">2</span>, .. origin &#125;;</div></pre></td></tr></table></figure>\n<h2 id=\"元组结构体\"><a href=\"#元组结构体\" class=\"headerlink\" title=\"元组结构体\"></a>元组结构体</h2><p>Rust有像另一个<a href=\"Primitive Types 原生类型.md#tuples\">元组</a>和结构体的混合体的数据类型。元组结构体有一个名字，不过它的字段没有。他们用<code>struct</code>关键字声明，并元组前面带有一个名字：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Color</span></span>(<span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>);</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span></span>(<span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//这里`black`和`origin`并不相等，即使它们有一模一样的值：</span></div><div class=\"line\"><span class=\"keyword\">let</span> black = Color(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> origin = Point(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div></pre></td></tr></table></figure>\n<p>使用结构体几乎总是好于使用元组结构体。不过有种情况元组结构体非常有用，就是当元组结构体只有一个元素时。我们管它叫<em>新类型</em>（<em>newtype</em>），因为你创建了一个与元素相似的类型：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Inches</span></span>(<span class=\"built_in\">i32</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> length = Inches(<span class=\"number\">10</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> Inches(integer_length) = length;</div><div class=\"line\"><span class=\"built_in\">println!</span>(<span class=\"string\">\"length is &#123;&#125; inches\"</span>, integer_length);</div></pre></td></tr></table></figure>\n<p>如你所见，你可以通过一个解构<code>let</code>来提取内部的整型，就像我们在讲元组时说的那样，<code>let Inches(integer_length)</code>给<code>integer_length</code>赋值为<code>10</code>。</p>\n<h2 id=\"类单元结构体（Unit-like-structs）\"><a href=\"#类单元结构体（Unit-like-structs）\" class=\"headerlink\" title=\"类单元结构体（Unit-like structs）\"></a>类单元结构体（Unit-like structs）</h2><p>你可以定义一个没有任何成员的结构体：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Electron</span></span> &#123;&#125; <span class=\"comment\">// Use empty braces...</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Proton</span></span>;     <span class=\"comment\">// ...or just a semicolon.</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Use the same notation when creating an instance.</span></div><div class=\"line\"><span class=\"keyword\">let</span> x = Electron &#123;&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> y = Proton;</div></pre></td></tr></table></figure>\n<p>这样的结构体叫做“类单元”因为它与一个空元组类似，<code>()</code>，这有时叫做“单元”。就像一个元组结构体，它定义了一个新类型。</p>\n<p>就它本身来看没什么用（虽然有时它可以作为一个标记类型），不过在与其它功能的结合中，它可以变得有用。例如，一个库可能请求你创建一个实现了一个特定特性的结构来处理事件。如果你并不需要在结构中存储任何数据，你可以仅仅创建一个类单元结构体。</p>\n<h2 id=\"2-枚举\"><a href=\"#2-枚举\" class=\"headerlink\" title=\"2. 枚举\"></a>2. 枚举</h2><p>Rust 中的一个<code>enum</code>是一个代表数个可能变量的数据的类型。每个变量都可选是否关联数据：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Message</span></span> &#123;</div><div class=\"line\">    Quit,</div><div class=\"line\">    ChangeColor(<span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>, <span class=\"built_in\">i32</span>),</div><div class=\"line\">    Move &#123; x: <span class=\"built_in\">i32</span>, y: <span class=\"built_in\">i32</span> &#125;,</div><div class=\"line\">    Write(<span class=\"built_in\">String</span>),</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>定义变量的语法与用来定义结构体的语法类似：你可以有不带数据的变量（像类单元结构体），带有命名数据的变量，和带有未命名数据的变量（像元组结构体）。然而，不像单独的结构体定义，一个<code>enum</code>是一个单独的类型。一个枚举的值可以匹配任何一个变量。因为这个原因，枚举有时被叫做“集合类型”：枚举可能值的集合是每一个变量可能值的集合的总和。</p>\n<p>我们使用<code>::</code>语法来使用每个变量的名字：它们包含在<code>enum</code>名字自身中。这样的话，以下的情况都是可行的：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Message</span></span> &#123;</div><div class=\"line\">     Move &#123; x: <span class=\"built_in\">i32</span>, y: <span class=\"built_in\">i32</span> &#125;,</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> x: Message = Message::Move &#123; x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span> &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">BoardGameTurn</span></span> &#123;</div><div class=\"line\">    Move &#123; squares: <span class=\"built_in\">i32</span> &#125;,</div><div class=\"line\">    Pass,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> y: BoardGameTurn = BoardGameTurn::Move &#123; squares: <span class=\"number\">1</span> &#125;;</div></pre></td></tr></table></figure>\n<p>这两个变量都叫做<code>Move</code>，不过他们包含在枚举名字中，他们可以无冲突的使用。</p>\n<p>枚举类型的一个值包含它是哪个变量的信息，以及任何与变量相关的数据。这有时被作为一个“标记的联合”被提及。因为数据包括一个“标签”表明它的类型是什么。编译器使用这个信息来确保安全的访问枚举中的数据。例如，我们不能简单的尝试解构一个枚举值，就像它是其中一个可能的变体那样：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">process_color_change</span></span>(msg: Message) &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> Message::ChangeColor(r, g, b) = msg; <span class=\"comment\">// compile-time error</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>不支持这些操作（比较操作）可能看起来更像限制。不过这是一个我们可以克服的限制。有两种方法：我们自己实现相等（比较），或通过<a href=\"Match 匹配.md\"><code>match</code> </a>表达式模式匹配变量，你会在下一部分学到它。我们还不够了解Rust如何实现相等，不过我们会在<a href=\"Traits.md\">特性</a>找到它们。</p>\n<h2 id=\"构造器作为函数（Constructors-as-functions）\"><a href=\"#构造器作为函数（Constructors-as-functions）\" class=\"headerlink\" title=\"构造器作为函数（Constructors as functions）\"></a>构造器作为函数（Constructors as functions）</h2><p>一个枚举的构造器总是可以像函数一样使用。例如：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Message</span></span> &#123;</div><div class=\"line\">Write(<span class=\"built_in\">String</span>),</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> m = Message::Write(<span class=\"string\">\"Hello, world\"</span>.to_string());</div></pre></td></tr></table></figure>\n<p>与下面是一样的：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Message</span></span> &#123;</div><div class=\"line\">Write(<span class=\"built_in\">String</span>),</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">foo</span></span>(x: <span class=\"built_in\">String</span>) -&gt; Message &#123;</div><div class=\"line\">    Message::Write(x)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> x = foo(<span class=\"string\">\"Hello, world\"</span>.to_string());</div></pre></td></tr></table></figure>\n<p>这对我们没有什么直接的帮助，直到我们要用到<a href=\"Closures 闭包.md\">闭包</a>时，这时我们要考虑将函数作为参数传递给其他函数。例如，使用<a href=\"Iterators 迭代器.md\">迭代器</a>，我们可以这样把一个<code>String</code>的Vector转换为一个<code>Message::Write</code>的Vector：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Message</span></span> &#123;</div><div class=\"line\">Write(<span class=\"built_in\">String</span>),</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"built_in\">vec!</span>[<span class=\"string\">\"Hello\"</span>.to_string(), <span class=\"string\">\"World\"</span>.to_string()];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> v1: <span class=\"built_in\">Vec</span>&lt;Message&gt; = v.into_iter().map(Message::Write).collect();</div></pre></td></tr></table></figure>\n<h1 id=\"三：不定长类型\"><a href=\"#三：不定长类型\" class=\"headerlink\" title=\"三：不定长类型\"></a>三：不定长类型</h1><p>大部分类型有一个特定的大小，以字节为单位，它们在编译时是已知的。例如，一个<code>i32</code>是32位大，或者4个字节。然而，有些类型有益于表达，却没有一个定义的大小。它们叫做“不定长”或者“动态大小”类型。一个例子是<code>[T]</code>。这个类型代表一个特定数量<code>t</code>的序列。不过我们并不知道有多少，所以大小是未知的。</p>\n<p>Rust知道几个这样的类型，不过它们有一些限制。这有三个：</p>\n<ol>\n<li>我们只能通过指针操作一个不定长类型的实例。<code>&amp;[T]</code>刚好能正常工作，不过<code>[T]</code>不行。一个<code>&amp;[T]</code>能正常工作，不过一个<code>[T]</code>不行。</li>\n<li>变量和参数不能拥有动态大小类型。</li>\n<li>只有一个<code>struct</code>的最后一个字段可能拥有一个动态大小类型；其它字段则不可以拥有动态大小类型。枚举变量不可以用动态大小类型作为数据。</li>\n</ol>\n<p>所以为什么这很重要？好吧，因为<code>[T]</code>只能用在一个指针之后，如果我们没有对不定长类型的语言支持，它将不可能这么写：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">impl</span> Foo <span class=\"keyword\">for</span> <span class=\"built_in\">str</span> &#123;</div></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">impl</span>&lt;T&gt; Foo <span class=\"keyword\">for</span> [T] &#123;</div></pre></td></tr></table></figure>\n<p>相反，你将不得不这么写：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">impl</span> Foo <span class=\"keyword\">for</span> &amp;<span class=\"built_in\">str</span> &#123;</div></pre></td></tr></table></figure>\n<p>意味深长的是，这个实现将只能用于<a href=\"References and Borrowing 引用和借用.md\">引用</a>，并且不能用于其它类型的指针。通过<code>impl for str</code>，所有指针，包括（在一些地方，这里会有bug需要修复）用户自定义的智能指针，可以使用这个<code>impl</code>。</p>\n<h2 id=\"Sized\"><a href=\"#Sized\" class=\"headerlink\" title=\"?Sized\"></a><code>?Sized</code></h2><p>如果你想要写一个接受动态大小类型的函数，你可以使用这个特殊的限制，<code>?Sized</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span></span>&lt;T: ?<span class=\"built_in\">Sized</span>&gt; &#123;</div><div class=\"line\">    f: T,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个<code>?</code>，读作“<code>T</code>可能是<code>Sized</code>的”，意味着这个限制是特殊的：它让我们的匹配更宽松，而不是相反。这几乎像每个<code>T</code>都隐式拥有<code>T: Sized</code>一样，<code>?</code>放松了这个默认（限制）。</p>\n<h1 id=\"四：关联类型\"><a href=\"#四：关联类型\" class=\"headerlink\" title=\"四：关联类型\"></a>四：关联类型</h1><p>关联类型是Rust类型系统中非常强大的一部分。它涉及到‘类型族’的概念，换句话说，就是把多种类型归于一类。这个描述可能比较抽象，所以让我们深入研究一个例子。如果你想编写一个<code>Graph</code>trait，你需要泛型化两个类型：点类型和边类型。所以你可能会像这样写一个trait，<code>Graph&lt;N, E&gt;</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span>&lt;N, E&gt; &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;N, &amp;N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;N) -&gt; <span class=\"built_in\">Vec</span>&lt;E&gt;;</div><div class=\"line\">    <span class=\"comment\">// etc</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然这可以工作，不过显得很尴尬，例如，任何需要一个<code>Graph</code>作为参数的函数都需要泛型化的<code>N</code>ode和<code>E</code>dge类型：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">distance</span></span>&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; <span class=\"built_in\">u32</span> &#123; ... &#125;</div></pre></td></tr></table></figure>\n<p>我们的距离计算并不需要<code>Edge</code>类型，所以函数签名中<code>E</code>只是写着玩的。</p>\n<p>我们需要的是对于每一种<code>Graph</code>类型，都使用一个特定的的<code>N</code>ode和<code>E</code>dge类型。我们可以用关联类型来做到这一点：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\">    <span class=\"comment\">// etc</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在，我们使用一个抽象的<code>Graph</code>了：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">distance</span></span>&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; uint &#123; ... &#125;</div></pre></td></tr></table></figure>\n<p>这里不再需要处理<code>E</code>dge类型了。</p>\n<p>让我们更详细的回顾一下。</p>\n<h2 id=\"定义关联类型\"><a href=\"#定义关联类型\" class=\"headerlink\" title=\"定义关联类型\"></a>定义关联类型</h2><p>让我们构建一个<code>Graph</code>trait。这里是定义：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>十分简单。关联类型使用<code>type</code>关键字，并出现在trait体和函数中。</p>\n<p>这些<code>type</code>声明跟函数定义一样。例如，如果我们想<code>N</code>类型实现<code>Display</code>，这样我们就可以打印出点类型，我们可以这样写：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">use</span> std::fmt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>: fmt::Display;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"实现关联类型\"><a href=\"#实现关联类型\" class=\"headerlink\" title=\"实现关联类型\"></a>实现关联类型</h2><p>就像任何 trait，使用关联类型的 trait 用<code>impl</code>关键字来提供实现。下面是一个<code>Graph</code>的简单实现：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyGraph</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">impl</span> Graph <span class=\"keyword\">for</span> MyGraph &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span> = Node;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span> = Edge;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class=\"built_in\">bool</span> &#123;</div><div class=\"line\">        <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, n: &amp;Node) -&gt; <span class=\"built_in\">Vec</span>&lt;Edge&gt; &#123;</div><div class=\"line\">        <span class=\"built_in\">Vec</span>::new()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个可笑的实现总是返回<code>true</code>和一个空的<code>Vec&lt;Edge&gt;</code>，不过它提供了如何实现这类 trait 的思路。首先我们需要3个<code>struct</code>，一个代表图，一个代表点，还有一个代表边。如果使用别的类型更合理，也可以那样做，我们只是准备使用<code>struct</code>来代表这 3 个类型。</p>\n<p>接下来是<code>impl</code>行，它就像其它任何 trait 的实现。</p>\n<p>在这里，我们使用<code>=</code>来定义我们的关联类型。trait 使用的名字出现在<code>=</code>的左边，而我们<code>impl</code>的具体类型出现在右边。最后，我们在函数声明中使用具体类型。</p>\n<h2 id=\"trait-对象和关联类型\"><a href=\"#trait-对象和关联类型\" class=\"headerlink\" title=\"trait 对象和关联类型\"></a>trait 对象和关联类型</h2><p>这里还有另外一个我们需要讨论的语法：trait对象。如果你创建一个关联类型的trait对象，像这样：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\"># &#125;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyGraph</span></span>;</div><div class=\"line\"># <span class=\"keyword\">impl</span> Graph <span class=\"keyword\">for</span> MyGraph &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span> = Node;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span> = Edge;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class=\"built_in\">bool</span> &#123;</div><div class=\"line\">#         <span class=\"literal\">true</span></div><div class=\"line\">#     &#125;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, n: &amp;Node) -&gt; <span class=\"built_in\">Vec</span>&lt;Edge&gt; &#123;</div><div class=\"line\">#         <span class=\"built_in\">Vec</span>::new()</div><div class=\"line\">#     &#125;</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> graph = MyGraph;</div><div class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"built_in\">Box</span>::new(graph) <span class=\"keyword\">as</span> <span class=\"built_in\">Box</span>&lt;Graph&gt;;</div></pre></td></tr></table></figure>\n<p>你会得到两个错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">error: the value of the associated type `E` (from the trait `main::Graph`) must</div><div class=\"line\">be specified [E0191]</div><div class=\"line\">let obj = Box::new(graph) as Box&lt;Graph&gt;;</div><div class=\"line\">          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class=\"line\">24:44 error: the value of the associated type `N` (from the trait</div><div class=\"line\">`main::Graph`) must be specified [E0191]</div><div class=\"line\">let obj = Box::new(graph) as Box&lt;Graph&gt;;</div><div class=\"line\">          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div></pre></td></tr></table></figure>\n<p>我们不能这样创建一个trait对象，因为我们并不知道关联的类型。相反，我们可以这样写：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\"># &#125;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyGraph</span></span>;</div><div class=\"line\"># <span class=\"keyword\">impl</span> Graph <span class=\"keyword\">for</span> MyGraph &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span> = Node;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span> = Edge;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class=\"built_in\">bool</span> &#123;</div><div class=\"line\">#         <span class=\"literal\">true</span></div><div class=\"line\">#     &#125;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, n: &amp;Node) -&gt; <span class=\"built_in\">Vec</span>&lt;Edge&gt; &#123;</div><div class=\"line\">#         <span class=\"built_in\">Vec</span>::new()</div><div class=\"line\">#     &#125;</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> graph = MyGraph;</div><div class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"built_in\">Box</span>::new(graph) <span class=\"keyword\">as</span> <span class=\"built_in\">Box</span>&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;</div></pre></td></tr></table></figure>\n<p><code>N=Node</code>语法允许我们提供一个具体类型，<code>Node</code>，作为<code>N</code>类型参数。<code>E=Edge</code>也是一样。如果我们不提供这个限制，我们不能确定应该<code>impl</code>那个来匹配trait对象。</p>\n<p>关联类型是Rust类型系统中非常强大的一部分。它涉及到‘类型族’的概念，换句话说，就是把多种类型归于一类。这个描述可能比较抽象，所以让我们深入研究一个例子。如果你想编写一个<code>Graph</code>trait，你需要泛型化两个类型：点类型和边类型。所以你可能会像这样写一个trait，<code>Graph&lt;N, E&gt;</code>：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span>&lt;N, E&gt; &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;N, &amp;N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;N) -&gt; <span class=\"built_in\">Vec</span>&lt;E&gt;;</div><div class=\"line\">    <span class=\"comment\">// etc</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>虽然这可以工作，不过显得很尴尬，例如，任何需要一个<code>Graph</code>作为参数的函数都需要泛型化的<code>N</code>ode和<code>E</code>dge类型：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">distance</span></span>&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; <span class=\"built_in\">u32</span> &#123; ... &#125;</div></pre></td></tr></table></figure>\n<p>我们的距离计算并不需要<code>Edge</code>类型，所以函数签名中<code>E</code>只是写着玩的。</p>\n<p>我们需要的是对于每一种<code>Graph</code>类型，都使用一个特定的的<code>N</code>ode和<code>E</code>dge类型。我们可以用关联类型来做到这一点：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\">    <span class=\"comment\">// etc</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在，我们使用一个抽象的<code>Graph</code>了：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">distance</span></span>&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; uint &#123; ... &#125;</div></pre></td></tr></table></figure>\n<p>这里不再需要处理<code>E</code>dge类型了。</p>\n<p>让我们更详细的回顾一下。</p>\n<h2 id=\"定义关联类型-1\"><a href=\"#定义关联类型-1\" class=\"headerlink\" title=\"定义关联类型\"></a>定义关联类型</h2><p>让我们构建一个<code>Graph</code>trait。这里是定义：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>十分简单。关联类型使用<code>type</code>关键字，并出现在trait体和函数中。</p>\n<p>这些<code>type</code>声明跟函数定义一样。例如，如果我们想<code>N</code>类型实现<code>Display</code>，这样我们就可以打印出点类型，我们可以这样写：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">use</span> std::fmt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>: fmt::Display;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"实现关联类型-1\"><a href=\"#实现关联类型-1\" class=\"headerlink\" title=\"实现关联类型\"></a>实现关联类型</h2><p>就像任何 trait，使用关联类型的 trait 用<code>impl</code>关键字来提供实现。下面是一个<code>Graph</code>的简单实现：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyGraph</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">impl</span> Graph <span class=\"keyword\">for</span> MyGraph &#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span> = Node;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span> = Edge;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class=\"built_in\">bool</span> &#123;</div><div class=\"line\">        <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, n: &amp;Node) -&gt; <span class=\"built_in\">Vec</span>&lt;Edge&gt; &#123;</div><div class=\"line\">        <span class=\"built_in\">Vec</span>::new()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个可笑的实现总是返回<code>true</code>和一个空的<code>Vec&lt;Edge&gt;</code>，不过它提供了如何实现这类 trait 的思路。首先我们需要3个<code>struct</code>，一个代表图，一个代表点，还有一个代表边。如果使用别的类型更合理，也可以那样做，我们只是准备使用<code>struct</code>来代表这 3 个类型。</p>\n<p>接下来是<code>impl</code>行，它就像其它任何 trait 的实现。</p>\n<p>在这里，我们使用<code>=</code>来定义我们的关联类型。trait 使用的名字出现在<code>=</code>的左边，而我们<code>impl</code>的具体类型出现在右边。最后，我们在函数声明中使用具体类型。</p>\n<h2 id=\"trait-对象和关联类型-1\"><a href=\"#trait-对象和关联类型-1\" class=\"headerlink\" title=\"trait 对象和关联类型\"></a>trait 对象和关联类型</h2><p>这里还有另外一个我们需要讨论的语法：trait对象。如果你创建一个关联类型的trait对象，像这样：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\"># &#125;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyGraph</span></span>;</div><div class=\"line\"># <span class=\"keyword\">impl</span> Graph <span class=\"keyword\">for</span> MyGraph &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span> = Node;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span> = Edge;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class=\"built_in\">bool</span> &#123;</div><div class=\"line\">#         <span class=\"literal\">true</span></div><div class=\"line\">#     &#125;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, n: &amp;Node) -&gt; <span class=\"built_in\">Vec</span>&lt;Edge&gt; &#123;</div><div class=\"line\">#         <span class=\"built_in\">Vec</span>::new()</div><div class=\"line\">#     &#125;</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> graph = MyGraph;</div><div class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"built_in\">Box</span>::new(graph) <span class=\"keyword\">as</span> <span class=\"built_in\">Box</span>&lt;Graph&gt;;</div></pre></td></tr></table></figure>\n<p>你会得到两个错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">error: the value of the associated type `E` (from the trait `main::Graph`) must</div><div class=\"line\">be specified [E0191]</div><div class=\"line\">let obj = Box::new(graph) as Box&lt;Graph&gt;;</div><div class=\"line\">          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class=\"line\">24:44 error: the value of the associated type `N` (from the trait</div><div class=\"line\">`main::Graph`) must be specified [E0191]</div><div class=\"line\">let obj = Box::new(graph) as Box&lt;Graph&gt;;</div><div class=\"line\">          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div></pre></td></tr></table></figure>\n<p>我们不能这样创建一个trait对象，因为我们并不知道关联的类型。相反，我们可以这样写：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Graph</span></span> &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span>;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N, &amp;Self::N) -&gt; <span class=\"built_in\">bool</span>;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, &amp;Self::N) -&gt; <span class=\"built_in\">Vec</span>&lt;Self::E&gt;;</div><div class=\"line\"># &#125;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Edge</span></span>;</div><div class=\"line\"># <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyGraph</span></span>;</div><div class=\"line\"># <span class=\"keyword\">impl</span> Graph <span class=\"keyword\">for</span> MyGraph &#123;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">N</span></span> = Node;</div><div class=\"line\">#     <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">E</span></span> = Edge;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">has_edge</span></span>(&amp;<span class=\"keyword\">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class=\"built_in\">bool</span> &#123;</div><div class=\"line\">#         <span class=\"literal\">true</span></div><div class=\"line\">#     &#125;</div><div class=\"line\">#     <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">edges</span></span>(&amp;<span class=\"keyword\">self</span>, n: &amp;Node) -&gt; <span class=\"built_in\">Vec</span>&lt;Edge&gt; &#123;</div><div class=\"line\">#         <span class=\"built_in\">Vec</span>::new()</div><div class=\"line\">#     &#125;</div><div class=\"line\"># &#125;</div><div class=\"line\"><span class=\"keyword\">let</span> graph = MyGraph;</div><div class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"built_in\">Box</span>::new(graph) <span class=\"keyword\">as</span> <span class=\"built_in\">Box</span>&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;</div></pre></td></tr></table></figure>\n<p><code>N=Node</code>语法允许我们提供一个具体类型，<code>Node</code>，作为<code>N</code>类型参数。<code>E=Edge</code>也是一样。如果我们不提供这个限制，我们不能确定应该<code>impl</code>那个来匹配trait对象。</p>\n<h1 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h1><h2 id=\"type-别名\"><a href=\"#type-别名\" class=\"headerlink\" title=\"`type`别名\"></a>`type`别名</h2><p><code>type</code>关键字让你定义另一个类型的别名：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Name</span></span> = <span class=\"built_in\">String</span>;</div></pre></td></tr></table></figure>\n<p>你可以像一个真正类型那样使用这个类型：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Name</span></span> = <span class=\"built_in\">String</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> x: Name = <span class=\"string\">\"Hello\"</span>.to_string();</div></pre></td></tr></table></figure>\n<p>然而要注意的是，这一个<em>别名</em>，完全不是一个新的类型。换句话说，因为Rust是强类型的，你可以预期两个不同类型的比较会失败：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> x: <span class=\"built_in\">i32</span> = <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> y: <span class=\"built_in\">i64</span> = <span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> x == y &#123;</div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这给出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">error: mismatched types:</div><div class=\"line\"> expected `i32`,</div><div class=\"line\">    found `i64`</div><div class=\"line\">(expected i32,</div><div class=\"line\">    found i64) [E0308]</div><div class=\"line\">     if x == y &#123;</div><div class=\"line\">             ^</div></pre></td></tr></table></figure>\n<p>不过，如果我们有一个别名：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Num</span></span> = <span class=\"built_in\">i32</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> x: <span class=\"built_in\">i32</span> = <span class=\"number\">5</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> y: Num = <span class=\"number\">5</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> x == y &#123;</div><div class=\"line\">   <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这会无错误的编译。从任何角度来说，<code>Num</code>类型的值与<code>i32</code>类型的值都是一样的。</p>\n<p>你也可以在泛型中使用类型别名：</p>\n<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">use</span> std::result;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ConcreteError</span></span> &#123;</div><div class=\"line\">    Foo,</div><div class=\"line\">    Bar,</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">Result</span></span>&lt;T&gt; = result::<span class=\"built_in\">Result</span>&lt;T, ConcreteError&gt;;</div></pre></td></tr></table></figure>\n<p>这创建了一个特定版本的<code>Result</code>类型，它总是有一个<code>ConcreteError</code>作为<code>Result&lt;T, E&gt;</code>的<code>E</code>那部分。这通常用于标准库中创建每个子部分的自定义错误。例如，<a href=\"http://doc.rust-lang.org/nightly/std/io/type.Result.html\" target=\"_blank\" rel=\"external\"><code>io::Result</code></a>。</p>\n"},{"title":"Use-debian","date":"2015-03-06T01:20:00.000Z","_content":"\n## 1.debian的安装：\n\n下载官网的Debian DVD版本用Win32DiskImager软件做成U盘启动安装(或使用 GNOME Multi-Writer)，\n开机设置BIOS的USB启动直接进入安装界面，还可以选择图形界面安装很方便.\n\n## 2.安装网卡驱动实现联网\n\n安装过程中会提示你的有限和无线网卡驱动未安装信息。我的是这两个：rtl_nic/rtl8168d-2.fw和rtlwifi/rtl8192sefw.bin谷歌搜索 可得到链接debian的deb包为firmware-realtek_0.43_all.deb，很方便。安装后重启就能链接无线上网了。\n\n## 3：配置源:\n\n```bash\nsudo nano /etc/apt/sources.list\ndeb http://ftp.cn.debian.org/debian/ testing main non-free contrib\ndeb-src http://ftp.cn.debian.org/debian/ testing main non-free contrib\ndeb http://ftp.cn.debian.org/debian/ testing-proposed-updates main non-free contrib\ndeb-src http://ftp.cn.debian.org/debian/ testing-proposed-updates main non-free contrib\ndeb http://ftp.cn.debian.org/debian/ testing-updates main non-free contrib\ndeb-src http://ftp.cn.debian.org/debian/ testing-updates main non-free contrib\ndeb http://security.debian.org/ testing/updates main contrib non-free\n\n使用Sid，则可将更新列表改为：\ndeb http://ftp.cn.debian.org/debian/ sid main contrib non-free\ndeb http://ftp.cn.debian.org/debian/ sid main contrib non-free\n```\n\n## 4.debian更新:\n\n```bash\n$ sudo aptitude update\n$ sudo aptitude safe-upgrade\n$ sudo aptitude full-upgrade\n```\n\n## 5.驱动问题\n\n```bash\nsudo aptitude install firmware-linux-nonfree\n```\n\n## 6.安装sudo 使普通用户有系统管理的权利\n\n```bash\nroot# aptitude install sudo\nroot# chmod +w /etc/sudoers          授予sudoers 写的权限，否则为只读。\nroot# nano /etc/sudoers               编辑  /etc/sudoers\n找到root 行并在下行输入你的账户,在账户后面把root后面的复制下来就行了,然后保存.\nroot# chmod 0440 /etc/sudoers        去掉sudoers 写的权限改为只读。\nroot# exit                           退到普通账户。\n```\n#### sudo找不到命令：修改sudo的PATH路径\n\nsudo有时候会出现找不到命令，而明明PATH路径下包含该命令，让人疑惑。其实出现这种情况的原因，主要是因为当 sudo以管理权限执行命令的时候，linux将PATH环境变量进行了重置，当然这主要是因为系统安全的考虑，但却使得sudo搜索的路径不是我们想要的PATH变量的路径，当然就找不到我们想要的命令了。两种方法解决该问题：\n\n首先，都要打开sudo的配置文件：sudo visudo\n\n- 1.可以使用 secure_path 指令修改 sudoers 中默认的 PATH为你想要的路径。这个指令指定当用户执行 sudo 命令时在什么地方寻找二进制代码和命令。这个选项的目的显然是要限制用户运行 sudo 命令的范围，这是一种好做法。\n\n- 2.将Defaults env_reset改成 Defaults !env_reset取消掉对PATH变量的重置，然后在.bashrc中最后添加\n```bash\nalias sudo='sudo env PATH=$PATH'\n```\n这样sudo执行命令时所搜寻的路径就是系统的PATH变量中的路径，如想添加其他变量也是类似。\n\n\n## 7.输入法\n\nFcitx输入法的前端是需要UI动态库支持，您会发现在Fcitx的安装目录中并没有该文件，\n这应该是官方打包的时候就已经遗漏的问题，解决方法就是安装UI动态库支持必须的文件，然后重启Debian系统您的问题将会迎刃而解。\n\n```bash\nTerminal 输入：apt-get install fcitx-ui-classic && apt-get install fcitx-ui-light\n```\n\n## 8.自定义Terminal快捷键\n\n打开系统设置---键盘---快捷键--自定义快捷键\n点加号添加一个自定义快捷键   名称根据自己喜欢起名:Terminal  命令:gnome-terminal   然后自定义一个快捷方式就可以了。\n\n## 9.创建快捷方式\n\n默认情况下，自动安装的软件快捷方式保存在/usr/share/applications目录下，要创建桌面快捷方式，只需要右键-复制-桌面。\n上面的方法是通过系统自动安装软件后实现的，有时候我们自己会从网上下载一些软件手动安装，该怎样创建软件的桌面快捷方式？\n这里以Eclipse 为例，首先到官网下载Eclipse软件包，直接解压在某个目录下，双击其中的eclipse文件，就可以启动eclipse了，\n不过如果每次要打开eclipse，都要从安装目录启动，是不是有些麻烦？依照下面的操作，\n在/usr/share/applications目录下创建一个文件名修为eclipse.desktop ，并添加执行权限。\n\n```bash\n模板：\n\n[Desktop Entry]\nEncoding=UTF-8\nCategories=Development;\nComment[zh_CN]=\nComment=\nExec=/home/xukun/eclipse/eclipse\nGenericName[zh_CN]=IDE\nGenericName=IDE\nIcon=/home/xukun/eclipse/icon.xpm\nMimeType=\nName[zh_CN]=eclipse\nName=eclipse\nPath=\nStartupNotify=true\nTerminal=false\nType=Application\nX-DBUS-ServiceName=\nX-DBUS-StartupType=\nX-KDE-SubstituteUID=false\nX-KDE-Username=xukun\n\n实例\n\n[Desktop Entry]\nEncoding=UTF-8\nName=eclipse\nComment= Eclipse for c++\nExec=/home/xukun/eclipse/eclipse\nIcon=/home/xukun/eclipse/icon.xpm\nTerminal=false\nType=Application\nCategories=Application;Development;\n```\n\n关注3个地方，分别为Exec=软件执行文件的路径，Icon=快捷方式图标（如果有的话），Name=快捷方式名称。\n根据自己软件按转的位置修改代码，以上代码保存后，发现 左上角的 活动 应用程序里面已经有了，\n想添加到左侧的快速启动栏，就右键图标，添加到收藏夹就行了，要创建桌面快捷方式，只需要右键-复制-桌面 就Ok。\n\n## 10.Lantern\n\n直接安装下载好的安装包。下载地址：https://github.com/getlantern/lantern\n若安装了Lantern之后，不能启动起来，一闪而过，命令行里启动，包如下错误：\n\n/.lantern/bin/lantern: error while loading shared libraries: libappindicator3.so.1: cannot open shared\n  object file: No such file or directory\n\n尝试：\n```bash\n$ apt-cache search libappindicator3\ngir1.2-appindicator3-0.1 - Typelib files for libappindicator3-1\nlibappindicator3-1 - allow applications to export a menu into the panel -- GTK3 version\nlibappindicator3-dev - allow applications to export a menu into the panel -- GTK3 development\n\n安装  apt-get install libappindicator3-1\n```\n\n## 11.uget+aria2\n\n```bash\n aptitude install uget\n aptitude install aria2\n ```\n然后启用aria2插件\n\n## 12.开发软件\n\n**Git, rust，VSCode，GNU工具链**\n\n- GNU make：用于编译和构建的自动工具； 检验：make --version/make -v\n\n- GNU编译器集合（GCC）：一组多种编程语言的编译器 检验：gcc --version/gcc -v\n\n- G++：C++语言的编译器 检验：g++ --version/g++ -v\n\n- GNU Binutils：包含链接器、汇编器和其它工具工具集\n\n- GNU Debugger（GDB）：代码调试工具； 检验：gdb --version/gdb -v\n\n**GNU构建系统（autotools）:**\n\n- Autoconf\n- Autoheader\n- Automake\n- Libtool\n","source":"_posts/Use-debian.md","raw":"---\ntitle: Use-debian\ndate: 2015-03-06 9:20\ntags:\n - Linux\n---\n\n## 1.debian的安装：\n\n下载官网的Debian DVD版本用Win32DiskImager软件做成U盘启动安装(或使用 GNOME Multi-Writer)，\n开机设置BIOS的USB启动直接进入安装界面，还可以选择图形界面安装很方便.\n\n## 2.安装网卡驱动实现联网\n\n安装过程中会提示你的有限和无线网卡驱动未安装信息。我的是这两个：rtl_nic/rtl8168d-2.fw和rtlwifi/rtl8192sefw.bin谷歌搜索 可得到链接debian的deb包为firmware-realtek_0.43_all.deb，很方便。安装后重启就能链接无线上网了。\n\n## 3：配置源:\n\n```bash\nsudo nano /etc/apt/sources.list\ndeb http://ftp.cn.debian.org/debian/ testing main non-free contrib\ndeb-src http://ftp.cn.debian.org/debian/ testing main non-free contrib\ndeb http://ftp.cn.debian.org/debian/ testing-proposed-updates main non-free contrib\ndeb-src http://ftp.cn.debian.org/debian/ testing-proposed-updates main non-free contrib\ndeb http://ftp.cn.debian.org/debian/ testing-updates main non-free contrib\ndeb-src http://ftp.cn.debian.org/debian/ testing-updates main non-free contrib\ndeb http://security.debian.org/ testing/updates main contrib non-free\n\n使用Sid，则可将更新列表改为：\ndeb http://ftp.cn.debian.org/debian/ sid main contrib non-free\ndeb http://ftp.cn.debian.org/debian/ sid main contrib non-free\n```\n\n## 4.debian更新:\n\n```bash\n$ sudo aptitude update\n$ sudo aptitude safe-upgrade\n$ sudo aptitude full-upgrade\n```\n\n## 5.驱动问题\n\n```bash\nsudo aptitude install firmware-linux-nonfree\n```\n\n## 6.安装sudo 使普通用户有系统管理的权利\n\n```bash\nroot# aptitude install sudo\nroot# chmod +w /etc/sudoers          授予sudoers 写的权限，否则为只读。\nroot# nano /etc/sudoers               编辑  /etc/sudoers\n找到root 行并在下行输入你的账户,在账户后面把root后面的复制下来就行了,然后保存.\nroot# chmod 0440 /etc/sudoers        去掉sudoers 写的权限改为只读。\nroot# exit                           退到普通账户。\n```\n#### sudo找不到命令：修改sudo的PATH路径\n\nsudo有时候会出现找不到命令，而明明PATH路径下包含该命令，让人疑惑。其实出现这种情况的原因，主要是因为当 sudo以管理权限执行命令的时候，linux将PATH环境变量进行了重置，当然这主要是因为系统安全的考虑，但却使得sudo搜索的路径不是我们想要的PATH变量的路径，当然就找不到我们想要的命令了。两种方法解决该问题：\n\n首先，都要打开sudo的配置文件：sudo visudo\n\n- 1.可以使用 secure_path 指令修改 sudoers 中默认的 PATH为你想要的路径。这个指令指定当用户执行 sudo 命令时在什么地方寻找二进制代码和命令。这个选项的目的显然是要限制用户运行 sudo 命令的范围，这是一种好做法。\n\n- 2.将Defaults env_reset改成 Defaults !env_reset取消掉对PATH变量的重置，然后在.bashrc中最后添加\n```bash\nalias sudo='sudo env PATH=$PATH'\n```\n这样sudo执行命令时所搜寻的路径就是系统的PATH变量中的路径，如想添加其他变量也是类似。\n\n\n## 7.输入法\n\nFcitx输入法的前端是需要UI动态库支持，您会发现在Fcitx的安装目录中并没有该文件，\n这应该是官方打包的时候就已经遗漏的问题，解决方法就是安装UI动态库支持必须的文件，然后重启Debian系统您的问题将会迎刃而解。\n\n```bash\nTerminal 输入：apt-get install fcitx-ui-classic && apt-get install fcitx-ui-light\n```\n\n## 8.自定义Terminal快捷键\n\n打开系统设置---键盘---快捷键--自定义快捷键\n点加号添加一个自定义快捷键   名称根据自己喜欢起名:Terminal  命令:gnome-terminal   然后自定义一个快捷方式就可以了。\n\n## 9.创建快捷方式\n\n默认情况下，自动安装的软件快捷方式保存在/usr/share/applications目录下，要创建桌面快捷方式，只需要右键-复制-桌面。\n上面的方法是通过系统自动安装软件后实现的，有时候我们自己会从网上下载一些软件手动安装，该怎样创建软件的桌面快捷方式？\n这里以Eclipse 为例，首先到官网下载Eclipse软件包，直接解压在某个目录下，双击其中的eclipse文件，就可以启动eclipse了，\n不过如果每次要打开eclipse，都要从安装目录启动，是不是有些麻烦？依照下面的操作，\n在/usr/share/applications目录下创建一个文件名修为eclipse.desktop ，并添加执行权限。\n\n```bash\n模板：\n\n[Desktop Entry]\nEncoding=UTF-8\nCategories=Development;\nComment[zh_CN]=\nComment=\nExec=/home/xukun/eclipse/eclipse\nGenericName[zh_CN]=IDE\nGenericName=IDE\nIcon=/home/xukun/eclipse/icon.xpm\nMimeType=\nName[zh_CN]=eclipse\nName=eclipse\nPath=\nStartupNotify=true\nTerminal=false\nType=Application\nX-DBUS-ServiceName=\nX-DBUS-StartupType=\nX-KDE-SubstituteUID=false\nX-KDE-Username=xukun\n\n实例\n\n[Desktop Entry]\nEncoding=UTF-8\nName=eclipse\nComment= Eclipse for c++\nExec=/home/xukun/eclipse/eclipse\nIcon=/home/xukun/eclipse/icon.xpm\nTerminal=false\nType=Application\nCategories=Application;Development;\n```\n\n关注3个地方，分别为Exec=软件执行文件的路径，Icon=快捷方式图标（如果有的话），Name=快捷方式名称。\n根据自己软件按转的位置修改代码，以上代码保存后，发现 左上角的 活动 应用程序里面已经有了，\n想添加到左侧的快速启动栏，就右键图标，添加到收藏夹就行了，要创建桌面快捷方式，只需要右键-复制-桌面 就Ok。\n\n## 10.Lantern\n\n直接安装下载好的安装包。下载地址：https://github.com/getlantern/lantern\n若安装了Lantern之后，不能启动起来，一闪而过，命令行里启动，包如下错误：\n\n/.lantern/bin/lantern: error while loading shared libraries: libappindicator3.so.1: cannot open shared\n  object file: No such file or directory\n\n尝试：\n```bash\n$ apt-cache search libappindicator3\ngir1.2-appindicator3-0.1 - Typelib files for libappindicator3-1\nlibappindicator3-1 - allow applications to export a menu into the panel -- GTK3 version\nlibappindicator3-dev - allow applications to export a menu into the panel -- GTK3 development\n\n安装  apt-get install libappindicator3-1\n```\n\n## 11.uget+aria2\n\n```bash\n aptitude install uget\n aptitude install aria2\n ```\n然后启用aria2插件\n\n## 12.开发软件\n\n**Git, rust，VSCode，GNU工具链**\n\n- GNU make：用于编译和构建的自动工具； 检验：make --version/make -v\n\n- GNU编译器集合（GCC）：一组多种编程语言的编译器 检验：gcc --version/gcc -v\n\n- G++：C++语言的编译器 检验：g++ --version/g++ -v\n\n- GNU Binutils：包含链接器、汇编器和其它工具工具集\n\n- GNU Debugger（GDB）：代码调试工具； 检验：gdb --version/gdb -v\n\n**GNU构建系统（autotools）:**\n\n- Autoconf\n- Autoheader\n- Automake\n- Libtool\n","slug":"Use-debian","published":1,"updated":"2017-09-09T14:41:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8dw0nfu000bqnjx40qhf1i0","content":"<h2 id=\"1-debian的安装：\"><a href=\"#1-debian的安装：\" class=\"headerlink\" title=\"1.debian的安装：\"></a>1.debian的安装：</h2><p>下载官网的Debian DVD版本用Win32DiskImager软件做成U盘启动安装(或使用 GNOME Multi-Writer)，<br>开机设置BIOS的USB启动直接进入安装界面，还可以选择图形界面安装很方便.</p>\n<h2 id=\"2-安装网卡驱动实现联网\"><a href=\"#2-安装网卡驱动实现联网\" class=\"headerlink\" title=\"2.安装网卡驱动实现联网\"></a>2.安装网卡驱动实现联网</h2><p>安装过程中会提示你的有限和无线网卡驱动未安装信息。我的是这两个：rtl_nic/rtl8168d-2.fw和rtlwifi/rtl8192sefw.bin谷歌搜索 可得到链接debian的deb包为firmware-realtek_0.43_all.deb，很方便。安装后重启就能链接无线上网了。</p>\n<h2 id=\"3：配置源\"><a href=\"#3：配置源\" class=\"headerlink\" title=\"3：配置源:\"></a>3：配置源:</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo nano /etc/apt/sources.list</div><div class=\"line\">deb http://ftp.cn.debian.org/debian/ testing main non-free contrib</div><div class=\"line\">deb-src http://ftp.cn.debian.org/debian/ testing main non-free contrib</div><div class=\"line\">deb http://ftp.cn.debian.org/debian/ testing-proposed-updates main non-free contrib</div><div class=\"line\">deb-src http://ftp.cn.debian.org/debian/ testing-proposed-updates main non-free contrib</div><div class=\"line\">deb http://ftp.cn.debian.org/debian/ testing-updates main non-free contrib</div><div class=\"line\">deb-src http://ftp.cn.debian.org/debian/ testing-updates main non-free contrib</div><div class=\"line\">deb http://security.debian.org/ testing/updates main contrib non-free</div><div class=\"line\"></div><div class=\"line\">使用Sid，则可将更新列表改为：</div><div class=\"line\">deb http://ftp.cn.debian.org/debian/ sid main contrib non-free</div><div class=\"line\">deb http://ftp.cn.debian.org/debian/ sid main contrib non-free</div></pre></td></tr></table></figure>\n<h2 id=\"4-debian更新\"><a href=\"#4-debian更新\" class=\"headerlink\" title=\"4.debian更新:\"></a>4.debian更新:</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo aptitude update</div><div class=\"line\">$ sudo aptitude safe-upgrade</div><div class=\"line\">$ sudo aptitude full-upgrade</div></pre></td></tr></table></figure>\n<h2 id=\"5-驱动问题\"><a href=\"#5-驱动问题\" class=\"headerlink\" title=\"5.驱动问题\"></a>5.驱动问题</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo aptitude install firmware-linux-nonfree</div></pre></td></tr></table></figure>\n<h2 id=\"6-安装sudo-使普通用户有系统管理的权利\"><a href=\"#6-安装sudo-使普通用户有系统管理的权利\" class=\"headerlink\" title=\"6.安装sudo 使普通用户有系统管理的权利\"></a>6.安装sudo 使普通用户有系统管理的权利</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">root<span class=\"comment\"># aptitude install sudo</span></div><div class=\"line\">root<span class=\"comment\"># chmod +w /etc/sudoers          授予sudoers 写的权限，否则为只读。</span></div><div class=\"line\">root<span class=\"comment\"># nano /etc/sudoers               编辑  /etc/sudoers</span></div><div class=\"line\">找到root 行并在下行输入你的账户,在账户后面把root后面的复制下来就行了,然后保存.</div><div class=\"line\">root<span class=\"comment\"># chmod 0440 /etc/sudoers        去掉sudoers 写的权限改为只读。</span></div><div class=\"line\">root<span class=\"comment\"># exit                           退到普通账户。</span></div></pre></td></tr></table></figure>\n<h4 id=\"sudo找不到命令：修改sudo的PATH路径\"><a href=\"#sudo找不到命令：修改sudo的PATH路径\" class=\"headerlink\" title=\"sudo找不到命令：修改sudo的PATH路径\"></a>sudo找不到命令：修改sudo的PATH路径</h4><p>sudo有时候会出现找不到命令，而明明PATH路径下包含该命令，让人疑惑。其实出现这种情况的原因，主要是因为当 sudo以管理权限执行命令的时候，linux将PATH环境变量进行了重置，当然这主要是因为系统安全的考虑，但却使得sudo搜索的路径不是我们想要的PATH变量的路径，当然就找不到我们想要的命令了。两种方法解决该问题：</p>\n<p>首先，都要打开sudo的配置文件：sudo visudo</p>\n<ul>\n<li><p>1.可以使用 secure_path 指令修改 sudoers 中默认的 PATH为你想要的路径。这个指令指定当用户执行 sudo 命令时在什么地方寻找二进制代码和命令。这个选项的目的显然是要限制用户运行 sudo 命令的范围，这是一种好做法。</p>\n</li>\n<li><p>2.将Defaults env_reset改成 Defaults !env_reset取消掉对PATH变量的重置，然后在.bashrc中最后添加</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">alias</span> sudo=<span class=\"string\">'sudo env PATH=$PATH'</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样sudo执行命令时所搜寻的路径就是系统的PATH变量中的路径，如想添加其他变量也是类似。</p>\n<h2 id=\"7-输入法\"><a href=\"#7-输入法\" class=\"headerlink\" title=\"7.输入法\"></a>7.输入法</h2><p>Fcitx输入法的前端是需要UI动态库支持，您会发现在Fcitx的安装目录中并没有该文件，<br>这应该是官方打包的时候就已经遗漏的问题，解决方法就是安装UI动态库支持必须的文件，然后重启Debian系统您的问题将会迎刃而解。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Terminal 输入：apt-get install fcitx-ui-classic &amp;&amp; apt-get install fcitx-ui-light</div></pre></td></tr></table></figure>\n<h2 id=\"8-自定义Terminal快捷键\"><a href=\"#8-自定义Terminal快捷键\" class=\"headerlink\" title=\"8.自定义Terminal快捷键\"></a>8.自定义Terminal快捷键</h2><p>打开系统设置—键盘—快捷键–自定义快捷键<br>点加号添加一个自定义快捷键   名称根据自己喜欢起名:Terminal  命令:gnome-terminal   然后自定义一个快捷方式就可以了。</p>\n<h2 id=\"9-创建快捷方式\"><a href=\"#9-创建快捷方式\" class=\"headerlink\" title=\"9.创建快捷方式\"></a>9.创建快捷方式</h2><p>默认情况下，自动安装的软件快捷方式保存在/usr/share/applications目录下，要创建桌面快捷方式，只需要右键-复制-桌面。<br>上面的方法是通过系统自动安装软件后实现的，有时候我们自己会从网上下载一些软件手动安装，该怎样创建软件的桌面快捷方式？<br>这里以Eclipse 为例，首先到官网下载Eclipse软件包，直接解压在某个目录下，双击其中的eclipse文件，就可以启动eclipse了，<br>不过如果每次要打开eclipse，都要从安装目录启动，是不是有些麻烦？依照下面的操作，<br>在/usr/share/applications目录下创建一个文件名修为eclipse.desktop ，并添加执行权限。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">模板：</div><div class=\"line\"></div><div class=\"line\">[Desktop Entry]</div><div class=\"line\">Encoding=UTF-8</div><div class=\"line\">Categories=Development;</div><div class=\"line\">Comment[zh_CN]=</div><div class=\"line\">Comment=</div><div class=\"line\">Exec=/home/xukun/eclipse/eclipse</div><div class=\"line\">GenericName[zh_CN]=IDE</div><div class=\"line\">GenericName=IDE</div><div class=\"line\">Icon=/home/xukun/eclipse/icon.xpm</div><div class=\"line\">MimeType=</div><div class=\"line\">Name[zh_CN]=eclipse</div><div class=\"line\">Name=eclipse</div><div class=\"line\">Path=</div><div class=\"line\">StartupNotify=<span class=\"literal\">true</span></div><div class=\"line\">Terminal=<span class=\"literal\">false</span></div><div class=\"line\">Type=Application</div><div class=\"line\">X-DBUS-ServiceName=</div><div class=\"line\">X-DBUS-StartupType=</div><div class=\"line\">X-KDE-SubstituteUID=<span class=\"literal\">false</span></div><div class=\"line\">X-KDE-Username=xukun</div><div class=\"line\"></div><div class=\"line\">实例</div><div class=\"line\"></div><div class=\"line\">[Desktop Entry]</div><div class=\"line\">Encoding=UTF-8</div><div class=\"line\">Name=eclipse</div><div class=\"line\">Comment= Eclipse <span class=\"keyword\">for</span> c++</div><div class=\"line\">Exec=/home/xukun/eclipse/eclipse</div><div class=\"line\">Icon=/home/xukun/eclipse/icon.xpm</div><div class=\"line\">Terminal=<span class=\"literal\">false</span></div><div class=\"line\">Type=Application</div><div class=\"line\">Categories=Application;Development;</div></pre></td></tr></table></figure>\n<p>关注3个地方，分别为Exec=软件执行文件的路径，Icon=快捷方式图标（如果有的话），Name=快捷方式名称。<br>根据自己软件按转的位置修改代码，以上代码保存后，发现 左上角的 活动 应用程序里面已经有了，<br>想添加到左侧的快速启动栏，就右键图标，添加到收藏夹就行了，要创建桌面快捷方式，只需要右键-复制-桌面 就Ok。</p>\n<h2 id=\"10-Lantern\"><a href=\"#10-Lantern\" class=\"headerlink\" title=\"10.Lantern\"></a>10.Lantern</h2><p>直接安装下载好的安装包。下载地址：<a href=\"https://github.com/getlantern/lantern\" target=\"_blank\" rel=\"external\">https://github.com/getlantern/lantern</a><br>若安装了Lantern之后，不能启动起来，一闪而过，命令行里启动，包如下错误：</p>\n<p>/.lantern/bin/lantern: error while loading shared libraries: libappindicator3.so.1: cannot open shared<br>  object file: No such file or directory</p>\n<p>尝试：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ apt-cache search libappindicator3</div><div class=\"line\">gir1.2-appindicator3-0.1 - Typelib files <span class=\"keyword\">for</span> libappindicator3-1</div><div class=\"line\">libappindicator3-1 - allow applications to <span class=\"built_in\">export</span> a menu into the panel -- GTK3 version</div><div class=\"line\">libappindicator3-dev - allow applications to <span class=\"built_in\">export</span> a menu into the panel -- GTK3 development</div><div class=\"line\"></div><div class=\"line\">安装  apt-get install libappindicator3-1</div></pre></td></tr></table></figure></p>\n<h2 id=\"11-uget-aria2\"><a href=\"#11-uget-aria2\" class=\"headerlink\" title=\"11.uget+aria2\"></a>11.uget+aria2</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">aptitude install uget</div><div class=\"line\">aptitude install aria2</div></pre></td></tr></table></figure>\n<p>然后启用aria2插件</p>\n<h2 id=\"12-开发软件\"><a href=\"#12-开发软件\" class=\"headerlink\" title=\"12.开发软件\"></a>12.开发软件</h2><p><strong>Git, rust，VSCode，GNU工具链</strong></p>\n<ul>\n<li><p>GNU make：用于编译和构建的自动工具； 检验：make –version/make -v</p>\n</li>\n<li><p>GNU编译器集合（GCC）：一组多种编程语言的编译器 检验：gcc –version/gcc -v</p>\n</li>\n<li><p>G++：C++语言的编译器 检验：g++ –version/g++ -v</p>\n</li>\n<li><p>GNU Binutils：包含链接器、汇编器和其它工具工具集</p>\n</li>\n<li><p>GNU Debugger（GDB）：代码调试工具； 检验：gdb –version/gdb -v</p>\n</li>\n</ul>\n<p><strong>GNU构建系统（autotools）:</strong></p>\n<ul>\n<li>Autoconf</li>\n<li>Autoheader</li>\n<li>Automake</li>\n<li>Libtool</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-debian的安装：\"><a href=\"#1-debian的安装：\" class=\"headerlink\" title=\"1.debian的安装：\"></a>1.debian的安装：</h2><p>下载官网的Debian DVD版本用Win32DiskImager软件做成U盘启动安装(或使用 GNOME Multi-Writer)，<br>开机设置BIOS的USB启动直接进入安装界面，还可以选择图形界面安装很方便.</p>\n<h2 id=\"2-安装网卡驱动实现联网\"><a href=\"#2-安装网卡驱动实现联网\" class=\"headerlink\" title=\"2.安装网卡驱动实现联网\"></a>2.安装网卡驱动实现联网</h2><p>安装过程中会提示你的有限和无线网卡驱动未安装信息。我的是这两个：rtl_nic/rtl8168d-2.fw和rtlwifi/rtl8192sefw.bin谷歌搜索 可得到链接debian的deb包为firmware-realtek_0.43_all.deb，很方便。安装后重启就能链接无线上网了。</p>\n<h2 id=\"3：配置源\"><a href=\"#3：配置源\" class=\"headerlink\" title=\"3：配置源:\"></a>3：配置源:</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo nano /etc/apt/sources.list</div><div class=\"line\">deb http://ftp.cn.debian.org/debian/ testing main non-free contrib</div><div class=\"line\">deb-src http://ftp.cn.debian.org/debian/ testing main non-free contrib</div><div class=\"line\">deb http://ftp.cn.debian.org/debian/ testing-proposed-updates main non-free contrib</div><div class=\"line\">deb-src http://ftp.cn.debian.org/debian/ testing-proposed-updates main non-free contrib</div><div class=\"line\">deb http://ftp.cn.debian.org/debian/ testing-updates main non-free contrib</div><div class=\"line\">deb-src http://ftp.cn.debian.org/debian/ testing-updates main non-free contrib</div><div class=\"line\">deb http://security.debian.org/ testing/updates main contrib non-free</div><div class=\"line\"></div><div class=\"line\">使用Sid，则可将更新列表改为：</div><div class=\"line\">deb http://ftp.cn.debian.org/debian/ sid main contrib non-free</div><div class=\"line\">deb http://ftp.cn.debian.org/debian/ sid main contrib non-free</div></pre></td></tr></table></figure>\n<h2 id=\"4-debian更新\"><a href=\"#4-debian更新\" class=\"headerlink\" title=\"4.debian更新:\"></a>4.debian更新:</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo aptitude update</div><div class=\"line\">$ sudo aptitude safe-upgrade</div><div class=\"line\">$ sudo aptitude full-upgrade</div></pre></td></tr></table></figure>\n<h2 id=\"5-驱动问题\"><a href=\"#5-驱动问题\" class=\"headerlink\" title=\"5.驱动问题\"></a>5.驱动问题</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo aptitude install firmware-linux-nonfree</div></pre></td></tr></table></figure>\n<h2 id=\"6-安装sudo-使普通用户有系统管理的权利\"><a href=\"#6-安装sudo-使普通用户有系统管理的权利\" class=\"headerlink\" title=\"6.安装sudo 使普通用户有系统管理的权利\"></a>6.安装sudo 使普通用户有系统管理的权利</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">root<span class=\"comment\"># aptitude install sudo</span></div><div class=\"line\">root<span class=\"comment\"># chmod +w /etc/sudoers          授予sudoers 写的权限，否则为只读。</span></div><div class=\"line\">root<span class=\"comment\"># nano /etc/sudoers               编辑  /etc/sudoers</span></div><div class=\"line\">找到root 行并在下行输入你的账户,在账户后面把root后面的复制下来就行了,然后保存.</div><div class=\"line\">root<span class=\"comment\"># chmod 0440 /etc/sudoers        去掉sudoers 写的权限改为只读。</span></div><div class=\"line\">root<span class=\"comment\"># exit                           退到普通账户。</span></div></pre></td></tr></table></figure>\n<h4 id=\"sudo找不到命令：修改sudo的PATH路径\"><a href=\"#sudo找不到命令：修改sudo的PATH路径\" class=\"headerlink\" title=\"sudo找不到命令：修改sudo的PATH路径\"></a>sudo找不到命令：修改sudo的PATH路径</h4><p>sudo有时候会出现找不到命令，而明明PATH路径下包含该命令，让人疑惑。其实出现这种情况的原因，主要是因为当 sudo以管理权限执行命令的时候，linux将PATH环境变量进行了重置，当然这主要是因为系统安全的考虑，但却使得sudo搜索的路径不是我们想要的PATH变量的路径，当然就找不到我们想要的命令了。两种方法解决该问题：</p>\n<p>首先，都要打开sudo的配置文件：sudo visudo</p>\n<ul>\n<li><p>1.可以使用 secure_path 指令修改 sudoers 中默认的 PATH为你想要的路径。这个指令指定当用户执行 sudo 命令时在什么地方寻找二进制代码和命令。这个选项的目的显然是要限制用户运行 sudo 命令的范围，这是一种好做法。</p>\n</li>\n<li><p>2.将Defaults env_reset改成 Defaults !env_reset取消掉对PATH变量的重置，然后在.bashrc中最后添加</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">alias</span> sudo=<span class=\"string\">'sudo env PATH=$PATH'</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样sudo执行命令时所搜寻的路径就是系统的PATH变量中的路径，如想添加其他变量也是类似。</p>\n<h2 id=\"7-输入法\"><a href=\"#7-输入法\" class=\"headerlink\" title=\"7.输入法\"></a>7.输入法</h2><p>Fcitx输入法的前端是需要UI动态库支持，您会发现在Fcitx的安装目录中并没有该文件，<br>这应该是官方打包的时候就已经遗漏的问题，解决方法就是安装UI动态库支持必须的文件，然后重启Debian系统您的问题将会迎刃而解。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Terminal 输入：apt-get install fcitx-ui-classic &amp;&amp; apt-get install fcitx-ui-light</div></pre></td></tr></table></figure>\n<h2 id=\"8-自定义Terminal快捷键\"><a href=\"#8-自定义Terminal快捷键\" class=\"headerlink\" title=\"8.自定义Terminal快捷键\"></a>8.自定义Terminal快捷键</h2><p>打开系统设置—键盘—快捷键–自定义快捷键<br>点加号添加一个自定义快捷键   名称根据自己喜欢起名:Terminal  命令:gnome-terminal   然后自定义一个快捷方式就可以了。</p>\n<h2 id=\"9-创建快捷方式\"><a href=\"#9-创建快捷方式\" class=\"headerlink\" title=\"9.创建快捷方式\"></a>9.创建快捷方式</h2><p>默认情况下，自动安装的软件快捷方式保存在/usr/share/applications目录下，要创建桌面快捷方式，只需要右键-复制-桌面。<br>上面的方法是通过系统自动安装软件后实现的，有时候我们自己会从网上下载一些软件手动安装，该怎样创建软件的桌面快捷方式？<br>这里以Eclipse 为例，首先到官网下载Eclipse软件包，直接解压在某个目录下，双击其中的eclipse文件，就可以启动eclipse了，<br>不过如果每次要打开eclipse，都要从安装目录启动，是不是有些麻烦？依照下面的操作，<br>在/usr/share/applications目录下创建一个文件名修为eclipse.desktop ，并添加执行权限。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">模板：</div><div class=\"line\"></div><div class=\"line\">[Desktop Entry]</div><div class=\"line\">Encoding=UTF-8</div><div class=\"line\">Categories=Development;</div><div class=\"line\">Comment[zh_CN]=</div><div class=\"line\">Comment=</div><div class=\"line\">Exec=/home/xukun/eclipse/eclipse</div><div class=\"line\">GenericName[zh_CN]=IDE</div><div class=\"line\">GenericName=IDE</div><div class=\"line\">Icon=/home/xukun/eclipse/icon.xpm</div><div class=\"line\">MimeType=</div><div class=\"line\">Name[zh_CN]=eclipse</div><div class=\"line\">Name=eclipse</div><div class=\"line\">Path=</div><div class=\"line\">StartupNotify=<span class=\"literal\">true</span></div><div class=\"line\">Terminal=<span class=\"literal\">false</span></div><div class=\"line\">Type=Application</div><div class=\"line\">X-DBUS-ServiceName=</div><div class=\"line\">X-DBUS-StartupType=</div><div class=\"line\">X-KDE-SubstituteUID=<span class=\"literal\">false</span></div><div class=\"line\">X-KDE-Username=xukun</div><div class=\"line\"></div><div class=\"line\">实例</div><div class=\"line\"></div><div class=\"line\">[Desktop Entry]</div><div class=\"line\">Encoding=UTF-8</div><div class=\"line\">Name=eclipse</div><div class=\"line\">Comment= Eclipse <span class=\"keyword\">for</span> c++</div><div class=\"line\">Exec=/home/xukun/eclipse/eclipse</div><div class=\"line\">Icon=/home/xukun/eclipse/icon.xpm</div><div class=\"line\">Terminal=<span class=\"literal\">false</span></div><div class=\"line\">Type=Application</div><div class=\"line\">Categories=Application;Development;</div></pre></td></tr></table></figure>\n<p>关注3个地方，分别为Exec=软件执行文件的路径，Icon=快捷方式图标（如果有的话），Name=快捷方式名称。<br>根据自己软件按转的位置修改代码，以上代码保存后，发现 左上角的 活动 应用程序里面已经有了，<br>想添加到左侧的快速启动栏，就右键图标，添加到收藏夹就行了，要创建桌面快捷方式，只需要右键-复制-桌面 就Ok。</p>\n<h2 id=\"10-Lantern\"><a href=\"#10-Lantern\" class=\"headerlink\" title=\"10.Lantern\"></a>10.Lantern</h2><p>直接安装下载好的安装包。下载地址：<a href=\"https://github.com/getlantern/lantern\" target=\"_blank\" rel=\"external\">https://github.com/getlantern/lantern</a><br>若安装了Lantern之后，不能启动起来，一闪而过，命令行里启动，包如下错误：</p>\n<p>/.lantern/bin/lantern: error while loading shared libraries: libappindicator3.so.1: cannot open shared<br>  object file: No such file or directory</p>\n<p>尝试：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ apt-cache search libappindicator3</div><div class=\"line\">gir1.2-appindicator3-0.1 - Typelib files <span class=\"keyword\">for</span> libappindicator3-1</div><div class=\"line\">libappindicator3-1 - allow applications to <span class=\"built_in\">export</span> a menu into the panel -- GTK3 version</div><div class=\"line\">libappindicator3-dev - allow applications to <span class=\"built_in\">export</span> a menu into the panel -- GTK3 development</div><div class=\"line\"></div><div class=\"line\">安装  apt-get install libappindicator3-1</div></pre></td></tr></table></figure></p>\n<h2 id=\"11-uget-aria2\"><a href=\"#11-uget-aria2\" class=\"headerlink\" title=\"11.uget+aria2\"></a>11.uget+aria2</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">aptitude install uget</div><div class=\"line\">aptitude install aria2</div></pre></td></tr></table></figure>\n<p>然后启用aria2插件</p>\n<h2 id=\"12-开发软件\"><a href=\"#12-开发软件\" class=\"headerlink\" title=\"12.开发软件\"></a>12.开发软件</h2><p><strong>Git, rust，VSCode，GNU工具链</strong></p>\n<ul>\n<li><p>GNU make：用于编译和构建的自动工具； 检验：make –version/make -v</p>\n</li>\n<li><p>GNU编译器集合（GCC）：一组多种编程语言的编译器 检验：gcc –version/gcc -v</p>\n</li>\n<li><p>G++：C++语言的编译器 检验：g++ –version/g++ -v</p>\n</li>\n<li><p>GNU Binutils：包含链接器、汇编器和其它工具工具集</p>\n</li>\n<li><p>GNU Debugger（GDB）：代码调试工具； 检验：gdb –version/gdb -v</p>\n</li>\n</ul>\n<p><strong>GNU构建系统（autotools）:</strong></p>\n<ul>\n<li>Autoconf</li>\n<li>Autoheader</li>\n<li>Automake</li>\n<li>Libtool</li>\n</ul>\n"},{"title":"使用nvm管理不同版本的node与npm","date":"2016-06-10T13:40:00.000Z","_content":"\n在我们的日常开发中经常会遇到这种情况：手上有好几个项目，每个项目的需求不同，进而不同项目必须依赖不同版的 NodeJS 运行环境。如果没有一个合适的工具，这个问题将非常棘手。\n\n## nvm 与 n 的区别\n\nnode 版本管理工具还有一个是 n 命令，n 命令是作为一个 node 的模块而存在，而 nvm 是一个独立于 node/npm 的外部 bash 脚本，因此 n 命令相比 nvm 更加局限。\n\n由于 npm 安装的模块路径均为 /usr/local/lib/node_modules，当使用 n 切换不同的 node 版本时，实际上会共用全局的 node/npm 目录。 因此不能很好的满足『按不同 node 版本使用不同全局 node 模块』的需求。\n\n## 卸载全局安装的 node/npm\n\n在官网下载的 node 安装包，运行后会自动安装在全局目录，使用过程中经常会遇到一些权限问题，所以推荐卸载全局安装的 node/npm。\n\n## Linux 安装\n\n我们并不一定要先卸载原有的 NodeJS。当然我们推荐还是先卸载掉比较好。另外，你还需要 C++ 编译器，Linux 发行版一般不用担心，像 Ubuntu 都可以直接用 build-essential 套件\n\n在 Linux 中：（如果是 Debian 发行版）\n\n```bash\nsudo apt-get install build-essential\n```\n然后我们可以使用\n\n```bash\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash\n```\n\n或者\n\n```bash\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash\n```\n\n从远程下载 install.sh 脚本并执行。注意这个版本年数字 v0.33.0 会随着项目开发而变化。随时通过[官方最新安装命令](https://github.com/creationix/nvm#install-script)来检查最新安装版本是有好处的。\n\n## 安装多版本 node/npm\n\n例如，我们要安装4.2.2版本，可以用如下命令：\n\n```bash\nnvm install 4.2.2\n```\nnvm 遵守语义化版本命名规则。例如，你想安装最新的 4.2 系列的最新的一个版本的话，可以运行：\n```bash\nnvm install 4.2\n```\nnvm 会寻找 4.2.x 中最高的版本来安装。\n\n你可以通过以下命令来列出远程服务器上所有的可用版本：\n```bash\nnvm ls-remote\n```\n\n## 在不同版本间切换\n\n每当我们安装了一个新版本 Node 后，全局环境会自动把这个新版本设置为默认。\n\nnvm 提供了 nvm use 命令。这个命令的使用方法和 install 命令类似。\n\n例如，切换到 4.2.2：\n```bash\nnvm use 4.2.2\n```\n切换到最新的 `4.2.x``：\n\n```bash\nnvm use 4.2\n```\n\n切换到最新版：\n```bash\nnvm use node\n```\n\n每次执行切换的时候，系统都会把 node 的可执行文件链接放到特定版本的文件上。\n\n我们还可以用 nvm 给不同的版本号设置别名：\n```bash\nnvm alias awesome-version 4.2.2\n```\n\n我们给 4.2.2 这个版本号起了一个名字叫做 awesome-version，然后我们可以运行：\n\n```bash\nnvm use awesome-version\n```\n\n下面这个命令可以取消别名：\n\n```bash\nnvm unalias awesome-version\n```\n另外，你还可以设置 default 这个特殊别名：\n\n```bash\nnvm alias default node\n```\n\n## 列出已安装实例\n\n```bash\nnvm ls\n```\n\n上面绿色箭头是当前正在使用的版本，下面列出的还有设置过的别名。\n\n## 在项目中使用不同版本的 Node\n\n我们可以通过创建项目目录中的 .nvmrc 文件来指定要使用的 Node 版本。之后在项目目录中执行 nvm use 即可。.nvmrc 文件内容只需要遵守上文提到的语义化版本规则即可。另外还有个工具叫做 avn，可以自动化这个过程。\n\n## 在多环境中，使用npm\n\n每个版本的 Node 都会自带一个不同版本的 npm，可以用 npm -v 来查看 npm 的版本。全局安装的 npm 包并不会在不同的 Node 环境中共享，因为这会引起兼容问题。它们被放在了不同版本的目录下，例如 ~/.nvm/versions/node/<version>/lib/node_modules</version> 这样的目录。这刚好也省去我们在 Linux 中使用 sudo 的功夫了。因为这是用户的主文件夹，并不会引起权限问题。\n\n但问题来了，我们安装过的 npm 包，都要重新再装一次？幸运的是，我们有个办法来解决我们的问题，运行下面这个命令，可以从特定版本导入到我们将要安装的新版本 Node：\n\n```bash\nnvm install v5.0.0 --reinstall-packages-from=4.2\n```\n\n## 其他命令\n\n直接运行特定版本的 Node\n\n```bash\nnvm run 4.2.2 --version\n```\n\n在当前终端的子进程中运行特定版本的 Node\n\n```bash\nnvm exec 4.2.2 node --version\n```\n确认某个版本Node的路径\n\n```bash\nnvm which 4.2.2\n```","source":"_posts/用nvm管理不同版本的node.md","raw":"---\ntitle: 使用nvm管理不同版本的node与npm\ndate: 2016-06-10 21:40\ntags:\n - Node\n---\n\n在我们的日常开发中经常会遇到这种情况：手上有好几个项目，每个项目的需求不同，进而不同项目必须依赖不同版的 NodeJS 运行环境。如果没有一个合适的工具，这个问题将非常棘手。\n\n## nvm 与 n 的区别\n\nnode 版本管理工具还有一个是 n 命令，n 命令是作为一个 node 的模块而存在，而 nvm 是一个独立于 node/npm 的外部 bash 脚本，因此 n 命令相比 nvm 更加局限。\n\n由于 npm 安装的模块路径均为 /usr/local/lib/node_modules，当使用 n 切换不同的 node 版本时，实际上会共用全局的 node/npm 目录。 因此不能很好的满足『按不同 node 版本使用不同全局 node 模块』的需求。\n\n## 卸载全局安装的 node/npm\n\n在官网下载的 node 安装包，运行后会自动安装在全局目录，使用过程中经常会遇到一些权限问题，所以推荐卸载全局安装的 node/npm。\n\n## Linux 安装\n\n我们并不一定要先卸载原有的 NodeJS。当然我们推荐还是先卸载掉比较好。另外，你还需要 C++ 编译器，Linux 发行版一般不用担心，像 Ubuntu 都可以直接用 build-essential 套件\n\n在 Linux 中：（如果是 Debian 发行版）\n\n```bash\nsudo apt-get install build-essential\n```\n然后我们可以使用\n\n```bash\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash\n```\n\n或者\n\n```bash\nwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash\n```\n\n从远程下载 install.sh 脚本并执行。注意这个版本年数字 v0.33.0 会随着项目开发而变化。随时通过[官方最新安装命令](https://github.com/creationix/nvm#install-script)来检查最新安装版本是有好处的。\n\n## 安装多版本 node/npm\n\n例如，我们要安装4.2.2版本，可以用如下命令：\n\n```bash\nnvm install 4.2.2\n```\nnvm 遵守语义化版本命名规则。例如，你想安装最新的 4.2 系列的最新的一个版本的话，可以运行：\n```bash\nnvm install 4.2\n```\nnvm 会寻找 4.2.x 中最高的版本来安装。\n\n你可以通过以下命令来列出远程服务器上所有的可用版本：\n```bash\nnvm ls-remote\n```\n\n## 在不同版本间切换\n\n每当我们安装了一个新版本 Node 后，全局环境会自动把这个新版本设置为默认。\n\nnvm 提供了 nvm use 命令。这个命令的使用方法和 install 命令类似。\n\n例如，切换到 4.2.2：\n```bash\nnvm use 4.2.2\n```\n切换到最新的 `4.2.x``：\n\n```bash\nnvm use 4.2\n```\n\n切换到最新版：\n```bash\nnvm use node\n```\n\n每次执行切换的时候，系统都会把 node 的可执行文件链接放到特定版本的文件上。\n\n我们还可以用 nvm 给不同的版本号设置别名：\n```bash\nnvm alias awesome-version 4.2.2\n```\n\n我们给 4.2.2 这个版本号起了一个名字叫做 awesome-version，然后我们可以运行：\n\n```bash\nnvm use awesome-version\n```\n\n下面这个命令可以取消别名：\n\n```bash\nnvm unalias awesome-version\n```\n另外，你还可以设置 default 这个特殊别名：\n\n```bash\nnvm alias default node\n```\n\n## 列出已安装实例\n\n```bash\nnvm ls\n```\n\n上面绿色箭头是当前正在使用的版本，下面列出的还有设置过的别名。\n\n## 在项目中使用不同版本的 Node\n\n我们可以通过创建项目目录中的 .nvmrc 文件来指定要使用的 Node 版本。之后在项目目录中执行 nvm use 即可。.nvmrc 文件内容只需要遵守上文提到的语义化版本规则即可。另外还有个工具叫做 avn，可以自动化这个过程。\n\n## 在多环境中，使用npm\n\n每个版本的 Node 都会自带一个不同版本的 npm，可以用 npm -v 来查看 npm 的版本。全局安装的 npm 包并不会在不同的 Node 环境中共享，因为这会引起兼容问题。它们被放在了不同版本的目录下，例如 ~/.nvm/versions/node/<version>/lib/node_modules</version> 这样的目录。这刚好也省去我们在 Linux 中使用 sudo 的功夫了。因为这是用户的主文件夹，并不会引起权限问题。\n\n但问题来了，我们安装过的 npm 包，都要重新再装一次？幸运的是，我们有个办法来解决我们的问题，运行下面这个命令，可以从特定版本导入到我们将要安装的新版本 Node：\n\n```bash\nnvm install v5.0.0 --reinstall-packages-from=4.2\n```\n\n## 其他命令\n\n直接运行特定版本的 Node\n\n```bash\nnvm run 4.2.2 --version\n```\n\n在当前终端的子进程中运行特定版本的 Node\n\n```bash\nnvm exec 4.2.2 node --version\n```\n确认某个版本Node的路径\n\n```bash\nnvm which 4.2.2\n```","slug":"用nvm管理不同版本的node","published":1,"updated":"2017-06-22T07:45:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8dw0nfw000cqnjxkdhh44w3","content":"<p>在我们的日常开发中经常会遇到这种情况：手上有好几个项目，每个项目的需求不同，进而不同项目必须依赖不同版的 NodeJS 运行环境。如果没有一个合适的工具，这个问题将非常棘手。</p>\n<h2 id=\"nvm-与-n-的区别\"><a href=\"#nvm-与-n-的区别\" class=\"headerlink\" title=\"nvm 与 n 的区别\"></a>nvm 与 n 的区别</h2><p>node 版本管理工具还有一个是 n 命令，n 命令是作为一个 node 的模块而存在，而 nvm 是一个独立于 node/npm 的外部 bash 脚本，因此 n 命令相比 nvm 更加局限。</p>\n<p>由于 npm 安装的模块路径均为 /usr/local/lib/node_modules，当使用 n 切换不同的 node 版本时，实际上会共用全局的 node/npm 目录。 因此不能很好的满足『按不同 node 版本使用不同全局 node 模块』的需求。</p>\n<h2 id=\"卸载全局安装的-node-npm\"><a href=\"#卸载全局安装的-node-npm\" class=\"headerlink\" title=\"卸载全局安装的 node/npm\"></a>卸载全局安装的 node/npm</h2><p>在官网下载的 node 安装包，运行后会自动安装在全局目录，使用过程中经常会遇到一些权限问题，所以推荐卸载全局安装的 node/npm。</p>\n<h2 id=\"Linux-安装\"><a href=\"#Linux-安装\" class=\"headerlink\" title=\"Linux 安装\"></a>Linux 安装</h2><p>我们并不一定要先卸载原有的 NodeJS。当然我们推荐还是先卸载掉比较好。另外，你还需要 C++ 编译器，Linux 发行版一般不用担心，像 Ubuntu 都可以直接用 build-essential 套件</p>\n<p>在 Linux 中：（如果是 Debian 发行版）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install build-essential</div></pre></td></tr></table></figure>\n<p>然后我们可以使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</div></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</div></pre></td></tr></table></figure>\n<p>从远程下载 install.sh 脚本并执行。注意这个版本年数字 v0.33.0 会随着项目开发而变化。随时通过<a href=\"https://github.com/creationix/nvm#install-script\" target=\"_blank\" rel=\"external\">官方最新安装命令</a>来检查最新安装版本是有好处的。</p>\n<h2 id=\"安装多版本-node-npm\"><a href=\"#安装多版本-node-npm\" class=\"headerlink\" title=\"安装多版本 node/npm\"></a>安装多版本 node/npm</h2><p>例如，我们要安装4.2.2版本，可以用如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm install 4.2.2</div></pre></td></tr></table></figure>\n<p>nvm 遵守语义化版本命名规则。例如，你想安装最新的 4.2 系列的最新的一个版本的话，可以运行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm install 4.2</div></pre></td></tr></table></figure></p>\n<p>nvm 会寻找 4.2.x 中最高的版本来安装。</p>\n<p>你可以通过以下命令来列出远程服务器上所有的可用版本：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm ls-remote</div></pre></td></tr></table></figure></p>\n<h2 id=\"在不同版本间切换\"><a href=\"#在不同版本间切换\" class=\"headerlink\" title=\"在不同版本间切换\"></a>在不同版本间切换</h2><p>每当我们安装了一个新版本 Node 后，全局环境会自动把这个新版本设置为默认。</p>\n<p>nvm 提供了 nvm use 命令。这个命令的使用方法和 install 命令类似。</p>\n<p>例如，切换到 4.2.2：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm use 4.2.2</div></pre></td></tr></table></figure></p>\n<p>切换到最新的 `4.2.x``：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm use 4.2</div></pre></td></tr></table></figure>\n<p>切换到最新版：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm use node</div></pre></td></tr></table></figure></p>\n<p>每次执行切换的时候，系统都会把 node 的可执行文件链接放到特定版本的文件上。</p>\n<p>我们还可以用 nvm 给不同的版本号设置别名：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm <span class=\"built_in\">alias</span> awesome-version 4.2.2</div></pre></td></tr></table></figure></p>\n<p>我们给 4.2.2 这个版本号起了一个名字叫做 awesome-version，然后我们可以运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm use awesome-version</div></pre></td></tr></table></figure>\n<p>下面这个命令可以取消别名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm <span class=\"built_in\">unalias</span> awesome-version</div></pre></td></tr></table></figure>\n<p>另外，你还可以设置 default 这个特殊别名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm <span class=\"built_in\">alias</span> default node</div></pre></td></tr></table></figure>\n<h2 id=\"列出已安装实例\"><a href=\"#列出已安装实例\" class=\"headerlink\" title=\"列出已安装实例\"></a>列出已安装实例</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm ls</div></pre></td></tr></table></figure>\n<p>上面绿色箭头是当前正在使用的版本，下面列出的还有设置过的别名。</p>\n<h2 id=\"在项目中使用不同版本的-Node\"><a href=\"#在项目中使用不同版本的-Node\" class=\"headerlink\" title=\"在项目中使用不同版本的 Node\"></a>在项目中使用不同版本的 Node</h2><p>我们可以通过创建项目目录中的 .nvmrc 文件来指定要使用的 Node 版本。之后在项目目录中执行 nvm use 即可。.nvmrc 文件内容只需要遵守上文提到的语义化版本规则即可。另外还有个工具叫做 avn，可以自动化这个过程。</p>\n<h2 id=\"在多环境中，使用npm\"><a href=\"#在多环境中，使用npm\" class=\"headerlink\" title=\"在多环境中，使用npm\"></a>在多环境中，使用npm</h2><p>每个版本的 Node 都会自带一个不同版本的 npm，可以用 npm -v 来查看 npm 的版本。全局安装的 npm 包并不会在不同的 Node 环境中共享，因为这会引起兼容问题。它们被放在了不同版本的目录下，例如 ~/.nvm/versions/node/<version>/lib/node_modules</version> 这样的目录。这刚好也省去我们在 Linux 中使用 sudo 的功夫了。因为这是用户的主文件夹，并不会引起权限问题。</p>\n<p>但问题来了，我们安装过的 npm 包，都要重新再装一次？幸运的是，我们有个办法来解决我们的问题，运行下面这个命令，可以从特定版本导入到我们将要安装的新版本 Node：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm install v5.0.0 --reinstall-packages-from=4.2</div></pre></td></tr></table></figure>\n<h2 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h2><p>直接运行特定版本的 Node</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm run 4.2.2 --version</div></pre></td></tr></table></figure>\n<p>在当前终端的子进程中运行特定版本的 Node</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm <span class=\"built_in\">exec</span> 4.2.2 node --version</div></pre></td></tr></table></figure>\n<p>确认某个版本Node的路径</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm <span class=\"built_in\">which</span> 4.2.2</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>在我们的日常开发中经常会遇到这种情况：手上有好几个项目，每个项目的需求不同，进而不同项目必须依赖不同版的 NodeJS 运行环境。如果没有一个合适的工具，这个问题将非常棘手。</p>\n<h2 id=\"nvm-与-n-的区别\"><a href=\"#nvm-与-n-的区别\" class=\"headerlink\" title=\"nvm 与 n 的区别\"></a>nvm 与 n 的区别</h2><p>node 版本管理工具还有一个是 n 命令，n 命令是作为一个 node 的模块而存在，而 nvm 是一个独立于 node/npm 的外部 bash 脚本，因此 n 命令相比 nvm 更加局限。</p>\n<p>由于 npm 安装的模块路径均为 /usr/local/lib/node_modules，当使用 n 切换不同的 node 版本时，实际上会共用全局的 node/npm 目录。 因此不能很好的满足『按不同 node 版本使用不同全局 node 模块』的需求。</p>\n<h2 id=\"卸载全局安装的-node-npm\"><a href=\"#卸载全局安装的-node-npm\" class=\"headerlink\" title=\"卸载全局安装的 node/npm\"></a>卸载全局安装的 node/npm</h2><p>在官网下载的 node 安装包，运行后会自动安装在全局目录，使用过程中经常会遇到一些权限问题，所以推荐卸载全局安装的 node/npm。</p>\n<h2 id=\"Linux-安装\"><a href=\"#Linux-安装\" class=\"headerlink\" title=\"Linux 安装\"></a>Linux 安装</h2><p>我们并不一定要先卸载原有的 NodeJS。当然我们推荐还是先卸载掉比较好。另外，你还需要 C++ 编译器，Linux 发行版一般不用担心，像 Ubuntu 都可以直接用 build-essential 套件</p>\n<p>在 Linux 中：（如果是 Debian 发行版）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install build-essential</div></pre></td></tr></table></figure>\n<p>然后我们可以使用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</div></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash</div></pre></td></tr></table></figure>\n<p>从远程下载 install.sh 脚本并执行。注意这个版本年数字 v0.33.0 会随着项目开发而变化。随时通过<a href=\"https://github.com/creationix/nvm#install-script\" target=\"_blank\" rel=\"external\">官方最新安装命令</a>来检查最新安装版本是有好处的。</p>\n<h2 id=\"安装多版本-node-npm\"><a href=\"#安装多版本-node-npm\" class=\"headerlink\" title=\"安装多版本 node/npm\"></a>安装多版本 node/npm</h2><p>例如，我们要安装4.2.2版本，可以用如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm install 4.2.2</div></pre></td></tr></table></figure>\n<p>nvm 遵守语义化版本命名规则。例如，你想安装最新的 4.2 系列的最新的一个版本的话，可以运行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm install 4.2</div></pre></td></tr></table></figure></p>\n<p>nvm 会寻找 4.2.x 中最高的版本来安装。</p>\n<p>你可以通过以下命令来列出远程服务器上所有的可用版本：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm ls-remote</div></pre></td></tr></table></figure></p>\n<h2 id=\"在不同版本间切换\"><a href=\"#在不同版本间切换\" class=\"headerlink\" title=\"在不同版本间切换\"></a>在不同版本间切换</h2><p>每当我们安装了一个新版本 Node 后，全局环境会自动把这个新版本设置为默认。</p>\n<p>nvm 提供了 nvm use 命令。这个命令的使用方法和 install 命令类似。</p>\n<p>例如，切换到 4.2.2：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm use 4.2.2</div></pre></td></tr></table></figure></p>\n<p>切换到最新的 `4.2.x``：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm use 4.2</div></pre></td></tr></table></figure>\n<p>切换到最新版：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm use node</div></pre></td></tr></table></figure></p>\n<p>每次执行切换的时候，系统都会把 node 的可执行文件链接放到特定版本的文件上。</p>\n<p>我们还可以用 nvm 给不同的版本号设置别名：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm <span class=\"built_in\">alias</span> awesome-version 4.2.2</div></pre></td></tr></table></figure></p>\n<p>我们给 4.2.2 这个版本号起了一个名字叫做 awesome-version，然后我们可以运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm use awesome-version</div></pre></td></tr></table></figure>\n<p>下面这个命令可以取消别名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm <span class=\"built_in\">unalias</span> awesome-version</div></pre></td></tr></table></figure>\n<p>另外，你还可以设置 default 这个特殊别名：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm <span class=\"built_in\">alias</span> default node</div></pre></td></tr></table></figure>\n<h2 id=\"列出已安装实例\"><a href=\"#列出已安装实例\" class=\"headerlink\" title=\"列出已安装实例\"></a>列出已安装实例</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm ls</div></pre></td></tr></table></figure>\n<p>上面绿色箭头是当前正在使用的版本，下面列出的还有设置过的别名。</p>\n<h2 id=\"在项目中使用不同版本的-Node\"><a href=\"#在项目中使用不同版本的-Node\" class=\"headerlink\" title=\"在项目中使用不同版本的 Node\"></a>在项目中使用不同版本的 Node</h2><p>我们可以通过创建项目目录中的 .nvmrc 文件来指定要使用的 Node 版本。之后在项目目录中执行 nvm use 即可。.nvmrc 文件内容只需要遵守上文提到的语义化版本规则即可。另外还有个工具叫做 avn，可以自动化这个过程。</p>\n<h2 id=\"在多环境中，使用npm\"><a href=\"#在多环境中，使用npm\" class=\"headerlink\" title=\"在多环境中，使用npm\"></a>在多环境中，使用npm</h2><p>每个版本的 Node 都会自带一个不同版本的 npm，可以用 npm -v 来查看 npm 的版本。全局安装的 npm 包并不会在不同的 Node 环境中共享，因为这会引起兼容问题。它们被放在了不同版本的目录下，例如 ~/.nvm/versions/node/<version>/lib/node_modules</version> 这样的目录。这刚好也省去我们在 Linux 中使用 sudo 的功夫了。因为这是用户的主文件夹，并不会引起权限问题。</p>\n<p>但问题来了，我们安装过的 npm 包，都要重新再装一次？幸运的是，我们有个办法来解决我们的问题，运行下面这个命令，可以从特定版本导入到我们将要安装的新版本 Node：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm install v5.0.0 --reinstall-packages-from=4.2</div></pre></td></tr></table></figure>\n<h2 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h2><p>直接运行特定版本的 Node</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm run 4.2.2 --version</div></pre></td></tr></table></figure>\n<p>在当前终端的子进程中运行特定版本的 Node</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm <span class=\"built_in\">exec</span> 4.2.2 node --version</div></pre></td></tr></table></figure>\n<p>确认某个版本Node的路径</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nvm <span class=\"built_in\">which</span> 4.2.2</div></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj8dw0nf90000qnjxg1gvlkkr","tag_id":"cj8dw0nfk0004qnjxt118u0tt","_id":"cj8dw0nft000aqnjxh8ctlh23"},{"post_id":"cj8dw0nfh0002qnjxn3luwe37","tag_id":"cj8dw0nfs0009qnjx6icp69p4","_id":"cj8dw0nfy000fqnjx8kff6rzi"},{"post_id":"cj8dw0nfh0002qnjxn3luwe37","tag_id":"cj8dw0nfx000dqnjxagx8klhz","_id":"cj8dw0nfy000gqnjx2daba063"},{"post_id":"cj8dw0nfn0005qnjxfqx22bsy","tag_id":"cj8dw0nfy000eqnjxo8778bjx","_id":"cj8dw0nfz000jqnjxbcaxbv1y"},{"post_id":"cj8dw0nfn0005qnjxfqx22bsy","tag_id":"cj8dw0nfz000hqnjxxcrhd5zo","_id":"cj8dw0ng0000kqnjx5dtd55tv"},{"post_id":"cj8dw0nfq0007qnjx6mw4pfck","tag_id":"cj8dw0nfz000iqnjxfjtcw68s","_id":"cj8dw0ng0000mqnjxx53o2khu"},{"post_id":"cj8dw0nfr0008qnjxcpswc6k7","tag_id":"cj8dw0ng0000lqnjxl37zf773","_id":"cj8dw0ng1000oqnjxq3y0glk5"},{"post_id":"cj8dw0nfu000bqnjx40qhf1i0","tag_id":"cj8dw0ng0000nqnjxxl0l0y4h","_id":"cj8dw0ng1000qqnjxidzm8rda"},{"post_id":"cj8dw0nfw000cqnjxkdhh44w3","tag_id":"cj8dw0ng1000pqnjxlss9dcz6","_id":"cj8dw0ng2000rqnjxjwbg1iuc"}],"Tag":[{"name":"C++","_id":"cj8dw0nfk0004qnjxt118u0tt"},{"name":"Github","_id":"cj8dw0nfs0009qnjx6icp69p4"},{"name":"hexo","_id":"cj8dw0nfx000dqnjxagx8klhz"},{"name":"Polymer","_id":"cj8dw0nfy000eqnjxo8778bjx"},{"name":"Web","_id":"cj8dw0nfz000hqnjxxcrhd5zo"},{"name":"Postgresql","_id":"cj8dw0nfz000iqnjxfjtcw68s"},{"name":"Rust","_id":"cj8dw0ng0000lqnjxl37zf773"},{"name":"Linux","_id":"cj8dw0ng0000nqnjxxl0l0y4h"},{"name":"Node","_id":"cj8dw0ng1000pqnjxlss9dcz6"}]}}